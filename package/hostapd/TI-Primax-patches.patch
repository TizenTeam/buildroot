diff -Nur hostapd-2.0/hostapd/android.config hostapd-2.0-TI/hostapd/android.config
--- hostapd-2.0/hostapd/android.config	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/hostapd/android.config	2014-03-28 17:49:32.000000000 +0800
@@ -20,7 +20,7 @@
 #CFLAGS += -I../../madwifi # change to the madwifi source directory
 
 # Driver interface for drivers using the nl80211 kernel interface
-#CONFIG_DRIVER_NL80211=y
+CONFIG_DRIVER_NL80211=y
 # driver_nl80211.c requires a rather new libnl (version 1.1) which may not be
 # shipped with your distribution yet. If that is the case, you need to build
 # newer libnl version and point the hostapd build to use it.
diff -Nur hostapd-2.0/hostapd/Android.mk hostapd-2.0-TI/hostapd/Android.mk
--- hostapd-2.0/hostapd/Android.mk	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/hostapd/Android.mk	2014-03-28 17:49:32.000000000 +0800
@@ -24,6 +24,19 @@
 # Set Android log name
 L_CFLAGS += -DANDROID_LOG_NAME=\"hostapd\"
 
+ifeq ($(BOARD_WLAN_DEVICE), bcmdhd)
+L_CFLAGS += -DANDROID_BRCM_P2P_PATCH
+endif
+
+L_CFLAGS += -DANDROID_P2P
+
+# Use Android specific directory for control interface sockets
+L_CFLAGS += -DCONFIG_CTRL_IFACE_CLIENT_DIR=\"/data/misc/wifi/sockets\"
+
+# Use Android specific directory for control interface sockets
+L_CFLAGS += -DCONFIG_CTRL_IFACE_CLIENT_DIR=\"/data/misc/wifi/sockets\"
+L_CFLAGS += -DCONFIG_CTRL_IFACE_DIR=\"/data/system/hostapd\"
+
 # To force sizeof(enum) = 4
 ifeq ($(TARGET_ARCH),arm)
 L_CFLAGS += -mabi=aapcs-linux
@@ -32,9 +45,6 @@
 # To allow non-ASCII characters in SSID
 L_CFLAGS += -DWPA_UNICODE_SSID
 
-# OpenSSL is configured without engines on Android
-L_CFLAGS += -DOPENSSL_NO_ENGINE
-
 INCLUDES = $(LOCAL_PATH)
 INCLUDES += $(LOCAL_PATH)/src
 INCLUDES += $(LOCAL_PATH)/src/utils
@@ -828,7 +838,8 @@
 LOCAL_STATIC_LIBRARIES := libCustomWifi
 endif
 ifneq ($(BOARD_HOSTAPD_PRIVATE_LIB),)
-LOCAL_STATIC_LIBRARIES += $(BOARD_HOSTAPD_PRIVATE_LIB)
+##Build as part of hostapd build now
+##LOCAL_STATIC_LIBRARIES += $(BOARD_HOSTAPD_PRIVATE_LIB)
 endif
 LOCAL_SHARED_LIBRARIES := libc libcutils libcrypto libssl
 ifdef CONFIG_DRIVER_NL80211
diff -Nur hostapd-2.0/hostapd/config_file.c hostapd-2.0-TI/hostapd/config_file.c
--- hostapd-2.0/hostapd/config_file.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/hostapd/config_file.c	2014-03-28 17:49:32.000000000 +0800
@@ -116,8 +116,8 @@
 }
 
 
-static int hostapd_config_read_maclist(const char *fname,
-				       struct mac_acl_entry **acl, int *num)
+int hostapd_config_read_maclist(const char *fname,
+				struct mac_acl_entry **acl, int *num)
 {
 	FILE *f;
 	char buf[128], *pos;
@@ -1780,8 +1780,6 @@
 				bss->ssid.ssid_set = 1;
 			}
 			os_free(str);
-		} else if (os_strcmp(buf, "utf8_ssid") == 0) {
-			bss->ssid.utf8_ssid = atoi(pos) > 0;
 		} else if (os_strcmp(buf, "macaddr_acl") == 0) {
 			bss->macaddr_acl = atoi(pos);
 			if (bss->macaddr_acl != ACCEPT_UNLESS_DENIED &&
@@ -2313,8 +2311,6 @@
 				conf->hw_mode = HOSTAPD_MODE_IEEE80211B;
 			else if (os_strcmp(pos, "g") == 0)
 				conf->hw_mode = HOSTAPD_MODE_IEEE80211G;
-			else if (os_strcmp(pos, "ad") == 0)
-				conf->hw_mode = HOSTAPD_MODE_IEEE80211AD;
 			else {
 				wpa_printf(MSG_ERROR, "Line %d: unknown "
 					   "hw_mode '%s'", line, pos);
@@ -2397,6 +2393,20 @@
 					   "list", line);
 				errors++;
 			}
+		} else if (os_strcmp(buf, "acs_blacklist") == 0) {
+			/* these are not rates but the same function will do */
+			if (hostapd_parse_rates(&conf->acs_blacklist, pos)) {
+				wpa_printf(MSG_ERROR, "Line %d: invalid acs "
+					   "black list", line);
+				errors++;
+			}
+		} else if (os_strcmp(buf, "acs_whitelist") == 0) {
+			/* these are not rates but the same function will do */
+			if (hostapd_parse_rates(&conf->acs_whitelist, pos)) {
+				wpa_printf(MSG_ERROR, "Line %d: invalid acs "
+					   "white list", line);
+				errors++;
+			}
 		} else if (os_strcmp(buf, "preamble") == 0) {
 			if (atoi(pos))
 				conf->preamble = SHORT_PREAMBLE;
@@ -2721,12 +2731,6 @@
 			bss->time_zone = os_strdup(pos);
 			if (bss->time_zone == NULL)
 				errors++;
-#ifdef CONFIG_WNM
-		} else if (os_strcmp(buf, "wnm_sleep_mode") == 0) {
-			bss->wnm_sleep_mode = atoi(pos);
-		} else if (os_strcmp(buf, "bss_transition") == 0) {
-			bss->bss_transition = atoi(pos);
-#endif /* CONFIG_WNM */
 #ifdef CONFIG_INTERWORKING
 		} else if (os_strcmp(buf, "interworking") == 0) {
 			bss->interworking = atoi(pos);
@@ -2935,6 +2939,8 @@
 
 			wpabuf_free(bss->vendor_elements);
 			bss->vendor_elements = elems;
+		} else if (os_strcmp(buf, "ap_channel_sync") == 0) {
+			conf->ap_channel_sync = atoi(pos);
 		} else {
 			wpa_printf(MSG_ERROR, "Line %d: unknown configuration "
 				   "item '%s'", line, buf);
diff -Nur hostapd-2.0/hostapd/config_file.h hostapd-2.0-TI/hostapd/config_file.h
--- hostapd-2.0/hostapd/config_file.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/hostapd/config_file.h	2014-03-28 17:49:32.000000000 +0800
@@ -13,5 +13,7 @@
 int hostapd_set_iface(struct hostapd_config *conf,
 		      struct hostapd_bss_config *bss, char *field,
 		      char *value);
+int hostapd_config_read_maclist(const char *fname,
+				struct mac_acl_entry **acl, int *num);
 
 #endif /* CONFIG_FILE_H */
diff -Nur hostapd-2.0/hostapd/ctrl_iface.c hostapd-2.0-TI/hostapd/ctrl_iface.c
--- hostapd-2.0/hostapd/ctrl_iface.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/hostapd/ctrl_iface.c	2014-03-28 17:49:32.000000000 +0800
@@ -13,6 +13,9 @@
 #include <sys/un.h>
 #include <sys/stat.h>
 #include <stddef.h>
+#ifdef ANDROID
+#include <cutils/sockets.h>
+#endif /* ANDROID */
 
 #include "utils/common.h"
 #include "utils/eloop.h"
@@ -436,50 +439,6 @@
 #endif /* CONFIG_WPS */
 
 
-#ifdef CONFIG_WNM
-
-static int hostapd_ctrl_iface_disassoc_imminent(struct hostapd_data *hapd,
-						const char *cmd)
-{
-	u8 addr[ETH_ALEN];
-	u8 buf[1000], *pos;
-	struct ieee80211_mgmt *mgmt;
-	int disassoc_timer;
-
-	if (hwaddr_aton(cmd, addr))
-		return -1;
-	if (cmd[17] != ' ')
-		return -1;
-	disassoc_timer = atoi(cmd + 17);
-
-	os_memset(buf, 0, sizeof(buf));
-	mgmt = (struct ieee80211_mgmt *) buf;
-	mgmt->frame_control = IEEE80211_FC(WLAN_FC_TYPE_MGMT,
-					   WLAN_FC_STYPE_ACTION);
-	os_memcpy(mgmt->da, addr, ETH_ALEN);
-	os_memcpy(mgmt->sa, hapd->own_addr, ETH_ALEN);
-	os_memcpy(mgmt->bssid, hapd->own_addr, ETH_ALEN);
-	mgmt->u.action.category = WLAN_ACTION_WNM;
-	mgmt->u.action.u.bss_tm_req.action = WNM_BSS_TRANS_MGMT_REQ;
-	mgmt->u.action.u.bss_tm_req.dialog_token = 1;
-	mgmt->u.action.u.bss_tm_req.req_mode =
-		WNM_BSS_TM_REQ_DISASSOC_IMMINENT;
-	mgmt->u.action.u.bss_tm_req.disassoc_timer =
-		host_to_le16(disassoc_timer);
-	mgmt->u.action.u.bss_tm_req.validity_interval = 0;
-
-	pos = mgmt->u.action.u.bss_tm_req.variable;
-
-	if (hostapd_drv_send_mlme(hapd, buf, pos - buf, 0) < 0) {
-		wpa_printf(MSG_DEBUG, "Failed to send BSS Transition "
-			   "Management Request frame");
-		return -1;
-	}
-
-	return 0;
-}
-
-
 static int hostapd_ctrl_iface_ess_disassoc(struct hostapd_data *hapd,
 					   const char *cmd)
 {
@@ -530,7 +489,41 @@
 	return 0;
 }
 
-#endif /* CONFIG_WNM */
+
+static int hostapd_ctrl_iface_set_accept_mac(struct hostapd_data *hapd,
+					     char *fname)
+{
+	hapd->conf->num_accept_mac = 0;
+
+	if (hostapd_config_read_maclist(fname, &hapd->conf->accept_mac,
+					&hapd->conf->num_accept_mac)) {
+		wpa_printf(MSG_ERROR, "Reading mac list from file failed");
+		return -1;
+	}
+
+	/* Accept mac list changed, check if need to deauth stations*/
+	hostapd_macaddr_acl_accept_sta(hapd);
+
+	return 0;
+}
+
+
+static int hostapd_ctrl_iface_set_deny_mac(struct hostapd_data *hapd,
+					   char *fname)
+{
+	hapd->conf->num_deny_mac = 0;
+
+	if (hostapd_config_read_maclist(fname, &hapd->conf->deny_mac,
+					&hapd->conf->num_deny_mac)) {
+		wpa_printf(MSG_ERROR, "Reading mac list from file failed");
+		return -1;
+	}
+
+	/* Deny mac list changed, check if need to deauth stations*/
+	hostapd_macaddr_acl_deny_sta(hapd);
+
+	return 0;
+}
 
 
 static int hostapd_ctrl_iface_get_config(struct hostapd_data *hapd,
@@ -761,6 +754,12 @@
 		else
 			hapd->gas_frag_limit = val;
 #endif /* CONFIG_INTERWORKING */
+	} else if (os_strcasecmp(cmd, "macaddr_acl") == 0) {
+		ret = hostapd_macaddr_acl_command(hapd, value);
+	} else if (os_strcasecmp(cmd, "accept_mac_file") == 0) {
+		ret = hostapd_ctrl_iface_set_accept_mac(hapd, value);
+	} else if (os_strcasecmp(cmd, "deny_mac_file") == 0) {
+		ret = hostapd_ctrl_iface_set_deny_mac(hapd, value);
 	} else {
 		ret = hostapd_set_iface(hapd->iconf, hapd->conf, cmd, value);
 	}
@@ -952,14 +951,9 @@
 			hapd, buf + 14, reply, reply_size);
 #endif /* CONFIG_WPS_NFC */
 #endif /* CONFIG_WPS */
-#ifdef CONFIG_WNM
-	} else if (os_strncmp(buf, "DISASSOC_IMMINENT ", 18) == 0) {
-		if (hostapd_ctrl_iface_disassoc_imminent(hapd, buf + 18))
-			reply_len = -1;
 	} else if (os_strncmp(buf, "ESS_DISASSOC ", 13) == 0) {
 		if (hostapd_ctrl_iface_ess_disassoc(hapd, buf + 13))
 			reply_len = -1;
-#endif /* CONFIG_WNM */
 	} else if (os_strcmp(buf, "GET_CONFIG") == 0) {
 		reply_len = hostapd_ctrl_iface_get_config(hapd, reply,
 							  reply_size);
@@ -1037,6 +1031,14 @@
 	if (hapd->conf->ctrl_interface == NULL)
 		return 0;
 
+#ifdef ANDROID
+	os_snprintf(addr.sun_path, sizeof(addr.sun_path), "wpa_%s",
+		    hapd->conf->ctrl_interface);
+	s = android_get_control_socket(addr.sun_path);
+	if (s >= 0)
+		goto havesock;
+#endif /* ANDROID */
+
 	if (mkdir(hapd->conf->ctrl_interface, S_IRWXU | S_IRWXG) < 0) {
 		if (errno == EEXIST) {
 			wpa_printf(MSG_DEBUG, "Using existing control "
@@ -1048,27 +1050,12 @@
 	}
 
 	if (hapd->conf->ctrl_interface_gid_set &&
-	    chown(hapd->conf->ctrl_interface, -1,
+	    chown(hapd->conf->ctrl_interface, 0,
 		  hapd->conf->ctrl_interface_gid) < 0) {
 		perror("chown[ctrl_interface]");
 		return -1;
 	}
 
-#ifdef ANDROID
-	/*
-	 * Android is using umask 0077 which would leave the control interface
-	 * directory without group access. This breaks things since Wi-Fi
-	 * framework assumes that this directory can be accessed by other
-	 * applications in the wifi group. Fix this by adding group access even
-	 * if umask value would prevent this.
-	 */
-	if (chmod(hapd->conf->ctrl_interface, S_IRWXU | S_IRWXG) < 0) {
-		wpa_printf(MSG_ERROR, "CTRL: Could not chmod directory: %s",
-			   strerror(errno));
-		/* Try to continue anyway */
-	}
-#endif /* ANDROID */
-
 	if (os_strlen(hapd->conf->ctrl_interface) + 1 +
 	    os_strlen(hapd->conf->iface) >= sizeof(addr.sun_path))
 		goto fail;
@@ -1121,7 +1108,7 @@
 	}
 
 	if (hapd->conf->ctrl_interface_gid_set &&
-	    chown(fname, -1, hapd->conf->ctrl_interface_gid) < 0) {
+	    chown(fname, 0, hapd->conf->ctrl_interface_gid) < 0) {
 		perror("chown[ctrl_interface/ifname]");
 		goto fail;
 	}
@@ -1132,6 +1119,9 @@
 	}
 	os_free(fname);
 
+#ifdef ANDROID
+havesock:
+#endif /* ANDROID */
 	hapd->ctrl_sock = s;
 	eloop_register_read_sock(s, hostapd_ctrl_iface_receive, hapd,
 				 NULL);
diff -Nur hostapd-2.0/hostapd/hostapd_cli.c hostapd-2.0-TI/hostapd/hostapd_cli.c
--- hostapd-2.0/hostapd/hostapd_cli.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/hostapd/hostapd_cli.c	2014-03-28 17:49:32.000000000 +0800
@@ -14,6 +14,9 @@
 #include "utils/eloop.h"
 #include "utils/edit.h"
 #include "common/version.h"
+#ifdef ANDROID
+#include <cutils/properties.h>
+#endif /* ANDROID */
 
 
 static const char *hostapd_cli_version =
@@ -90,7 +93,12 @@
 static struct wpa_ctrl *ctrl_conn;
 static int hostapd_cli_quit = 0;
 static int hostapd_cli_attached = 0;
-static const char *ctrl_iface_dir = "/var/run/hostapd";
+
+#ifndef CONFIG_CTRL_IFACE_DIR
+#define CONFIG_CTRL_IFACE_DIR "/var/run/hostapd"
+#endif /* CONFIG_CTRL_IFACE_DIR */
+static const char *ctrl_iface_dir = CONFIG_CTRL_IFACE_DIR;
+
 static char *ctrl_ifname = NULL;
 static const char *pid_file = NULL;
 static const char *action_file = NULL;
@@ -126,17 +134,27 @@
 
 static struct wpa_ctrl * hostapd_cli_open_connection(const char *ifname)
 {
-	char *cfile;
+	char *cfile = NULL;
 	int flen;
 
 	if (ifname == NULL)
 		return NULL;
 
-	flen = strlen(ctrl_iface_dir) + strlen(ifname) + 2;
-	cfile = malloc(flen);
-	if (cfile == NULL)
-		return NULL;
-	snprintf(cfile, flen, "%s/%s", ctrl_iface_dir, ifname);
+#ifdef ANDROID
+	if (access(ctrl_iface_dir, F_OK) < 0) {
+		cfile = os_strdup(ifname);
+		if (cfile == NULL)
+			return NULL;
+	}
+#endif /* ANDROID */
+
+	if (cfile == NULL) {
+		flen = strlen(ctrl_iface_dir) + strlen(ifname) + 2;
+		cfile = malloc(flen);
+		if (cfile == NULL)
+			return NULL;
+		snprintf(cfile, flen, "%s/%s", ctrl_iface_dir, ifname);
+	}
 
 	ctrl_conn = wpa_ctrl_open(cfile);
 	free(cfile);
@@ -539,26 +557,6 @@
 #endif /* CONFIG_WPS */
 
 
-static int hostapd_cli_cmd_disassoc_imminent(struct wpa_ctrl *ctrl, int argc,
-					     char *argv[])
-{
-	char buf[300];
-	int res;
-
-	if (argc < 2) {
-		printf("Invalid 'disassoc_imminent' command - two arguments "
-		       "(STA addr and Disassociation Timer) are needed\n");
-		return -1;
-	}
-
-	res = os_snprintf(buf, sizeof(buf), "DISASSOC_IMMINENT %s %s",
-			  argv[0], argv[1]);
-	if (res < 0 || res >= (int) sizeof(buf))
-		return -1;
-	return wpa_ctrl_command(ctrl, buf);
-}
-
-
 static int hostapd_cli_cmd_ess_disassoc(struct wpa_ctrl *ctrl, int argc,
 					char *argv[])
 {
@@ -795,7 +793,6 @@
 	{ "wps_ap_pin", hostapd_cli_cmd_wps_ap_pin },
 	{ "wps_config", hostapd_cli_cmd_wps_config },
 #endif /* CONFIG_WPS */
-	{ "disassoc_imminent", hostapd_cli_cmd_disassoc_imminent },
 	{ "ess_disassoc", hostapd_cli_cmd_ess_disassoc },
 	{ "get_config", hostapd_cli_cmd_get_config },
 	{ "help", hostapd_cli_cmd_help },
@@ -1085,6 +1082,18 @@
 				}
 				closedir(dir);
 			}
+#ifdef ANDROID
+			else {
+				char ifprop[PROPERTY_VALUE_MAX];
+				int res = property_get("ap.interface", ifprop,
+						       NULL);
+				if (!res) {
+					ctrl_ifname = os_strdup(ifprop);
+					printf("Using interface '%s'\n",
+					       ctrl_ifname);
+				}
+			}
+#endif /* ANDROID */
 		}
 		ctrl_conn = hostapd_cli_open_connection(ctrl_ifname);
 		if (ctrl_conn) {
diff -Nur hostapd-2.0/hostapd/hostapd.conf hostapd-2.0-TI/hostapd/hostapd.conf
--- hostapd-2.0/hostapd/hostapd.conf	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/hostapd/hostapd.conf	2014-03-28 17:49:32.000000000 +0800
@@ -90,9 +90,6 @@
 #ssid2=74657374
 #ssid2=P"hello\nthere"
 
-# UTF-8 SSID: Whether the SSID is to be interpreted using UTF-8 encoding
-#utf8_ssid=1
-
 # Country code (ISO/IEC 3166-1). Used to set regulatory domain.
 # Set as needed to indicate country in which device is operating.
 # This can limit available channels and transmit power.
@@ -106,8 +103,6 @@
 #ieee80211d=1
 
 # Operation mode (a = IEEE 802.11a, b = IEEE 802.11b, g = IEEE 802.11g,
-# ad = IEEE 802.11ad (60 GHz); a/g options are used with IEEE 802.11n, too, to
-# specify band)
 # Default: IEEE 802.11b
 hw_mode=g
 
@@ -115,8 +110,27 @@
 # (default: 0, i.e., not set)
 # Please note that some drivers do not use this value from hostapd and the
 # channel will need to be configured separately with iwconfig.
+# When set to 0, automatic channel selection will be engaged. A channel
+# will be selected from the desired hw_mode.
 channel=1
 
+# Automatic channel selection (ACS) whitelist
+# (default: not set)
+# Allow only these channels in automatic channel selection
+# acs_whitelist=1 2 3 4 5 6 7 8 9 10 11
+
+# Automatic channel selection (ACS) blacklist
+# (default: not set)
+# Don't allow these channels in automatic channel selection
+# acs_blacklist=1 2 3 4 5 6 7 8 9 10 11
+
+# Sync channel to previous operational APs
+# (default: 0)
+# Set to 1 in order to sync the channel of the current AP to the
+# channel of an operational radio on the same PHY. Note that this
+# applies to the 40Mhz operating channel (primary + secondary)
+#ap_channel_sync=0
+
 # Beacon interval in kus (1.024 ms) (default: 100; range 15..65535)
 beacon_int=100
 
@@ -1305,16 +1319,6 @@
 # stdoffset[dst[offset][,start[/time],end[/time]]]
 #time_zone=EST5
 
-# WNM-Sleep Mode (extended sleep mode for stations)
-# 0 = disabled (default)
-# 1 = enabled (allow stations to use WNM-Sleep Mode)
-#wnm_sleep_mode=1
-
-# BSS Transition Management
-# 0 = disabled (default)
-# 1 = enabled
-#bss_transition=1
-
 ##### IEEE 802.11u-2011 #######################################################
 
 # Enable Interworking service
diff -Nur hostapd-2.0/hostapd/Makefile hostapd-2.0-TI/hostapd/Makefile
--- hostapd-2.0/hostapd/Makefile	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/hostapd/Makefile	2014-03-28 17:49:32.000000000 +0800
@@ -176,8 +176,8 @@
 CFLAGS += -DCONFIG_SAE
 endif
 
-ifdef CONFIG_WNM
-CFLAGS += -DCONFIG_WNM
+ifdef CONFIG_IEEE80211V
+CFLAGS += -DCONFIG_IEEE80211V
 OBJS += ../src/ap/wnm_ap.o
 endif
 
@@ -185,6 +185,10 @@
 CFLAGS += -DCONFIG_IEEE80211N
 endif
 
+ifdef CONFIG_WNM
+CFLAGS += -DCONFIG_WNM
+endif
+
 ifdef CONFIG_IEEE80211AC
 CFLAGS += -DCONFIG_IEEE80211AC
 endif
diff -Nur hostapd-2.0/src/ap/accounting.c hostapd-2.0-TI/src/ap/accounting.c
--- hostapd-2.0/src/ap/accounting.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/accounting.c	2014-03-28 17:49:32.000000000 +0800
@@ -26,6 +26,8 @@
  * input/output octets and updates Acct-{Input,Output}-Gigawords. */
 #define ACCT_DEFAULT_UPDATE_INTERVAL 300
 
+static void accounting_sta_get_id(struct hostapd_data *hapd,
+				  struct sta_info *sta);
 static void accounting_sta_interim(struct hostapd_data *hapd,
 				   struct sta_info *sta);
 
@@ -208,6 +210,7 @@
 	if (sta->acct_session_started)
 		return;
 
+	accounting_sta_get_id(hapd, sta);
 	hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_RADIUS,
 		       HOSTAPD_LEVEL_INFO,
 		       "starting accounting session %08X-%08X",
@@ -374,7 +377,7 @@
 }
 
 
-void accounting_sta_get_id(struct hostapd_data *hapd,
+static void accounting_sta_get_id(struct hostapd_data *hapd,
 				  struct sta_info *sta)
 {
 	sta->acct_session_id_lo = hapd->acct_session_id_lo++;
diff -Nur hostapd-2.0/src/ap/accounting.h hostapd-2.0-TI/src/ap/accounting.h
--- hostapd-2.0/src/ap/accounting.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/accounting.h	2014-03-28 17:49:32.000000000 +0800
@@ -10,11 +10,6 @@
 #define ACCOUNTING_H
 
 #ifdef CONFIG_NO_ACCOUNTING
-static inline void accounting_sta_get_id(struct hostapd_data *hapd,
-					 struct sta_info *sta)
-{
-}
-
 static inline void accounting_sta_start(struct hostapd_data *hapd,
 					struct sta_info *sta)
 {
@@ -34,7 +29,6 @@
 {
 }
 #else /* CONFIG_NO_ACCOUNTING */
-void accounting_sta_get_id(struct hostapd_data *hapd, struct sta_info *sta);
 void accounting_sta_start(struct hostapd_data *hapd, struct sta_info *sta);
 void accounting_sta_stop(struct hostapd_data *hapd, struct sta_info *sta);
 int accounting_init(struct hostapd_data *hapd);
diff -Nur hostapd-2.0/src/ap/ap_config.c hostapd-2.0-TI/src/ap/ap_config.c
--- hostapd-2.0/src/ap/ap_config.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/ap_config.c	2014-03-28 17:49:32.000000000 +0800
@@ -158,9 +158,6 @@
 
 	conf->ht_capab = HT_CAP_INFO_SMPS_DISABLED;
 
-	conf->ap_table_max_size = 255;
-	conf->ap_table_expiration_time = 60;
-
 	return conf;
 }
 
diff -Nur hostapd-2.0/src/ap/ap_config.h hostapd-2.0-TI/src/ap/ap_config.h
--- hostapd-2.0/src/ap/ap_config.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/ap_config.h	2014-03-28 17:49:32.000000000 +0800
@@ -51,8 +51,7 @@
 struct hostapd_ssid {
 	u8 ssid[HOSTAPD_MAX_SSID_LEN];
 	size_t ssid_len;
-	unsigned int ssid_set:1;
-	unsigned int utf8_ssid:1;
+	int ssid_set;
 
 	char vlan[IFNAMSIZ + 1];
 	secpolicy security_policy;
@@ -391,8 +390,6 @@
 	/* IEEE 802.11v */
 	int time_advertisement;
 	char *time_zone;
-	int wnm_sleep_mode;
-	int bss_transition;
 
 	/* IEEE 802.11u - Interworking */
 	int interworking;
@@ -515,6 +512,11 @@
 	u8 vht_oper_chwidth;
 	u8 vht_oper_centr_freq_seg0_idx;
 	u8 vht_oper_centr_freq_seg1_idx;
+
+	int *acs_blacklist;
+	int *acs_whitelist;
+
+	int ap_channel_sync;
 };
 
 
diff -Nur hostapd-2.0/src/ap/ap_drv_ops.c hostapd-2.0-TI/src/ap/ap_drv_ops.c
--- hostapd-2.0/src/ap/ap_drv_ops.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/ap_drv_ops.c	2014-04-17 17:31:01.000000000 +0800
@@ -504,6 +504,13 @@
 	return hapd->driver->set_country(hapd->drv_priv, country);
 }
 
+int hostapd_get_country(struct hostapd_data *hapd, char *country)
+{
+	if (hapd->driver == NULL ||
+	    hapd->driver->get_country == NULL)
+		return 0;
+	return hapd->driver->get_country(hapd->drv_priv, country);
+}
 
 int hostapd_set_tx_queue_params(struct hostapd_data *hapd, int queue, int aifs,
 				int cw_min, int cw_max, int burst_time)
diff -Nur hostapd-2.0/src/ap/ap_drv_ops.h hostapd-2.0-TI/src/ap/ap_drv_ops.h
--- hostapd-2.0/src/ap/ap_drv_ops.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/ap_drv_ops.h	2014-04-17 17:31:08.000000000 +0800
@@ -61,6 +61,7 @@
 int hostapd_sta_set_flags(struct hostapd_data *hapd, u8 *addr,
 			  int total_flags, int flags_or, int flags_and);
 int hostapd_set_country(struct hostapd_data *hapd, const char *country);
+int hostapd_get_country(struct hostapd_data *hapd, char *country);
 int hostapd_set_tx_queue_params(struct hostapd_data *hapd, int queue, int aifs,
 				int cw_min, int cw_max, int burst_time);
 struct hostapd_hw_modes *
@@ -213,4 +214,26 @@
 	hapd->driver->poll_client(hapd->drv_priv, own_addr, addr, qos);
 }
 
+static inline int hostapd_drv_set_priority(struct hostapd_data *hapd)
+{
+	if (hapd->driver == NULL || hapd->driver->set_priority == NULL)
+		return 0;
+	return hapd->driver->set_priority(hapd->drv_priv);
+}
+
+static inline int hostapd_drv_cancel_priority(struct hostapd_data *hapd)
+{
+	if (hapd->driver == NULL || hapd->driver->cancel_priority == NULL)
+		return 0;
+	return hapd->driver->cancel_priority(hapd->drv_priv);
+}
+
+static inline int hostapd_drv_shared_ap_freq(struct hostapd_data *hapd,
+					     struct wpa_channel_info *info)
+{
+	if (hapd->driver == NULL || hapd->driver->shared_ap_freq == NULL)
+		return -1;
+	return hapd->driver->shared_ap_freq(hapd->drv_priv, info);
+}
+
 #endif /* AP_DRV_OPS */
diff -Nur hostapd-2.0/src/ap/beacon.c hostapd-2.0-TI/src/ap/beacon.c
--- hostapd-2.0/src/ap/beacon.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/beacon.c	2014-03-28 17:49:32.000000000 +0800
@@ -2,7 +2,7 @@
  * hostapd / IEEE 802.11 Management: Beacon and Probe Request/Response
  * Copyright (c) 2002-2004, Instant802 Networks, Inc.
  * Copyright (c) 2005-2006, Devicescape Software, Inc.
- * Copyright (c) 2008-2012, Jouni Malinen <j@w1.fi>
+ * Copyright (c) 2008-2009, Jouni Malinen <j@w1.fi>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -310,46 +310,6 @@
 }
 
 
-enum ssid_match_result {
-	NO_SSID_MATCH,
-	EXACT_SSID_MATCH,
-	WILDCARD_SSID_MATCH
-};
-
-static enum ssid_match_result ssid_match(struct hostapd_data *hapd,
-					 const u8 *ssid, size_t ssid_len,
-					 const u8 *ssid_list,
-					 size_t ssid_list_len)
-{
-	const u8 *pos, *end;
-	int wildcard = 0;
-
-	if (ssid_len == 0)
-		wildcard = 1;
-	if (ssid_len == hapd->conf->ssid.ssid_len &&
-	    os_memcmp(ssid, hapd->conf->ssid.ssid, ssid_len) == 0)
-		return EXACT_SSID_MATCH;
-
-	if (ssid_list == NULL)
-		return wildcard ? WILDCARD_SSID_MATCH : NO_SSID_MATCH;
-
-	pos = ssid_list;
-	end = ssid_list + ssid_list_len;
-	while (pos + 1 <= end) {
-		if (pos + 2 + pos[1] > end)
-			break;
-		if (pos[1] == 0)
-			wildcard = 1;
-		if (pos[1] == hapd->conf->ssid.ssid_len &&
-		    os_memcmp(pos + 2, hapd->conf->ssid.ssid, pos[1]) == 0)
-			return EXACT_SSID_MATCH;
-		pos += 2 + pos[1];
-	}
-
-	return wildcard ? WILDCARD_SSID_MATCH : NO_SSID_MATCH;
-}
-
-
 void handle_probe_req(struct hostapd_data *hapd,
 		      const struct ieee80211_mgmt *mgmt, size_t len,
 		      int ssi_signal)
@@ -361,7 +321,6 @@
 	struct sta_info *sta = NULL;
 	size_t i, resp_len;
 	int noack;
-	enum ssid_match_result res;
 
 	ie = mgmt->u.probe_req.variable;
 	if (len < IEEE80211_HDRLEN + sizeof(mgmt->u.probe_req))
@@ -417,8 +376,7 @@
 	}
 #endif /* CONFIG_P2P */
 
-	if (hapd->conf->ignore_broadcast_ssid && elems.ssid_len == 0 &&
-	    elems.ssid_list_len == 0) {
+	if (hapd->conf->ignore_broadcast_ssid && elems.ssid_len == 0) {
 		wpa_printf(MSG_MSGDUMP, "Probe Request from " MACSTR " for "
 			   "broadcast SSID ignored", MAC2STR(mgmt->sa));
 		return;
@@ -436,9 +394,10 @@
 	}
 #endif /* CONFIG_P2P */
 
-	res = ssid_match(hapd, elems.ssid, elems.ssid_len,
-			 elems.ssid_list, elems.ssid_list_len);
-	if (res != NO_SSID_MATCH) {
+	if (elems.ssid_len == 0 ||
+	    (elems.ssid_len == hapd->conf->ssid.ssid_len &&
+	     os_memcmp(elems.ssid, hapd->conf->ssid.ssid, elems.ssid_len) ==
+	     0)) {
 		if (sta)
 			sta->ssid_probe = &hapd->conf->ssid;
 	} else {
@@ -447,10 +406,9 @@
 			ieee802_11_print_ssid(ssid_txt, elems.ssid,
 					      elems.ssid_len);
 			wpa_printf(MSG_MSGDUMP, "Probe Request from " MACSTR
-				   " for foreign SSID '%s' (DA " MACSTR ")%s",
+				   " for foreign SSID '%s' (DA " MACSTR ")",
 				   MAC2STR(mgmt->sa), ssid_txt,
-				   MAC2STR(mgmt->da),
-				   elems.ssid_list ? " (SSID list)" : "");
+				   MAC2STR(mgmt->da));
 		}
 		return;
 	}
@@ -497,8 +455,7 @@
 	 * If this is a broadcast probe request, apply no ack policy to avoid
 	 * excessive retries.
 	 */
-	noack = !!(res == WILDCARD_SSID_MATCH &&
-		   is_broadcast_ether_addr(mgmt->da));
+	noack = !!(elems.ssid_len == 0 && is_broadcast_ether_addr(mgmt->da));
 
 	if (hostapd_drv_send_mlme(hapd, resp, resp_len, noack) < 0)
 		perror("handle_probe_req: send");
diff -Nur hostapd-2.0/src/ap/drv_callbacks.c hostapd-2.0-TI/src/ap/drv_callbacks.c
--- hostapd-2.0/src/ap/drv_callbacks.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/drv_callbacks.c	2014-03-28 17:49:32.000000000 +0800
@@ -342,7 +342,9 @@
 	}
 
 	ap_sta_set_authorized(hapd, sta, 0);
-	sta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC);
+	sta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC |
+			WLAN_STA_ASSOC_REQ_OK);
+	ap_sta_cancel_priority(hapd, sta);
 	wpa_auth_sm_event(sta->wpa_sm, WPA_DISASSOC);
 	sta->acct_terminate_cause = RADIUS_ACCT_TERMINATE_CAUSE_USER_REQUEST;
 	ieee802_1x_notify_port_enabled(sta->eapol_sm, 0);
@@ -512,13 +514,13 @@
 					   action->data + 2);
 	}
 #endif /* CONFIG_IEEE80211W */
-#ifdef CONFIG_WNM
+#ifdef CONFIG_IEEE80211V
 	if (action->category == WLAN_ACTION_WNM) {
 		wpa_printf(MSG_DEBUG, "%s: WNM_ACTION length %d",
 			   __func__, (int) action->len);
 		ieee802_11_rx_wnm_action_ap(hapd, action);
 	}
-#endif /* CONFIG_WNM */
+#endif /* CONFIG_IEEE80211V */
 }
 
 
@@ -828,6 +830,12 @@
 					data->ch_switch.ht_enabled,
 					data->ch_switch.ch_offset);
 		break;
+	case EVENT_INTERFACE_DISABLED:
+		hapd->driver->stop_ap(hapd->drv_priv);
+		break;
+	case EVENT_INTERFACE_ENABLED:
+		hostapd_reload_iface(hapd->iface);
+		break;
 	default:
 		wpa_printf(MSG_DEBUG, "Unknown event %d", event);
 		break;
diff -Nur hostapd-2.0/src/ap/hostapd.c hostapd-2.0-TI/src/ap/hostapd.c
--- hostapd-2.0/src/ap/hostapd.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/hostapd.c	2014-04-17 17:31:18.000000000 +0800
@@ -261,6 +261,9 @@
 	os_free(hapd->probereq_cb);
 	hapd->probereq_cb = NULL;
 
+	wpabuf_free(hapd->pending_eapol_rx);
+	hapd->pending_eapol_rx = NULL;
+
 #ifdef CONFIG_P2P
 	wpabuf_free(hapd->p2p_beacon_ie);
 	hapd->p2p_beacon_ie = NULL;
@@ -825,7 +828,7 @@
 {
 	struct hostapd_data *hapd = iface->bss[0];
 	size_t i;
-	char country[4];
+	char country[4] = {0};
 
 	/*
 	 * Make sure that all BSSes get configured with a pointer to the same
@@ -840,11 +843,17 @@
 		return -1;
 
 	if (hapd->iconf->country[0] && hapd->iconf->country[1]) {
-		os_memcpy(country, hapd->iconf->country, 3);
-		country[3] = '\0';
-		if (hostapd_set_country(hapd, country) < 0) {
-			wpa_printf(MSG_ERROR, "Failed to set country code");
-			return -1;
+		if (hostapd_get_country(hapd, country) == 0 &&
+		    os_strncmp(country, "00", 2) != 0) {
+			wpa_printf(MSG_ERROR, "Current country: %s. Use it for ap operation", country);
+			os_memcpy(hapd->iconf->country, country, 3);
+		} else {
+			os_memcpy(country, hapd->iconf->country, 3);
+			country[3] = '\0';
+			if (hostapd_set_country(hapd, country) < 0) {
+				wpa_printf(MSG_ERROR, "Failed to set country code");
+				return -1;
+			}
 		}
 	}
 
@@ -858,7 +867,16 @@
 				   "channel. (%d)", ret);
 			return -1;
 		}
-		ret = hostapd_check_ht_capab(iface);
+		//ret = hostapd_check_ht_capab(iface);
+	   /* we don't need hostapd_check_ht_capab if the channel is
+  	   * selected automatically */
+    if (ret == 1) {
+      wpa_printf(MSG_DEBUG, "Interface HW mode selection and "
+           "initialization be completed in a callback");
+      return 0;
+    }
+
+    ret = hostapd_check_ht_capab(iface, NULL);
 		if (ret < 0)
 			return -1;
 		if (ret == 1) {
@@ -876,6 +894,7 @@
 	struct hostapd_data *hapd = iface->bss[0];
 	size_t j;
 	u8 *prev_addr;
+	char channelmsg[64]; 
 
 	if (err) {
 		wpa_printf(MSG_ERROR, "Interface initialization failed");
@@ -885,6 +904,9 @@
 
 	wpa_printf(MSG_DEBUG, "Completing interface initialization");
 	if (hapd->iconf->channel) {
+		memset(channelmsg, 0x0, sizeof(channelmsg));
+  		snprintf(channelmsg, sizeof(channelmsg), "echo %d > /tmp/CurrentChannel\n", iface->conf->channel);
+  		system(channelmsg);
 		iface->freq = hostapd_hw_get_freq(hapd, hapd->iconf->channel);
 		wpa_printf(MSG_DEBUG, "Mode: %s  Channel: %d  "
 			   "Frequency: %d MHz",
@@ -1401,3 +1423,60 @@
 	eloop_register_timeout(hapd->conf->ap_max_inactivity, 0,
 			       ap_handle_timer, hapd, sta);
 }
+
+void hostapd_macaddr_acl_accept_sta(struct hostapd_data *hapd)
+{
+	struct sta_info *sta = NULL;
+
+	if (hapd->conf->macaddr_acl != DENY_UNLESS_ACCEPTED)
+		return;
+
+	for (sta = hapd->sta_list; sta; sta = sta->next) {
+		if (!hostapd_maclist_found(hapd->conf->accept_mac,
+				hapd->conf->num_accept_mac, sta->addr, NULL)) {
+			hostapd_drv_sta_deauth(hapd, sta->addr,
+					       WLAN_REASON_PREV_AUTH_NOT_VALID);
+			ap_sta_deauthenticate(hapd, sta,
+					      WLAN_REASON_PREV_AUTH_NOT_VALID);
+		}
+	}
+}
+
+void hostapd_macaddr_acl_deny_sta(struct hostapd_data *hapd)
+{
+	struct sta_info *sta = NULL;
+
+	if (hapd->conf->macaddr_acl != ACCEPT_UNLESS_DENIED)
+		return;
+
+	for (sta = hapd->sta_list; sta; sta = sta->next) {
+		if (hostapd_maclist_found(hapd->conf->deny_mac,
+				hapd->conf->num_deny_mac, sta->addr, NULL)) {
+			hostapd_drv_sta_deauth(hapd, sta->addr,
+					       WLAN_REASON_PREV_AUTH_NOT_VALID);
+			ap_sta_deauthenticate(hapd, sta,
+					      WLAN_REASON_PREV_AUTH_NOT_VALID);
+		}
+	}
+}
+
+int hostapd_macaddr_acl_command(struct hostapd_data *hapd, char *cmd)
+{
+	int ret = 0;
+
+	if (os_strcasecmp(cmd, "accept") == 0) {
+		wpa_printf(MSG_DEBUG, "Changing to access control accept list");
+		hapd->conf->macaddr_acl = DENY_UNLESS_ACCEPTED;
+		hostapd_macaddr_acl_accept_sta(hapd);
+	} else if (os_strcasecmp(cmd, "deny") == 0) {
+		wpa_printf(MSG_DEBUG, "Changing to accees control deny list");
+		hapd->conf->macaddr_acl = ACCEPT_UNLESS_DENIED;
+		hostapd_macaddr_acl_deny_sta(hapd);
+	} else {
+		wpa_printf(MSG_ERROR, "Unknown acl command");
+		ret = -1;
+	}
+
+	return ret;
+}
+
diff -Nur hostapd-2.0/src/ap/hostapd.h hostapd-2.0-TI/src/ap/hostapd.h
--- hostapd-2.0/src/ap/hostapd.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/hostapd.h	2014-03-28 17:49:32.000000000 +0800
@@ -76,6 +76,7 @@
 	u8 own_addr[ETH_ALEN];
 
 	int num_sta; /* number of entries in sta_list */
+	int num_priorities; /* num of stations with set_priorities */
 	struct sta_info *sta_list; /* STA info list head */
 #define STA_HASH_SIZE 256
 #define STA_HASH(sta) (sta[5])
@@ -138,6 +139,11 @@
 	int beacon_set_done;
 	struct wpabuf *wps_beacon_ie;
 	struct wpabuf *wps_probe_resp_ie;
+
+	struct wpabuf *pending_eapol_rx;
+	struct os_time pending_eapol_rx_time;
+	u8 pending_eapol_rx_src[ETH_ALEN];
+
 #ifdef CONFIG_WPS
 	unsigned int ap_pin_failures;
 	unsigned int ap_pin_failures_consecutive;
@@ -281,6 +287,9 @@
 int hostapd_disable_iface(struct hostapd_iface *hapd_iface);
 int hostapd_add_iface(struct hapd_interfaces *ifaces, char *buf);
 int hostapd_remove_iface(struct hapd_interfaces *ifaces, char *buf);
+void hostapd_macaddr_acl_accept_sta(struct hostapd_data *hapd);
+void hostapd_macaddr_acl_deny_sta(struct hostapd_data *hapd);
+int hostapd_macaddr_acl_command(struct hostapd_data *hapd, char *cmd);
 
 /* utils.c */
 int hostapd_register_probereq_cb(struct hostapd_data *hapd,
diff -Nur hostapd-2.0/src/ap/hw_features.c hostapd-2.0-TI/src/ap/hw_features.c
--- hostapd-2.0/src/ap/hw_features.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/hw_features.c	2014-03-28 17:49:32.000000000 +0800
@@ -122,8 +122,6 @@
 	case HOSTAPD_MODE_IEEE80211G:
 		basic_rates = basic_rates_g;
 		break;
-	case HOSTAPD_MODE_IEEE80211AD:
-		return 0; /* No basic rates for 11ad */
 	default:
 		return -1;
 	}
@@ -413,28 +411,30 @@
 }
 
 
-static void ieee80211n_check_scan(struct hostapd_iface *iface)
+//static void ieee80211n_check_scan(struct hostapd_iface *iface)
+static int ieee80211n_check_scan(struct hostapd_iface *iface,
+          struct wpa_scan_results *scan_res)
 {
-	struct wpa_scan_results *scan_res;
+	//struct wpa_scan_results *scan_res;
 	int oper40;
 	int res;
 
 	/* Check list of neighboring BSSes (from scan) to see whether 40 MHz is
 	 * allowed per IEEE Std 802.11-2012, 10.15.3.2 */
 
-	iface->scan_cb = NULL;
+	//iface->scan_cb = NULL;
 
-	scan_res = hostapd_driver_get_scan_results(iface->bss[0]);
-	if (scan_res == NULL) {
-		hostapd_setup_interface_complete(iface, 1);
-		return;
-	}
+	//scan_res = hostapd_driver_get_scan_results(iface->bss[0]);
+	//if (scan_res == NULL) {
+	//	hostapd_setup_interface_complete(iface, 1);
+	//	return;
+	//}
 
 	if (iface->current_mode->mode == HOSTAPD_MODE_IEEE80211A)
 		oper40 = ieee80211n_check_40mhz_5g(iface, scan_res);
 	else
 		oper40 = ieee80211n_check_40mhz_2g4(iface, scan_res);
-	wpa_scan_results_free(scan_res);
+	//wpa_scan_results_free(scan_res);
 
 	if (!oper40) {
 		wpa_printf(MSG_INFO, "20/40 MHz operation not permitted on "
@@ -448,8 +448,27 @@
 
 	res = ieee80211n_allowed_ht40_channel_pair(iface);
 	hostapd_setup_interface_complete(iface, !res);
+	return 1;
 }
 
+static void ieee80211n_get_res_and_check_scan(struct hostapd_iface *iface)
+{
+  struct wpa_scan_results *scan_res;
+
+  /* Check list of neighboring BSSes (from scan) to see whether 40 MHz is
+   * allowed per IEEE Std 802.11-2012, 10.15.3.2 */
+
+  iface->scan_cb = NULL;
+
+  scan_res = hostapd_driver_get_scan_results(iface->bss[0]);
+  if (scan_res == NULL) {
+    hostapd_setup_interface_complete(iface, 1);
+    return;
+  }
+
+  ieee80211n_check_scan(iface, scan_res);
+  wpa_scan_results_free(scan_res);
+}
 
 static void ieee80211n_scan_channels_2g4(struct hostapd_iface *iface,
 					 struct wpa_driver_scan_params *params)
@@ -511,7 +530,8 @@
 	}
 	os_free(params.freqs);
 
-	iface->scan_cb = ieee80211n_check_scan;
+	//iface->scan_cb = ieee80211n_check_scan;
+	iface->scan_cb = ieee80211n_get_res_and_check_scan;
 	return 1;
 }
 
@@ -616,20 +636,341 @@
 #endif /* CONFIG_IEEE80211N */
 
 
-int hostapd_check_ht_capab(struct hostapd_iface *iface)
+//int hostapd_check_ht_capab(struct hostapd_iface *iface)
+int hostapd_check_ht_capab(struct hostapd_iface *iface,
+         struct wpa_scan_results *scan_res)
 {
 #ifdef CONFIG_IEEE80211N
 	int ret;
 	if (!iface->conf->ieee80211n)
-		return 0;
+		//return 0;
+		goto out;
 	if (!ieee80211n_supported_ht_capab(iface))
 		return -1;
-	ret = ieee80211n_check_40mhz(iface);
+	//ret = ieee80211n_check_40mhz(iface);
+	if (scan_res)
+     ret = ieee80211n_check_scan(iface, scan_res);
+   else
+     ret = ieee80211n_check_40mhz(iface);
+ 
+   /* sometimes the init should proceed async or fail */
 	if (ret)
 		return ret;
 	if (!ieee80211n_allowed_ht40_channel_pair(iface))
 		return -1;
+out:		
 #endif /* CONFIG_IEEE80211N */
+  /* we are in an async callback if we have scan results */
+   if (scan_res)
+   		hostapd_setup_interface_complete(iface, 0);
+	return 0;
+}
+
+static int valid_ap_channel(struct hostapd_iface *iface, int chan)
+{
+	int j;
+	struct hostapd_channel_data *c;
+	int *list;
+
+	/* don't allow AP on channel 14 - only JP 11b rates */
+	if (chan == 14)
+		return 0;
+
+	/* don't allow channels on the the ACS blacklist */
+	if (iface->conf->acs_blacklist) {
+		list = iface->conf->acs_blacklist;
+		for (j = 0; list[j] >= 0; j++)
+			if (chan == list[j])
+				return 0;
+	}
+
+	/* only allow channels from the ACS whitelist */
+	if (iface->conf->acs_whitelist) {
+		list = iface->conf->acs_whitelist;
+		for (j = 0; list[j] >= 0; j++)
+			if (chan == list[j])
+				break;
+
+		/* channel not found */
+		if (list[j] != chan)
+			return 0;
+	}
+  for (j = 0; j < iface->current_mode->num_channels; j++) {
+   	c = &iface->current_mode->channels[j];
+     if (c->chan == chan)
+       return (c->flag & HOSTAPD_CHAN_DISABLED) ? 0 : 1;
+   }
+ 
+   /* channel not found */
+   return 0;
+}
+
+struct oper_class_map {
+  enum hostapd_hw_mode mode;
+  u8 op_class;
+  u8 min_chan;
+  u8 max_chan;
+  u8 inc;
+  enum { BW40PLUS, BW40MINUS } bw;
+};
+
+/* this is a duplication of the table in p2p_supplicant.c.
+ * all changes here must be propagated there and vice versa */
+static struct oper_class_map op_class[] = {
+#if 0 /* diallow HT40 on 2.4Ghz on purpose */
+  { HOSTAPD_MODE_IEEE80211G, 83, 1, 9, 1, BW40PLUS },
+  { HOSTAPD_MODE_IEEE80211G, 84, 5, 13, 1, BW40MINUS },
+#endif
+  { HOSTAPD_MODE_IEEE80211A, 116, 36, 44, 8, BW40PLUS },
+  { HOSTAPD_MODE_IEEE80211A, 117, 40, 48, 8, BW40MINUS },
+  { HOSTAPD_MODE_IEEE80211A, 126, 149, 157, 8, BW40PLUS },
+  { HOSTAPD_MODE_IEEE80211A, 127, 153, 161, 8, BW40MINUS },
+  { -1, 0, 0, 0, 0, BW40PLUS } /* terminator */
+};
+
+static int channel_distance(struct hostapd_iface *iface)
+{
+  switch (iface->current_mode->mode) {
+  case HOSTAPD_MODE_IEEE80211A:
+    return 4;
+  case HOSTAPD_MODE_IEEE80211B:
+  case HOSTAPD_MODE_IEEE80211G:
+    return 1;
+  default:
+    break;
+  }
+
+  wpa_printf(MSG_ERROR, "Invalid HW mode for channel distance");
+  return 0;
+}
+
+
+
+/* Returns secondary channel (-1, 1), if possible considering the
+ * user preferred secondary channel. If no HT40 operation is possible,
+ * returns 0 */
+static int select_secondary_channel(struct hostapd_iface *iface,
+            int primary_chan, int pref_sec_chan)
+{
+  int i;
+  int up_ok = 0, down_ok = 0;
+
+  for (i = 0; op_class[i].op_class; i++) {
+    struct oper_class_map *o = &op_class[i];
+    u8 ch;
+
+    if (o->mode != iface->current_mode->mode)
+      continue;
+
+    if (primary_chan < o->min_chan || primary_chan > o->max_chan)
+      continue;
+
+    for (ch = o->min_chan; ch <= o->max_chan; ch += o->inc) {
+      if (ch == primary_chan) {
+        if (o->bw == BW40PLUS)
+          up_ok = 1;
+        else if (o->bw == BW40MINUS)
+          down_ok = 1;
+
+        break;
+      }
+    }
+  }
+
+  if (up_ok && !valid_ap_channel(iface,
+        primary_chan + channel_distance(iface)))
+    up_ok = 0;
+  if (down_ok && !valid_ap_channel(iface,
+        primary_chan - channel_distance(iface)))
+    down_ok = 0;
+
+  if ((pref_sec_chan == 1 && up_ok) || (pref_sec_chan == -1 && down_ok))
+    return pref_sec_chan;
+
+  if (up_ok)
+    return 1;
+  else if (down_ok)
+    return -1;
+
+  /* no secondary channel possible */
+  return 0;
+}
+
+  
+/* unreasonable number of APs to find on a channel. */
+#define MAX_AP_COUNT 10000
+ 
+void set_prim_sec_chan(struct hostapd_iface *iface, int *channel_cnt,
+           int min_cnt, int default_prim_chan)
+{
+  int j, i;
+  int min_sec_cnt = MAX_AP_COUNT, min_sec_prim_chan = -1,
+    min_sec_chan_dir = -1;
+  int prim_chan, sec_chan_dir, sec_chan;
+
+  if (!iface->conf->secondary_channel)
+    goto set;
+
+  /* if a secondary channel is requested, try to select a channel that
+   * allows HT40 from the minimal AP ones */
+  for (j = 0; j < iface->current_mode->num_channels; j++) {
+    prim_chan = iface->current_mode->channels[j].chan;
+    if (channel_cnt[j] != min_cnt)
+      continue;
+
+    sec_chan_dir = select_secondary_channel(iface, prim_chan,
+          iface->conf->secondary_channel);
+    if (!sec_chan_dir)
+      continue;
+
+    /* see if this secondary channel has minimal APs count */
+    sec_chan = prim_chan + sec_chan_dir * channel_distance(iface);
+    for (i = 0; i < iface->current_mode->num_channels; i++) {
+      if (iface->current_mode->channels[i].chan == sec_chan)
+        break;
+    }
+
+    if (i < iface->current_mode->num_channels &&
+        channel_cnt[i] < min_sec_cnt) {
+      min_sec_cnt = channel_cnt[i];
+      min_sec_prim_chan = prim_chan;
+      min_sec_chan_dir = sec_chan_dir;
+    }
+  }
+
+  /* found some sec chan with minimal APs */
+  if (min_sec_cnt != MAX_AP_COUNT) {
+    iface->conf->channel = min_sec_prim_chan;
+    iface->conf->secondary_channel = min_sec_chan_dir;
+    return;
+  }
+
+  wpa_printf(MSG_DEBUG, "Could not auto-select secondary channel");
+
+set:
+  iface->conf->channel = default_prim_chan;
+  iface->conf->secondary_channel = 0;
+  iface->conf->ht_capab &= ~HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET;
+}
+ 
+ 
+static void hostapd_auto_select_scan_cb(struct hostapd_iface *iface)
+{
+  struct wpa_scan_results *scan_res;
+  size_t i, j;
+  int *channel_cnt;
+  int min_cnt, min_idx;
+  struct hostapd_channel_data *chan;
+  char channelmsg[64];
+
+  iface->scan_cb = NULL;
+
+  /* init all channel counters to 0 */
+  channel_cnt = os_zalloc(iface->current_mode->num_channels * sizeof(int));
+  if (channel_cnt == NULL) {
+    hostapd_setup_interface_complete(iface, 1);
+    return;
+  }
+
+  scan_res = hostapd_driver_get_scan_results(iface->bss[0]);
+  if (scan_res == NULL) {
+    hostapd_setup_interface_complete(iface, 1);
+    goto free_chans;
+  }
+
+  /* increment channel counters according to scan results */
+  for (i = 0; i < scan_res->num; i++) {
+    struct wpa_scan_res *bss = scan_res->res[i];
+    for (j = 0; j < iface->current_mode->num_channels; j++) {
+      chan = &iface->current_mode->channels[j];
+      if (bss->freq == chan->freq) {
+        channel_cnt[j]++;
+        wpa_printf(MSG_DEBUG, "Have %d BSSes on ch %d",
+             channel_cnt[j], chan->chan);
+        break;
+      }
+    }
+  }
+
+  min_idx = -1;
+  min_cnt = MAX_AP_COUNT;
+  for (j = 0; j < iface->current_mode->num_channels; j++) {
+    chan = &iface->current_mode->channels[j];
+    if (!valid_ap_channel(iface, chan->chan)) {
+      channel_cnt[j] = MAX_AP_COUNT;
+      continue;
+    }
+
+    if (channel_cnt[j] >= min_cnt)
+      continue;
+
+    min_cnt = channel_cnt[j];
+    min_idx = j;
+  }
+
+  if (min_idx == -1) {
+    wpa_printf(MSG_ERROR,
+         "Could not select channel automatically");
+    hostapd_setup_interface_complete(iface, 1);
+    goto free_scan;
+  }
+
+  chan = &iface->current_mode->channels[min_idx];
+  wpa_printf(MSG_DEBUG, "Min APs found in channel %d (AP count %d)",
+       chan->chan, min_cnt);
+
+  //iface->conf->channel = chan->chan;
+
+  /* Select a secondary channel and fine tune the primary one.
+   * Basically we try to start HT40, without increasing the number
+   * of APs on the primary channel. */
+  set_prim_sec_chan(iface, channel_cnt, min_cnt, chan->chan);
+
+  wpa_printf(MSG_DEBUG, "Auto-selected channel: %d secondary: %d",
+       iface->conf->channel, iface->conf->secondary_channel);
+  
+  memset(channelmsg, 0x0, sizeof(channelmsg));
+  snprintf(channelmsg, sizeof(channelmsg), "echo %d > /tmp/CurrentChannel\n", iface->conf->channel);
+  system(channelmsg);
+  
+  /* will complete interface setup */
+  hostapd_check_ht_capab(iface, scan_res);
+
+free_scan:
+  wpa_scan_results_free(scan_res);
+
+free_chans:
+  os_free(channel_cnt);
+	
+}
+
+
+static int hostapd_auto_select_channel(struct hostapd_iface *iface)
+{
+  struct wpa_driver_scan_params params;
+
+  /* TODO: we can scan only the current HW mode */
+  wpa_printf(MSG_DEBUG, "Scan for neighboring BSSes to select channel");
+  os_memset(&params, 0, sizeof(params));
+  if (hostapd_driver_scan(iface->bss[0], &params) < 0) {
+    wpa_printf(MSG_ERROR, "Failed to request a scan of "
+         "neighboring BSSes");
+    return -1;
+  }
+
+  iface->scan_cb = hostapd_auto_select_scan_cb;
+  return 0;
+}
+
+
+static u8 freq_to_channel(int freq)
+{
+	if (freq >= 2412 && freq <= 2472)
+		return (freq - 2407) / 5;
+	else if (freq == 2484)
+		return 14;
+	else if (freq >= 5180 && freq <= 5805)
+		return (freq - 5000) / 5;
 
 	return 0;
 }
@@ -646,6 +987,7 @@
 int hostapd_select_hw_mode(struct hostapd_iface *iface)
 {
 	int i, j, ok;
+	struct wpa_channel_info info;
 
 	if (iface->num_hw_features < 1)
 		return -1;
@@ -670,6 +1012,40 @@
 		return -2;
 	}
 
+	/* if we failed in querying the channel, assume no concurrent operation */
+	if (iface->conf->ap_channel_sync &&
+	    hostapd_drv_shared_ap_freq(iface->bss[0], &info) == 1) {
+		u8 chan = freq_to_channel(info.frequency);
+		if (chan == 0) {
+			wpa_printf(MSG_ERROR, "Shared AP freq bad channel");
+			return -3;
+		}
+
+		iface->conf->channel = chan;
+		iface->conf->secondary_channel = info.sec_channel_offset;
+		wpa_printf(MSG_DEBUG, "Channel automatically synced to "
+			   "existing AP: %d (secondary: %d)",
+			   chan, info.sec_channel_offset);
+	}
+
+	/*
+	 * request a scan of neighboring BSSes and select the
+	 * channel automatically
+	 */
+	if (iface->conf->channel == 0) {
+		if (hostapd_auto_select_channel(iface)) {
+			wpa_printf(MSG_ERROR, "Channel not configured "
+				   "(hw_mode/channel in hostapd.conf) and "
+				   "automatic channel selection failed");
+			return -3;
+		} else {
+			wpa_printf(MSG_DEBUG, "Operating channel will be "
+				   "selected automatically");
+			/* will be completed async */
+			return 1;
+		}
+	}
+
 	ok = 0;
 	for (j = 0; j < iface->current_mode->num_channels; j++) {
 		struct hostapd_channel_data *chan =
@@ -719,14 +1095,8 @@
 			ok = 0;
 		}
 	}
-	if (iface->conf->channel == 0) {
-		/* TODO: could request a scan of neighboring BSSes and select
-		 * the channel automatically */
-		wpa_printf(MSG_ERROR, "Channel not configured "
-			   "(hw_mode/channel in hostapd.conf)");
-		return -3;
-	}
-	if (ok == 0 && iface->conf->channel != 0) {
+
+	if (ok == 0) {
 		hostapd_logger(iface->bss[0], NULL,
 			       HOSTAPD_MODULE_IEEE80211,
 			       HOSTAPD_LEVEL_WARNING,
@@ -758,8 +1128,6 @@
 		return "IEEE 802.11b";
 	case HOSTAPD_MODE_IEEE80211G:
 		return "IEEE 802.11g";
-	case HOSTAPD_MODE_IEEE80211AD:
-		return "IEEE 802.11ad";
 	default:
 		return "UNKNOWN";
 	}
diff -Nur hostapd-2.0/src/ap/hw_features.h hostapd-2.0-TI/src/ap/hw_features.h
--- hostapd-2.0/src/ap/hw_features.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/hw_features.h	2014-03-28 17:49:32.000000000 +0800
@@ -25,7 +25,8 @@
 const char * hostapd_hw_mode_txt(int mode);
 int hostapd_hw_get_freq(struct hostapd_data *hapd, int chan);
 int hostapd_hw_get_channel(struct hostapd_data *hapd, int freq);
-int hostapd_check_ht_capab(struct hostapd_iface *iface);
+int hostapd_check_ht_capab(struct hostapd_iface *iface,
+         struct wpa_scan_results *scan_res);
 int hostapd_prepare_rates(struct hostapd_iface *iface,
 			  struct hostapd_hw_modes *mode);
 #else /* NEED_AP_MLME */
diff -Nur hostapd-2.0/src/ap/ieee802_11.c hostapd-2.0-TI/src/ap/ieee802_11.c
--- hostapd-2.0/src/ap/ieee802_11.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/ieee802_11.c	2014-03-28 17:49:32.000000000 +0800
@@ -34,7 +34,6 @@
 #include "ap_mlme.h"
 #include "p2p_hostapd.h"
 #include "ap_drv_ops.h"
-#include "wnm_ap.h"
 #include "ieee802_11.h"
 
 
@@ -649,6 +648,8 @@
 #endif /* CONFIG_SAE */
 	}
 
+	ap_sta_set_priority(hapd, sta);
+
  fail:
 	os_free(identity);
 	os_free(radius_cui);
@@ -1014,6 +1015,36 @@
 }
 
 
+static void add_pre_assoc_sta(struct hostapd_data *hapd, struct sta_info *sta)
+{
+	struct ieee80211_ht_capabilities ht_cap;
+	/*
+	 * Remove the STA entry in order to make sure the STA PS state gets
+	 * cleared and configuration gets updated in case of reassociation back
+	 * to the same AP.
+	 */
+	hostapd_drv_sta_remove(hapd, sta->addr);
+
+#ifdef CONFIG_IEEE80211N
+	if (sta->flags & WLAN_STA_HT)
+		hostapd_get_ht_capab(hapd, sta->ht_capabilities, &ht_cap);
+#endif /* CONFIG_IEEE80211N */
+
+	if (hostapd_sta_add(hapd, sta->addr, sta->aid, sta->capability,
+			    sta->supported_rates, sta->supported_rates_len,
+			    sta->listen_interval,
+			    sta->flags & WLAN_STA_HT ? &ht_cap : NULL,
+			    sta->flags, sta->qosinfo)) {
+		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
+			       HOSTAPD_LEVEL_NOTICE,
+			       "Could not add STA to kernel driver");
+
+		ap_sta_disconnect(hapd, sta, sta->addr,
+				  WLAN_REASON_DISASSOC_AP_BUSY);
+	}
+}
+
+
 static void send_assoc_resp(struct hostapd_data *hapd, struct sta_info *sta,
 			    u16 status_code, int reassoc, const u8 *ies,
 			    size_t ies_len)
@@ -1113,6 +1144,11 @@
 	}
 #endif /* CONFIG_P2P */
 
+	if (status_code == WLAN_STATUS_SUCCESS) {
+		wpa_printf(MSG_DEBUG, "Adding associated sta");
+		add_pre_assoc_sta(hapd, sta);
+	}
+
 #ifdef CONFIG_P2P_MANAGER
 	if (hapd->conf->p2p & P2P_MANAGE)
 		p = hostapd_eid_p2p_manage(hapd, p);
@@ -1186,6 +1222,14 @@
 		return;
 	}
 
+	if ((sta->flags & WLAN_STA_ASSOC_REQ_OK) &&
+	    !(sta->flags & WLAN_STA_ASSOC)) {
+		hostapd_logger(hapd, mgmt->sa, HOSTAPD_MODULE_IEEE80211,
+			       HOSTAPD_LEVEL_INFO, "Station sent another "
+			       "assoc req before assoc resp. Discarding");
+		return;
+	}
+
 	if (hapd->tkip_countermeasures) {
 		resp = WLAN_REASON_MICHAEL_MIC_FAILURE;
 		goto fail;
@@ -1373,6 +1417,7 @@
 	ap_sta_set_authorized(hapd, sta, 0);
 	sta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC |
 			WLAN_STA_ASSOC_REQ_OK);
+	ap_sta_cancel_priority(hapd, sta);
 	wpa_auth_sm_event(sta->wpa_sm, WPA_DEAUTH);
 	hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
 		       HOSTAPD_LEVEL_DEBUG, "deauthenticated");
@@ -1435,32 +1480,13 @@
 #endif /* CONFIG_IEEE80211W */
 
 
-#ifdef CONFIG_WNM
-static void hostapd_wnm_action(struct hostapd_data *hapd, struct sta_info *sta,
-			       const struct ieee80211_mgmt *mgmt,
-			       size_t len)
-{
-	struct rx_action action;
-	if (len < IEEE80211_HDRLEN + 2)
-		return;
-	os_memset(&action, 0, sizeof(action));
-	action.da = mgmt->da;
-	action.sa = mgmt->sa;
-	action.bssid = mgmt->bssid;
-	action.category = mgmt->u.action.category;
-	action.data = (const u8 *) &mgmt->u.action.u.wnm_sleep_req.action;
-	action.len = len - IEEE80211_HDRLEN - 1;
-	action.freq = hapd->iface->freq;
-	ieee802_11_rx_wnm_action_ap(hapd, &action);
-}
-#endif /* CONFIG_WNM */
-
-
 static void handle_action(struct hostapd_data *hapd,
 			  const struct ieee80211_mgmt *mgmt, size_t len)
 {
+#if defined(CONFIG_IEEE80211W) || defined(CONFIG_IEEE80211R)
 	struct sta_info *sta;
 	sta = ap_get_sta(hapd, mgmt->sa);
+#endif /* CONFIG_IEEE80211W || CONFIG_IEEE80211R */
 
 	if (len < IEEE80211_HDRLEN + 1) {
 		hostapd_logger(hapd, mgmt->sa, HOSTAPD_MODULE_IEEE80211,
@@ -1470,14 +1496,6 @@
 		return;
 	}
 
-	if (mgmt->u.action.category != WLAN_ACTION_PUBLIC &&
-	    (sta == NULL || !(sta->flags & WLAN_STA_ASSOC))) {
-		wpa_printf(MSG_DEBUG, "IEEE 802.11: Ignored Action "
-			   "frame (category=%u) from unassociated STA " MACSTR,
-			   MAC2STR(mgmt->sa), mgmt->u.action.category);
-		return;
-	}
-
 #ifdef CONFIG_IEEE80211W
 	if (sta && (sta->flags & WLAN_STA_MFP) &&
 	    !(mgmt->frame_control & host_to_le16(WLAN_FC_ISWEP) &&
@@ -1493,10 +1511,20 @@
 	switch (mgmt->u.action.category) {
 #ifdef CONFIG_IEEE80211R
 	case WLAN_ACTION_FT:
+	{
+		if (sta == NULL || !(sta->flags & WLAN_STA_ASSOC)) {
+			wpa_printf(MSG_DEBUG, "IEEE 802.11: Ignored FT Action "
+				   "frame from unassociated STA " MACSTR,
+				   MAC2STR(mgmt->sa));
+			return;
+		}
+
 		if (wpa_ft_action_rx(sta->wpa_sm, (u8 *) &mgmt->u.action,
 				     len - IEEE80211_HDRLEN))
 			break;
+
 		return;
+	}
 #endif /* CONFIG_IEEE80211R */
 	case WLAN_ACTION_WMM:
 		hostapd_wmm_action(hapd, mgmt, len);
@@ -1506,11 +1534,6 @@
 		hostapd_sa_query_action(hapd, mgmt, len);
 		return;
 #endif /* CONFIG_IEEE80211W */
-#ifdef CONFIG_WNM
-	case WLAN_ACTION_WNM:
-		hostapd_wnm_action(hapd, sta, mgmt, len);
-		return;
-#endif /* CONFIG_WNM */
 	case WLAN_ACTION_PUBLIC:
 		if (hapd->public_action_cb) {
 			hapd->public_action_cb(hapd->public_action_cb_ctx,
@@ -1708,6 +1731,7 @@
 	struct sta_info *sta;
 	int new_assoc = 1;
 	struct ieee80211_ht_capabilities ht_cap;
+	char msg[128];
 
 	if (len < IEEE80211_HDRLEN + (reassoc ? sizeof(mgmt->u.reassoc_resp) :
 				      sizeof(mgmt->u.assoc_resp))) {
@@ -1723,19 +1747,21 @@
 		return;
 	}
 
+	if (reassoc)
+		status = le_to_host16(mgmt->u.reassoc_resp.status_code);
+	else
+		status = le_to_host16(mgmt->u.assoc_resp.status_code);
+
 	if (!ok) {
 		hostapd_logger(hapd, mgmt->da, HOSTAPD_MODULE_IEEE80211,
 			       HOSTAPD_LEVEL_DEBUG,
 			       "did not acknowledge association response");
+		if (status == WLAN_STATUS_SUCCESS)
+			hostapd_drv_sta_remove(hapd, sta->addr);
 		sta->flags &= ~WLAN_STA_ASSOC_REQ_OK;
 		return;
 	}
 
-	if (reassoc)
-		status = le_to_host16(mgmt->u.reassoc_resp.status_code);
-	else
-		status = le_to_host16(mgmt->u.assoc_resp.status_code);
-
 	if (status != WLAN_STATUS_SUCCESS)
 		goto fail;
 
@@ -1751,6 +1777,13 @@
 	if (sta->flags & WLAN_STA_ASSOC)
 		new_assoc = 0;
 	sta->flags |= WLAN_STA_ASSOC;
+	
+	memset(msg, 0x0, sizeof(msg));
+	snprintf(msg, sizeof(msg), "/usr/local/sbin/incUpdateCount.pm wifi_client_connection &\n");
+	if (system(msg) < 0){
+		memset(msg, 0x0, sizeof(msg));
+	}	
+	
 	if ((!hapd->conf->ieee802_1x && !hapd->conf->wpa) ||
 	    sta->auth_alg == WLAN_AUTH_FT) {
 		/*
@@ -1769,33 +1802,6 @@
 	sta->sa_query_timed_out = 0;
 #endif /* CONFIG_IEEE80211W */
 
-	/*
-	 * Remove the STA entry in order to make sure the STA PS state gets
-	 * cleared and configuration gets updated in case of reassociation back
-	 * to the same AP.
-	 */
-	hostapd_drv_sta_remove(hapd, sta->addr);
-
-#ifdef CONFIG_IEEE80211N
-	if (sta->flags & WLAN_STA_HT)
-		hostapd_get_ht_capab(hapd, sta->ht_capabilities, &ht_cap);
-#endif /* CONFIG_IEEE80211N */
-
-	if (hostapd_sta_add(hapd, sta->addr, sta->aid, sta->capability,
-			    sta->supported_rates, sta->supported_rates_len,
-			    sta->listen_interval,
-			    sta->flags & WLAN_STA_HT ? &ht_cap : NULL,
-			    sta->flags, sta->qosinfo)) {
-		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
-			       HOSTAPD_LEVEL_NOTICE,
-			       "Could not add STA to kernel driver");
-
-		ap_sta_disconnect(hapd, sta, sta->addr,
-				  WLAN_REASON_DISASSOC_AP_BUSY);
-
-		goto fail;
-	}
-
 	if (sta->flags & WLAN_STA_WDS)
 		hostapd_set_wds_sta(hapd, sta->addr, sta->aid, 1);
 
@@ -1823,6 +1829,25 @@
 
 	ieee802_1x_notify_port_enabled(sta->eapol_sm, 1);
 
+	if (hapd->pending_eapol_rx) {
+		struct os_time now, age;
+		os_get_time(&now);
+		os_time_sub(&now, &hapd->pending_eapol_rx_time, &age);
+		if (age.sec == 0 && /*age.usec < 100000 &&*/
+		    os_memcmp(hapd->pending_eapol_rx_src,
+			      mgmt->da, ETH_ALEN) == 0) {
+			wpa_printf(MSG_DEBUG, "Process pending EAPOL "
+				"frame that was received just before "
+				"association notification");
+			ieee802_1x_receive(
+				hapd, hapd->pending_eapol_rx_src,
+				wpabuf_head(hapd->pending_eapol_rx),
+				wpabuf_len(hapd->pending_eapol_rx));
+		 }
+		 wpabuf_free(hapd->pending_eapol_rx);
+		 hapd->pending_eapol_rx = NULL;
+	 }
+
  fail:
 	/* Copy of the association request is not needed anymore */
 	if (sta->last_assoc_req) {
diff -Nur hostapd-2.0/src/ap/ieee802_11_shared.c hostapd-2.0-TI/src/ap/ieee802_11_shared.c
--- hostapd-2.0/src/ap/ieee802_11_shared.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/ieee802_11_shared.c	2014-03-28 17:49:32.000000000 +0800
@@ -173,14 +173,6 @@
 		len = 5;
 	if (len < 4 && hapd->conf->interworking)
 		len = 4;
-	if (len < 3 && hapd->conf->wnm_sleep_mode)
-		len = 3;
-	if (len < 7 && hapd->conf->ssid.utf8_ssid)
-		len = 7;
-#ifdef CONFIG_WNM
-	if (len < 4)
-		len = 4;
-#endif /* CONFIG_WNM */
 	if (len == 0)
 		return eid;
 
@@ -188,20 +180,9 @@
 	*pos++ = len;
 	*pos++ = 0x00;
 	*pos++ = 0x00;
+	*pos++ = 0x00;
 
 	*pos = 0x00;
-	if (hapd->conf->wnm_sleep_mode)
-		*pos |= 0x02; /* Bit 17 - WNM-Sleep Mode */
-	if (hapd->conf->bss_transition)
-		*pos |= 0x08; /* Bit 19 - BSS Transition */
-	pos++;
-
-	if (len < 4)
-		return pos;
-	*pos = 0x00;
-#ifdef CONFIG_WNM
-	*pos |= 0x02; /* Bit 25 - SSID List */
-#endif /* CONFIG_WNM */
 	if (hapd->conf->time_advertisement == 2)
 		*pos |= 0x08; /* Bit 27 - UTC TSF Offset */
 	if (hapd->conf->interworking)
@@ -217,18 +198,6 @@
 		*pos |= 0x80; /* Bit 39 - TDLS Channel Switching Prohibited */
 	pos++;
 
-	if (len < 6)
-		return pos;
-	*pos = 0x00;
-	pos++;
-
-	if (len < 7)
-		return pos;
-	*pos = 0x00;
-	if (hapd->conf->ssid.utf8_ssid)
-		*pos |= 0x01; /* Bit 48 - UTF-8 SSID */
-	pos++;
-
 	return pos;
 }
 
diff -Nur hostapd-2.0/src/ap/ieee802_1x.c hostapd-2.0-TI/src/ap/ieee802_1x.c
--- hostapd-2.0/src/ap/ieee802_1x.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/ieee802_1x.c	2014-03-28 17:49:32.000000000 +0800
@@ -66,9 +66,8 @@
 	if (sta->flags & WLAN_STA_PREAUTH) {
 		rsn_preauth_send(hapd, sta, buf, len);
 	} else {
-		hostapd_drv_hapd_send_eapol(
-			hapd, sta->addr, buf, len,
-			encrypt, hostapd_sta_flags_to_drv(sta->flags));
+		hostapd_drv_hapd_send_eapol(hapd, sta->addr, buf, len,
+					    encrypt, sta->flags);
 	}
 
 	os_free(buf);
@@ -355,8 +354,6 @@
 const char *radius_mode_txt(struct hostapd_data *hapd)
 {
 	switch (hapd->iface->conf->hw_mode) {
-	case HOSTAPD_MODE_IEEE80211AD:
-		return "802.11ad";
 	case HOSTAPD_MODE_IEEE80211A:
 		return "802.11a";
 	case HOSTAPD_MODE_IEEE80211G:
@@ -455,16 +452,6 @@
 		return -1;
 	}
 
-	if (sta->acct_session_id_hi || sta->acct_session_id_lo) {
-		os_snprintf(buf, sizeof(buf), "%08X-%08X",
-			    sta->acct_session_id_hi, sta->acct_session_id_lo);
-		if (!radius_msg_add_attr(msg, RADIUS_ATTR_ACCT_SESSION_ID,
-					 (u8 *) buf, os_strlen(buf))) {
-			wpa_printf(MSG_ERROR, "Could not add Acct-Session-Id");
-			return -1;
-		}
-	}
-
 	return 0;
 }
 
@@ -772,6 +759,17 @@
 		     !(hapd->iface->drv_flags & WPA_DRIVER_FLAGS_WIRED))) {
 		wpa_printf(MSG_DEBUG, "IEEE 802.1X data frame from not "
 			   "associated/Pre-authenticating STA");
+		if (sta && (sta->flags & WLAN_STA_ASSOC_REQ_OK)) {
+			wpa_printf(MSG_DEBUG, "Saving EAPOL for later use");
+			wpabuf_free(hapd->pending_eapol_rx);
+			hapd->pending_eapol_rx = wpabuf_alloc_copy(buf, len);
+			if (hapd->pending_eapol_rx) {
+				os_get_time(&hapd->pending_eapol_rx_time);
+				os_memcpy(hapd->pending_eapol_rx_src, sa,
+					  ETH_ALEN);
+			}
+		}
+
 		return;
 	}
 
diff -Nur hostapd-2.0/src/ap/pmksa_cache_auth.c hostapd-2.0-TI/src/ap/pmksa_cache_auth.c
--- hostapd-2.0/src/ap/pmksa_cache_auth.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/pmksa_cache_auth.c	2014-03-28 17:49:32.000000000 +0800
@@ -209,8 +209,6 @@
 	pmksa->pmkid[PMKID_HASH(entry->pmkid)] = entry;
 
 	pmksa->pmksa_count++;
-	if (prev == NULL)
-		pmksa_cache_set_expiration(pmksa);
 	wpa_printf(MSG_DEBUG, "RSN: added PMKSA cache entry for " MACSTR,
 		   MAC2STR(entry->spa));
 	wpa_hexdump(MSG_DEBUG, "RSN: added PMKID", entry->pmkid, PMKID_LEN);
diff -Nur hostapd-2.0/src/ap/sta_info.c hostapd-2.0-TI/src/ap/sta_info.c
--- hostapd-2.0/src/ap/sta_info.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/sta_info.c	2014-03-28 17:49:32.000000000 +0800
@@ -389,7 +389,7 @@
 		break;
 	case STA_DISASSOC:
 		ap_sta_set_authorized(hapd, sta, 0);
-		sta->flags &= ~WLAN_STA_ASSOC;
+		sta->flags &= ~(WLAN_STA_ASSOC | WLAN_STA_ASSOC_REQ_OK);
 		ieee802_1x_notify_port_enabled(sta->eapol_sm, 0);
 		if (!sta->acct_terminate_cause)
 			sta->acct_terminate_cause =
@@ -493,7 +493,6 @@
 		return NULL;
 	}
 	sta->acct_interim_interval = hapd->conf->acct_interim_interval;
-	accounting_sta_get_id(hapd, sta);
 
 	/* initialize STA info data */
 	wpa_printf(MSG_DEBUG, "%s: register ap_handle_timer timeout "
@@ -570,7 +569,7 @@
 {
 	wpa_printf(MSG_DEBUG, "%s: disassociate STA " MACSTR,
 		   hapd->conf->iface, MAC2STR(sta->addr));
-	sta->flags &= ~WLAN_STA_ASSOC;
+	sta->flags &= ~(WLAN_STA_ASSOC | WLAN_STA_ASSOC_REQ_OK);
 	ap_sta_set_authorized(hapd, sta, 0);
 	sta->timeout_next = STA_DEAUTH;
 	wpa_printf(MSG_DEBUG, "%s: reschedule ap_handle_timer timeout "
@@ -608,7 +607,8 @@
 {
 	wpa_printf(MSG_DEBUG, "%s: deauthenticate STA " MACSTR,
 		   hapd->conf->iface, MAC2STR(sta->addr));
-	sta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC);
+	sta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC | WLAN_STA_ASSOC_REQ_OK);
+	ap_sta_cancel_priority(hapd, sta);
 	ap_sta_set_authorized(hapd, sta, 0);
 	sta->timeout_next = STA_REMOVE;
 	wpa_printf(MSG_DEBUG, "%s: reschedule ap_handle_timer timeout "
@@ -885,6 +885,7 @@
 				AP_STA_CONNECTED MACSTR, MAC2STR(sta->addr));
 
 		sta->flags |= WLAN_STA_AUTHORIZED;
+		ap_sta_cancel_priority(hapd, sta);
 	} else {
 		if (dev_addr)
 			wpa_msg(hapd->msg_ctx, MSG_INFO, AP_STA_DISCONNECTED
@@ -927,7 +928,8 @@
 	ap_sta_set_authorized(hapd, sta, 0);
 	wpa_auth_sm_event(sta->wpa_sm, WPA_DEAUTH);
 	ieee802_1x_notify_port_enabled(sta->eapol_sm, 0);
-	sta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC);
+	sta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC | WLAN_STA_ASSOC_REQ_OK);
+	ap_sta_cancel_priority(hapd, sta);
 	wpa_printf(MSG_DEBUG, "%s: reschedule ap_handle_timer timeout "
 		   "for " MACSTR " (%d seconds - "
 		   "AP_MAX_INACTIVITY_AFTER_DEAUTH)",
@@ -969,3 +971,26 @@
 	eloop_cancel_timeout(ap_sta_disassoc_cb_timeout, hapd, sta);
 	ap_sta_disassoc_cb_timeout(hapd, sta);
 }
+
+void ap_sta_set_priority(struct hostapd_data *hapd, struct sta_info *sta)
+{
+	if (sta->priority_set)
+		return;
+
+	if (sta->flags & WLAN_STA_AUTHORIZED)
+		return;
+
+	sta->priority_set = 1;
+	if (!hapd->num_priorities++)
+		hostapd_drv_set_priority(hapd);
+}
+
+void ap_sta_cancel_priority(struct hostapd_data *hapd, struct sta_info *sta)
+{
+	if (!sta->priority_set)
+		return;
+
+	sta->priority_set = 0;
+	if (!--hapd->num_priorities)
+		hostapd_drv_cancel_priority(hapd);
+}
diff -Nur hostapd-2.0/src/ap/sta_info.h hostapd-2.0-TI/src/ap/sta_info.h
--- hostapd-2.0/src/ap/sta_info.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/sta_info.h	2014-03-28 17:49:32.000000000 +0800
@@ -57,6 +57,7 @@
 	unsigned int no_ht_set:1;
 	unsigned int ht_20mhz_set:1;
 	unsigned int no_p2p_set:1;
+	unsigned int priority_set:1;
 
 	u16 auth_alg;
 	u8 previous_ap[6];
@@ -190,5 +191,7 @@
 
 void ap_sta_deauth_cb(struct hostapd_data *hapd, struct sta_info *sta);
 void ap_sta_disassoc_cb(struct hostapd_data *hapd, struct sta_info *sta);
+void ap_sta_set_priority(struct hostapd_data *hapd, struct sta_info *sta);
+void ap_sta_cancel_priority(struct hostapd_data *hapd, struct sta_info *sta);
 
 #endif /* STA_INFO_H */
diff -Nur hostapd-2.0/src/ap/tkip_countermeasures.c hostapd-2.0-TI/src/ap/tkip_countermeasures.c
--- hostapd-2.0/src/ap/tkip_countermeasures.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/tkip_countermeasures.c	2014-03-28 17:49:32.000000000 +0800
@@ -55,6 +55,7 @@
 		}
 		hostapd_drv_sta_deauth(hapd, sta->addr,
 				       WLAN_REASON_MICHAEL_MIC_FAILURE);
+		ap_sta_cancel_priority(hapd, sta);
 		ap_free_sta(hapd, sta);
 	}
 }
diff -Nur hostapd-2.0/src/ap/wnm_ap.c hostapd-2.0-TI/src/ap/wnm_ap.c
--- hostapd-2.0/src/ap/wnm_ap.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/wnm_ap.c	2014-03-28 17:49:32.000000000 +0800
@@ -19,6 +19,7 @@
 
 #define MAX_TFS_IE_LEN  1024
 
+#ifdef CONFIG_IEEE80211V
 
 /* get the TFS IE from driver */
 static int ieee80211_11_get_tfs_ie(struct hostapd_data *hapd, const u8 *addr,
@@ -56,8 +57,8 @@
 	u16 wnmtfs_ie_len;
 	u8 *pos;
 	struct sta_info *sta;
-	enum wnm_oper tfs_oper = action_type == WNM_SLEEP_MODE_ENTER ?
-		WNM_SLEEP_TFS_RESP_IE_ADD : WNM_SLEEP_TFS_RESP_IE_NONE;
+	enum wnm_oper tfs_oper = action_type == 0 ? WNM_SLEEP_TFS_RESP_IE_ADD :
+		WNM_SLEEP_TFS_RESP_IE_NONE;
 
 	sta = ap_get_sta(hapd, addr);
 	if (sta == NULL) {
@@ -104,8 +105,7 @@
 	mgmt->u.action.u.wnm_sleep_resp.dialogtoken = dialog_token;
 	pos = (u8 *)mgmt->u.action.u.wnm_sleep_resp.variable;
 	/* add key data if MFP is enabled */
-	if (!wpa_auth_uses_mfp(sta->wpa_sm) ||
-	    action_type != WNM_SLEEP_MODE_EXIT) {
+	if (wpa_auth_uses_mfp(sta->wpa_sm) || action_type != 1){
 		mgmt->u.action.u.wnm_sleep_resp.keydata_len = 0;
 	} else {
 		gtk_elem_len = wpa_wnmsleep_gtk_subelem(sta->wpa_sm, pos);
@@ -132,8 +132,7 @@
 	os_memcpy(pos, &wnmsleep_ie, wnmsleep_ie_len);
 	/* copy TFS IE here */
 	pos += wnmsleep_ie_len;
-	if (wnmtfs_ie)
-		os_memcpy(pos, wnmtfs_ie, wnmtfs_ie_len);
+	os_memcpy(pos, wnmtfs_ie, wnmtfs_ie_len);
 
 	len = 1 + sizeof(mgmt->u.action.u.wnm_sleep_resp) + gtk_elem_len +
 		igtk_elem_len + wnmsleep_ie_len + wnmtfs_ie_len;
@@ -153,7 +152,7 @@
 		 * WNM Sleep
 		 */
 		if (wnmsleep_ie.status == WNM_STATUS_SLEEP_ACCEPT &&
-		    wnmsleep_ie.action_type == WNM_SLEEP_MODE_ENTER) {
+		    wnmsleep_ie.action_type == 0) {
 			hostapd_drv_wnm_oper(hapd, WNM_SLEEP_ENTER_CONFIRM,
 					     addr, NULL, NULL);
 			wpa_set_wnmsleep(sta->wpa_sm, 1);
@@ -163,14 +162,12 @@
 		 * 2. start GTK/IGTK update if MFP is not used
 		 * 3. unpause the node in driver
 		 */
-		if ((wnmsleep_ie.status == WNM_STATUS_SLEEP_ACCEPT ||
-		     wnmsleep_ie.status ==
-		     WNM_STATUS_SLEEP_EXIT_ACCEPT_GTK_UPDATE) &&
-		    wnmsleep_ie.action_type == WNM_SLEEP_MODE_EXIT) {
+		if (wnmsleep_ie.status == WNM_STATUS_SLEEP_ACCEPT &&
+		    wnmsleep_ie.action_type == 1) {
 			wpa_set_wnmsleep(sta->wpa_sm, 0);
 			hostapd_drv_wnm_oper(hapd, WNM_SLEEP_EXIT_CONFIRM,
 					     addr, NULL, NULL);
-			if (!wpa_auth_uses_mfp(sta->wpa_sm))
+			if (wpa_auth_uses_mfp(sta->wpa_sm) && action_type == 1)
 				wpa_wnmsleep_rekey_gtk(sta->wpa_sm);
 		}
 	} else
@@ -187,29 +184,29 @@
 static void ieee802_11_rx_wnmsleep_req(struct hostapd_data *hapd,
 				       const u8 *addr, const u8 *frm, int len)
 {
-	/* Dialog Token [1] | WNM-Sleep Mode IE | TFS Response IE */
-	const u8 *pos = frm;
-	u8 dialog_token;
+	/*
+	 * Action [1] | Dialog Token [1] | WNM-Sleep Mode IE |
+	 * TFS Response IE
+	 */
+	u8 *pos = (u8 *) frm; /* point to action field */
+	u8 dialog_token = pos[1];
 	struct wnm_sleep_element *wnmsleep_ie = NULL;
 	/* multiple TFS Req IE (assuming consecutive) */
 	u8 *tfsreq_ie_start = NULL;
 	u8 *tfsreq_ie_end = NULL;
 	u16 tfsreq_ie_len = 0;
 
-	dialog_token = *pos++;
-	while (pos + 1 < frm + len) {
-		u8 ie_len = pos[1];
-		if (pos + 2 + ie_len > frm + len)
-			break;
+	pos += 1 + 1;
+	while (pos - frm < len - 1) {
+		u8 ie_len = *(pos+1);
 		if (*pos == WLAN_EID_WNMSLEEP)
-			wnmsleep_ie = (struct wnm_sleep_element *) pos;
+			wnmsleep_ie = (struct wnm_sleep_element *)pos;
 		else if (*pos == WLAN_EID_TFS_REQ) {
 			if (!tfsreq_ie_start)
-				tfsreq_ie_start = (u8 *) pos;
-			tfsreq_ie_end = (u8 *) pos;
+				tfsreq_ie_start = pos;
+			tfsreq_ie_end = pos;
 		} else
-			wpa_printf(MSG_DEBUG, "WNM: EID %d not recognized",
-				   *pos);
+			wpa_printf(MSG_DEBUG, "EID %d not recognized", *pos);
 		pos += ie_len + 2;
 	}
 
@@ -218,9 +215,8 @@
 		return;
 	}
 
-	if (wnmsleep_ie->action_type == WNM_SLEEP_MODE_ENTER &&
-	    tfsreq_ie_start && tfsreq_ie_end &&
-	    tfsreq_ie_end - tfsreq_ie_start >= 0) {
+	if (wnmsleep_ie->action_type == 0 && tfsreq_ie_start &&
+	    tfsreq_ie_end && tfsreq_ie_end - tfsreq_ie_start >= 0) {
 		tfsreq_ie_len = (tfsreq_ie_end + tfsreq_ie_end[1] + 2) -
 			tfsreq_ie_start;
 		wpa_printf(MSG_DEBUG, "TFS Req IE(s) found");
@@ -235,7 +231,7 @@
 				      wnmsleep_ie->action_type,
 				      wnmsleep_ie->intval);
 
-	if (wnmsleep_ie->action_type == WNM_SLEEP_MODE_EXIT) {
+	if (wnmsleep_ie->action_type == 1) {
 		/* clear the tfs after sending the resp frame */
 		ieee80211_11_set_tfs_ie(hapd, addr, tfsreq_ie_start,
 					&tfsreq_ie_len, WNM_SLEEP_TFS_IE_DEL);
@@ -243,29 +239,20 @@
 }
 
 
-int ieee802_11_rx_wnm_action_ap(struct hostapd_data *hapd,
-				struct rx_action *action)
+void ieee802_11_rx_wnm_action_ap(struct hostapd_data *hapd,
+				 struct rx_action *action)
 {
-	if (action->len < 1 || action->data == NULL)
-		return -1;
+	u8 *pos = (u8 *) action->data + 1; /* point to the action field */
+	u8 act = *pos;
 
-	switch (action->data[0]) {
-	case WNM_BSS_TRANS_MGMT_QUERY:
-		wpa_printf(MSG_DEBUG, "WNM: BSS Transition Management Query");
-		/* TODO */
-		return -1;
-	case WNM_BSS_TRANS_MGMT_RESP:
-		wpa_printf(MSG_DEBUG, "WNM: BSS Transition Management "
-			   "Response");
-		/* TODO */
-		return -1;
+	switch (act) {
 	case WNM_SLEEP_MODE_REQ:
 		ieee802_11_rx_wnmsleep_req(hapd, action->sa, action->data + 1,
-					   action->len - 1);
-		return 0;
+					   action->len);
+		break;
+	default:
+		break;
 	}
-
-	wpa_printf(MSG_DEBUG, "WNM: Unsupported WNM Action %u from " MACSTR,
-		   action->data[0], MAC2STR(action->sa));
-	return -1;
 }
+
+#endif /* CONFIG_IEEE80211V */
diff -Nur hostapd-2.0/src/ap/wnm_ap.h hostapd-2.0-TI/src/ap/wnm_ap.h
--- hostapd-2.0/src/ap/wnm_ap.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/wnm_ap.h	2014-03-28 17:49:32.000000000 +0800
@@ -11,7 +11,7 @@
 
 struct rx_action;
 
-int ieee802_11_rx_wnm_action_ap(struct hostapd_data *hapd,
-				struct rx_action *action);
+void ieee802_11_rx_wnm_action_ap(struct hostapd_data *hapd,
+				 struct rx_action *action);
 
 #endif /* WNM_AP_H */
diff -Nur hostapd-2.0/src/ap/wpa_auth.c hostapd-2.0-TI/src/ap/wpa_auth.c
--- hostapd-2.0/src/ap/wpa_auth.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/wpa_auth.c	2014-03-28 17:49:32.000000000 +0800
@@ -2413,9 +2413,11 @@
 				"marking station for GTK rekeying");
 	}
 
-	/* Do not rekey GTK/IGTK when STA is in WNM-Sleep Mode */
+#ifdef CONFIG_IEEE80211V
+	/* Do not rekey GTK/IGTK when STA is in wnmsleep */
 	if (sm->is_wnmsleep)
 		return 0;
+#endif /* CONFIG_IEEE80211V */
 
 	sm->group->GKeyDoneStations++;
 	sm->GUpdateStationKeys = TRUE;
@@ -2425,8 +2427,8 @@
 }
 
 
-#ifdef CONFIG_WNM
-/* update GTK when exiting WNM-Sleep Mode */
+#ifdef CONFIG_IEEE80211V
+/* update GTK when exiting wnmsleep mode */
 void wpa_wnmsleep_rekey_gtk(struct wpa_state_machine *sm)
 {
 	if (sm->is_wnmsleep)
@@ -2444,65 +2446,111 @@
 
 int wpa_wnmsleep_gtk_subelem(struct wpa_state_machine *sm, u8 *pos)
 {
+	u8 *subelem;
 	struct wpa_group *gsm = sm->group;
-	u8 *start = pos;
+	size_t subelem_len, pad_len;
+	const u8 *key;
+	size_t key_len;
+	u8 keybuf[32];
+
+	/* GTK subslement */
+	key_len = gsm->GTK_len;
+	if (key_len > sizeof(keybuf))
+		return 0;
+
+	/*
+	 * Pad key for AES Key Wrap if it is not multiple of 8 bytes or is less
+	 * than 16 bytes.
+	 */
+	pad_len = key_len % 8;
+	if (pad_len)
+		pad_len = 8 - pad_len;
+	if (key_len + pad_len < 16)
+		pad_len += 8;
+	if (pad_len) {
+		os_memcpy(keybuf, gsm->GTK[gsm->GN - 1], key_len);
+		os_memset(keybuf + key_len, 0, pad_len);
+		keybuf[key_len] = 0xdd;
+		key_len += pad_len;
+		key = keybuf;
+	} else
+		key = gsm->GTK[gsm->GN - 1];
 
 	/*
-	 * GTK subelement:
 	 * Sub-elem ID[1] | Length[1] | Key Info[2] | Key Length[1] | RSC[8] |
-	 * Key[5..32]
+	 * Key[5..32] | 8 padding.
 	 */
-	*pos++ = WNM_SLEEP_SUBELEM_GTK;
-	*pos++ = 11 + gsm->GTK_len;
+	subelem_len = 13 + key_len + 8;
+	subelem = os_zalloc(subelem_len);
+	if (subelem == NULL)
+		return 0;
+
+	subelem[0] = WNM_SLEEP_SUBELEM_GTK;
+	subelem[1] = 11 + key_len + 8;
 	/* Key ID in B0-B1 of Key Info */
-	WPA_PUT_LE16(pos, gsm->GN & 0x03);
-	pos += 2;
-	*pos++ = gsm->GTK_len;
-	if (wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN, pos) != 0)
-		return 0;
-	pos += 8;
-	os_memcpy(pos, gsm->GTK[gsm->GN - 1], gsm->GTK_len);
-	pos += gsm->GTK_len;
-
-	wpa_printf(MSG_DEBUG, "WNM: GTK Key ID %u in WNM-Sleep Mode exit",
-		   gsm->GN);
-	wpa_hexdump_key(MSG_DEBUG, "WNM: GTK in WNM-Sleep Mode exit",
+	WPA_PUT_LE16(&subelem[2], gsm->GN & 0x03);
+	subelem[4] = gsm->GTK_len;
+	if (wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN, subelem + 5) != 0)
+	{
+		os_free(subelem);
+		return 0;
+	}
+	if (aes_wrap(sm->PTK.kek, key_len / 8, key, subelem + 13)) {
+		os_free(subelem);
+		return 0;
+	}
+
+	os_memcpy(pos, subelem, subelem_len);
+
+	wpa_hexdump_key(MSG_DEBUG, "Plaintext GTK",
 			gsm->GTK[gsm->GN - 1], gsm->GTK_len);
+	os_free(subelem);
 
-	return pos - start;
+	return subelem_len;
 }
 
 
 #ifdef CONFIG_IEEE80211W
 int wpa_wnmsleep_igtk_subelem(struct wpa_state_machine *sm, u8 *pos)
 {
+	u8 *subelem, *ptr;
 	struct wpa_group *gsm = sm->group;
-	u8 *start = pos;
+	size_t subelem_len;
 
-	/*
-	 * IGTK subelement:
-	 * Sub-elem ID[1] | Length[1] | KeyID[2] | PN[6] | Key[16]
-	 */
-	*pos++ = WNM_SLEEP_SUBELEM_IGTK;
-	*pos++ = 2 + 6 + WPA_IGTK_LEN;
-	WPA_PUT_LE16(pos, gsm->GN_igtk);
-	pos += 2;
-	if (wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN_igtk, pos) != 0)
-		return 0;
-	pos += 6;
-
-	os_memcpy(pos, gsm->IGTK[gsm->GN_igtk - 4], WPA_IGTK_LEN);
-	pos += WPA_IGTK_LEN;
-
-	wpa_printf(MSG_DEBUG, "WNM: IGTK Key ID %u in WNM-Sleep Mode exit",
-		   gsm->GN_igtk);
-	wpa_hexdump_key(MSG_DEBUG, "WNM: IGTK in WNM-Sleep Mode exit",
+	/* IGTK subelement
+	 * Sub-elem ID[1] | Length[1] | KeyID[2] | PN[6] |
+	 * Key[16] | 8 padding */
+	subelem_len = 1 + 1 + 2 + 6 + WPA_IGTK_LEN + 8;
+	subelem = os_zalloc(subelem_len);
+	if (subelem == NULL)
+		return 0;
+
+	ptr = subelem;
+	*ptr++ = WNM_SLEEP_SUBELEM_IGTK;
+	*ptr++ = subelem_len - 2;
+	WPA_PUT_LE16(ptr, gsm->GN_igtk);
+	ptr += 2;
+	if (wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN_igtk, ptr) != 0) {
+		os_free(subelem);
+		return 0;
+	}
+	ptr += 6;
+	if (aes_wrap(sm->PTK.kek, WPA_IGTK_LEN / 8,
+		     gsm->IGTK[gsm->GN_igtk - 4], ptr)) {
+		os_free(subelem);
+		return -1;
+	}
+
+	os_memcpy(pos, subelem, subelem_len);
+
+	wpa_hexdump_key(MSG_DEBUG, "Plaintext IGTK",
 			gsm->IGTK[gsm->GN_igtk - 4], WPA_IGTK_LEN);
+	os_free(subelem);
 
-	return pos - start;
+	return subelem_len;
 }
 #endif /* CONFIG_IEEE80211W */
-#endif /* CONFIG_WNM */
+#endif /* CONFIG_IEEE80211V */
 
 
 static void wpa_group_setkeys(struct wpa_authenticator *wpa_auth,
diff -Nur hostapd-2.0/src/ap/wpa_auth.h hostapd-2.0-TI/src/ap/wpa_auth.h
--- hostapd-2.0/src/ap/wpa_auth.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/wpa_auth.h	2014-03-28 17:49:32.000000000 +0800
@@ -282,10 +282,14 @@
 void wpa_ft_push_pmk_r1(struct wpa_authenticator *wpa_auth, const u8 *addr);
 #endif /* CONFIG_IEEE80211R */
 
+#ifdef CONFIG_IEEE80211V
 void wpa_wnmsleep_rekey_gtk(struct wpa_state_machine *sm);
 void wpa_set_wnmsleep(struct wpa_state_machine *sm, int flag);
 int wpa_wnmsleep_gtk_subelem(struct wpa_state_machine *sm, u8 *pos);
+#ifdef CONFIG_IEEE80211W
 int wpa_wnmsleep_igtk_subelem(struct wpa_state_machine *sm, u8 *pos);
+#endif /* CONFIG_IEEE80211W */
+#endif /* CONFIG_IEEE80211V */
 
 int wpa_auth_uses_sae(struct wpa_state_machine *sm);
 
diff -Nur hostapd-2.0/src/ap/wpa_auth_i.h hostapd-2.0-TI/src/ap/wpa_auth_i.h
--- hostapd-2.0/src/ap/wpa_auth_i.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/wpa_auth_i.h	2014-03-28 17:49:32.000000000 +0800
@@ -87,7 +87,9 @@
 	unsigned int ft_completed:1;
 	unsigned int pmk_r1_name_valid:1;
 #endif /* CONFIG_IEEE80211R */
+#ifdef CONFIG_IEEE80211V
 	unsigned int is_wnmsleep:1;
+#endif /* CONFIG_IEEE80211V */
 
 	u8 req_replay_counter[WPA_REPLAY_COUNTER_LEN];
 	int req_replay_counter_used;
diff -Nur hostapd-2.0/src/ap/wps_hostapd.c hostapd-2.0-TI/src/ap/wps_hostapd.c
--- hostapd-2.0/src/ap/wps_hostapd.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/ap/wps_hostapd.c	2014-03-28 17:49:32.000000000 +0800
@@ -957,9 +957,6 @@
 	if (conf->ssid.security_policy == SECURITY_STATIC_WEP)
 		cfg.static_wep_only = 1;
 	cfg.dualband = interface_count(hapd->iface) > 1;
-	if ((wps->dev.rf_bands & (WPS_RF_50GHZ | WPS_RF_24GHZ)) ==
-	    (WPS_RF_50GHZ | WPS_RF_24GHZ))
-		cfg.dualband = 1;
 	if (cfg.dualband)
 		wpa_printf(MSG_DEBUG, "WPS: Dualband AP");
 
diff -Nur hostapd-2.0/src/common/defs.h hostapd-2.0-TI/src/common/defs.h
--- hostapd-2.0/src/common/defs.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/common/defs.h	2014-03-28 17:49:34.000000000 +0800
@@ -297,7 +297,6 @@
 	HOSTAPD_MODE_IEEE80211B,
 	HOSTAPD_MODE_IEEE80211G,
 	HOSTAPD_MODE_IEEE80211A,
-	HOSTAPD_MODE_IEEE80211AD,
 	NUM_HOSTAPD_MODES
 };
 
diff -Nur hostapd-2.0/src/common/ieee802_11_common.c hostapd-2.0-TI/src/common/ieee802_11_common.c
--- hostapd-2.0/src/common/ieee802_11_common.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/common/ieee802_11_common.c	2014-03-28 17:49:34.000000000 +0800
@@ -284,10 +284,6 @@
 				break;
 			elems->bss_max_idle_period = pos;
 			break;
-		case WLAN_EID_SSID_LIST:
-			elems->ssid_list = pos;
-			elems->ssid_list_len = elen;
-			break;
 		default:
 			unknown++;
 			if (!show_errors)
diff -Nur hostapd-2.0/src/common/ieee802_11_common.h hostapd-2.0-TI/src/common/ieee802_11_common.h
--- hostapd-2.0/src/common/ieee802_11_common.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/common/ieee802_11_common.h	2014-03-28 17:49:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
  * IEEE 802.11 Common routines
- * Copyright (c) 2002-2012, Jouni Malinen <j@w1.fi>
+ * Copyright (c) 2002-2009, Jouni Malinen <j@w1.fi>
  *
  * This software may be distributed under the terms of the BSD license.
  * See README for more details.
@@ -43,7 +43,6 @@
 	const u8 *hs20;
 	const u8 *ext_capab;
 	const u8 *bss_max_idle_period;
-	const u8 *ssid_list;
 
 	u8 ssid_len;
 	u8 supp_rates_len;
@@ -75,7 +74,6 @@
 	u8 interworking_len;
 	u8 hs20_len;
 	u8 ext_capab_len;
-	u8 ssid_list_len;
 };
 
 typedef enum { ParseOK = 0, ParseUnknown = 1, ParseFailed = -1 } ParseRes;
diff -Nur hostapd-2.0/src/common/ieee802_11_defs.h hostapd-2.0-TI/src/common/ieee802_11_defs.h
--- hostapd-2.0/src/common/ieee802_11_defs.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/common/ieee802_11_defs.h	2014-03-28 17:49:34.000000000 +0800
@@ -232,7 +232,6 @@
 #define WLAN_EID_20_40_BSS_INTOLERANT 73
 #define WLAN_EID_OVERLAPPING_BSS_SCAN_PARAMS 74
 #define WLAN_EID_MMIE 76
-#define WLAN_EID_SSID_LIST 84
 #define WLAN_EID_BSS_MAX_IDLE_PERIOD 90
 #define WLAN_EID_TFS_REQ 91
 #define WLAN_EID_TFS_RESP 92
@@ -538,16 +537,6 @@
 					 * Entries */
 					u8 variable[0];
 				} STRUCT_PACKED bss_tm_req;
-				struct {
-					u8 action; /* 8 */
-					u8 dialog_token;
-					u8 status_code;
-					u8 bss_termination_delay;
-					/* Target BSSID (optional),
-					 * BSS Transition Candidate List
-					 * Entries (optional) */
-					u8 variable[0];
-				} STRUCT_PACKED bss_tm_resp;
 			} u;
 		} STRUCT_PACKED action;
 	} u;
@@ -1059,14 +1048,11 @@
 struct wnm_sleep_element {
 	u8 eid;     /* WLAN_EID_WNMSLEEP */
 	u8 len;
-	u8 action_type; /* WNM_SLEEP_ENTER/WNM_SLEEP_MODE_EXIT */
+	u8 action_type; /* WLAN_WNM_SLEEP_ENTER/EXIT */
 	u8 status;
 	le16 intval;
 } STRUCT_PACKED;
 
-#define WNM_SLEEP_MODE_ENTER 0
-#define WNM_SLEEP_MODE_EXIT 1
-
 enum wnm_sleep_mode_response_status {
 	WNM_STATUS_SLEEP_ACCEPT = 0,
 	WNM_STATUS_SLEEP_EXIT_ACCEPT_GTK_UPDATE = 1,
diff -Nur hostapd-2.0/src/common/version.h hostapd-2.0-TI/src/common/version.h
--- hostapd-2.0/src/common/version.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/common/version.h	2014-03-28 17:49:34.000000000 +0800
@@ -5,6 +5,6 @@
 #define VERSION_STR_POSTFIX ""
 #endif /* VERSION_STR_POSTFIX */
 
-#define VERSION_STR "2.0" VERSION_STR_POSTFIX
+#define VERSION_STR "2.0-devel" VERSION_STR_POSTFIX
 
 #endif /* VERSION_H */
diff -Nur hostapd-2.0/src/common/wpa_ctrl.h hostapd-2.0-TI/src/common/wpa_ctrl.h
--- hostapd-2.0/src/common/wpa_ctrl.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/common/wpa_ctrl.h	2014-03-28 17:49:34.000000000 +0800
@@ -146,6 +146,9 @@
 #define AP_STA_CONNECTED "AP-STA-CONNECTED "
 #define AP_STA_DISCONNECTED "AP-STA-DISCONNECTED "
 
+/* smart config events */
+#define SMART_CONFIG_EVENT_SYNCED "SMART-CONFIG-SYNC-COMPLETE "
+#define SMART_CONFIG_EVENT_DECODED "SMART-CONFIG-SUCCESS "
 
 /* BSS command information masks */
 
diff -Nur hostapd-2.0/src/crypto/tls_openssl.c hostapd-2.0-TI/src/crypto/tls_openssl.c
--- hostapd-2.0/src/crypto/tls_openssl.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/crypto/tls_openssl.c	2014-03-28 17:49:34.000000000 +0800
@@ -10,9 +10,11 @@
 
 #ifndef CONFIG_SMARTCARD
 #ifndef OPENSSL_NO_ENGINE
+#ifndef ANDROID
 #define OPENSSL_NO_ENGINE
 #endif
 #endif
+#endif
 
 #include <openssl/ssl.h>
 #include <openssl/err.h>
@@ -806,16 +808,21 @@
 		wpa_printf(MSG_ERROR, "ENGINE: Engine ID not set");
 		return -1;
 	}
+#ifndef ANDROID
 	if (pin == NULL) {
 		wpa_printf(MSG_ERROR, "ENGINE: Smartcard PIN not set");
 		return -1;
 	}
+#endif
 	if (key_id == NULL) {
 		wpa_printf(MSG_ERROR, "ENGINE: Key Id not set");
 		return -1;
 	}
 
 	ERR_clear_error();
+#ifdef ANDROID
+	ENGINE_load_dynamic();
+#endif
 	conn->engine = ENGINE_by_id(engine_id);
 	if (!conn->engine) {
 		wpa_printf(MSG_ERROR, "ENGINE: engine %s not available [%s]",
@@ -830,11 +837,13 @@
 	}
 	wpa_printf(MSG_DEBUG, "ENGINE: engine initialized");
 
+#ifndef ANDROID
 	if (ENGINE_ctrl_cmd_string(conn->engine, "PIN", pin, 0) == 0) {
 		wpa_printf(MSG_ERROR, "ENGINE: cannot set pin [%s]",
 			   ERR_error_string(ERR_get_error(), NULL));
 		goto err;
 	}
+#endif
 	/* load private key first in-case PIN is required for cert */
 	conn->private_key = ENGINE_load_private_key(conn->engine,
 						    key_id, NULL, NULL);
@@ -933,6 +942,11 @@
 #ifdef SSL_OP_NO_COMPRESSION
 	options |= SSL_OP_NO_COMPRESSION;
 #endif /* SSL_OP_NO_COMPRESSION */
+#ifdef ANDROID
+	options |= SSL_OP_NO_TLSv1_1;
+	options |= SSL_OP_NO_TLSv1_2;
+	options |= SSL_OP_NO_TICKET;
+#endif /* ANDROID */
 	SSL_set_options(conn->ssl, options);
 
 	conn->ssl_in = BIO_new(BIO_s_mem());
diff -Nur hostapd-2.0/src/drivers/android_drv.h hostapd-2.0-TI/src/drivers/android_drv.h
--- hostapd-2.0/src/drivers/android_drv.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/drivers/android_drv.h	2014-03-28 17:49:34.000000000 +0800
@@ -19,6 +19,9 @@
 #define MAX_DRV_CMD_SIZE		248
 #define DRV_NUMBER_SEQUENTIAL_ERRORS	4
 
+#define RSSI_CMD			"RSSI"
+#define LINKSPEED_CMD			"LINKSPEED"
+
 #define WEXT_PNOSETUP_HEADER		"PNOSETUP "
 #define WEXT_PNOSETUP_HEADER_SIZE	9
 #define WEXT_PNO_TLV_PREFIX		'S'
diff -Nur hostapd-2.0/src/drivers/driver_atheros.c hostapd-2.0-TI/src/drivers/driver_atheros.c
--- hostapd-2.0/src/drivers/driver_atheros.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/drivers/driver_atheros.c	2014-03-28 17:49:34.000000000 +0800
@@ -874,7 +874,7 @@
 }
 #endif /* CONFIG_HS20 */
 
-#if defined(CONFIG_WNM) && !defined(CONFIG_IEEE80211R)
+#if defined(CONFIG_IEEE80211V) && !defined(CONFIG_IEEE80211R)
 static void atheros_raw_recv_11v(void *ctx, const u8 *src_addr, const u8 *buf,
 				 size_t len)
 {
@@ -921,9 +921,9 @@
 		break;
 	}
 }
-#endif /* CONFIG_WNM */
+#endif /* CONFIG_IEEE80211V */
 
-#if defined(CONFIG_WPS) || defined(CONFIG_IEEE80211R) || defined(CONFIG_WNM)
+#if defined(CONFIG_WPS) || defined(CONFIG_IEEE80211R) || defined(CONFIG_IEEE80211V)
 static void atheros_raw_receive(void *ctx, const u8 *src_addr, const u8 *buf,
 				size_t len)
 {
@@ -933,9 +933,9 @@
 #ifdef CONFIG_IEEE80211R
 	atheros_raw_recv_11r(ctx, src_addr, buf, len);
 #endif /* CONFIG_IEEE80211R */
-#if defined(CONFIG_WNM) && !defined(CONFIG_IEEE80211R)
+#if defined(CONFIG_IEEE80211V) && !defined(CONFIG_IEEE80211R)
 	atheros_raw_recv_11v(ctx, src_addr, buf, len);
-#endif /* CONFIG_WNM */
+#endif /* CONFIG_IEEE80211V */
 #ifdef CONFIG_HS20
 	atheros_raw_recv_hs20(ctx, src_addr, buf, len);
 #endif /* CONFIG_HS20 */
@@ -957,9 +957,9 @@
 			       IEEE80211_FILTER_TYPE_AUTH |
 			       IEEE80211_FILTER_TYPE_ACTION);
 #endif
-#ifdef CONFIG_WNM
+#ifdef CONFIG_IEEE80211V
 	filt.app_filterype |= IEEE80211_FILTER_TYPE_ACTION;
-#endif /* CONFIG_WNM */
+#endif /* CONFIG_IEEE80211V */
 #ifdef CONFIG_HS20
 	filt.app_filterype |= IEEE80211_FILTER_TYPE_ACTION;
 #endif /* CONFIG_HS20 */
@@ -1688,17 +1688,13 @@
 	linux_set_iface_flags(drv->ioctl_sock, drv->iface, 0);
 	atheros_set_privacy(drv, 0); /* default to no privacy */
 
-	if (atheros_receive_pkt(drv))
-		goto bad;
+	atheros_receive_pkt(drv);
 
 	if (atheros_wireless_event_init(drv))
 		goto bad;
 
 	return drv;
 bad:
-	atheros_reset_appfilter(drv);
-	if (drv->sock_raw)
-		l2_packet_deinit(drv->sock_raw);
 	if (drv->sock_recv != NULL && drv->sock_recv != drv->sock_xmit)
 		l2_packet_deinit(drv->sock_recv);
 	if (drv->sock_xmit != NULL)
@@ -1963,7 +1959,7 @@
 }
 
 
-#ifdef CONFIG_WNM
+#ifdef CONFIG_IEEE80211V
 static int athr_wnm_tfs(struct atheros_driver_data *drv, const u8* peer,
 			u8 *ie, u16 *len, enum wnm_oper oper)
 {
@@ -2116,7 +2112,7 @@
 		return -1;
 	}
 }
-#endif /* CONFIG_WNM */
+#endif /* CONFIG_IEEE80211V */
 
 
 const struct wpa_driver_ops wpa_driver_atheros_ops = {
@@ -2150,7 +2146,7 @@
 	.add_sta_node    	= atheros_add_sta_node,
 #endif /* CONFIG_IEEE80211R */
 	.send_action		= atheros_send_action,
-#ifdef CONFIG_WNM
+#ifdef CONFIG_IEEE80211V
 	.wnm_oper		= atheros_wnm_oper,
-#endif /* CONFIG_WNM */
+#endif /* CONFIG_IEEE80211V */
 };
diff -Nur hostapd-2.0/src/drivers/driver_common.c hostapd-2.0-TI/src/drivers/driver_common.c
--- hostapd-2.0/src/drivers/driver_common.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/drivers/driver_common.c	2014-03-28 17:49:34.000000000 +0800
@@ -79,6 +79,9 @@
 	E2S(EAPOL_TX_STATUS);
 	E2S(CH_SWITCH);
 	E2S(WNM);
+	E2S(START_ROAMING);
+	E2S(SMART_CONFIG_SYNC);
+	E2S(SMART_CONFIG_DECODE);
 	}
 
 	return "UNKNOWN";
diff -Nur hostapd-2.0/src/drivers/driver.h hostapd-2.0-TI/src/drivers/driver.h
--- hostapd-2.0/src/drivers/driver.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/drivers/driver.h	2014-04-17 17:31:27.000000000 +0800
@@ -847,6 +847,7 @@
 	int max_scan_ssids;
 	int max_sched_scan_ssids;
 	int sched_scan_supported;
+	int sched_scan_intervals_supported;
 	int max_match_sets;
 
 	/**
@@ -1037,6 +1038,16 @@
 };
 
 /**
+ * struct wpa_signal_info - Information about channel
+ */
+struct wpa_channel_info {
+	u32 frequency;
+	int sec_channel_offset; /* 0 = HT40 disabled, -1 = HT40 enabled,
+				 * secondary channel below primary, 1 = HT40
+				 * enabled, secondary channel above primary */
+};
+
+/**
  * struct wpa_driver_ops - Driver interface API definition
  *
  * This structure defines the API that each driver interface needs to implement
@@ -1448,7 +1459,7 @@
 	 * of setting a regulatory domain.
 	 */
 	int (*set_country)(void *priv, const char *alpha2);
-
+	int (*get_country)(void *priv, char *alpha2);
 	/**
 	 * global_init - Global driver initialization
 	 * Returns: Pointer to private data (global), %NULL on failure
@@ -1507,6 +1518,40 @@
 	int (*scan2)(void *priv, struct wpa_driver_scan_params *params);
 
 	/**
+	 * sched_scan - Request the driver to initiate scheduled scan
+	 * @priv: private driver interface data
+	 * @params: Scan parameters
+	 * @long_interval: interval between cycles after short intervals end
+	 * @short_interval: interval between initial short scan cycles
+	 * @num_short_intervals: number of interval short scan intervals
+	 *
+	 * Returns: 0 on success, -1 on failure
+	 *
+	 * This operation should be used for scheduled scan offload to
+	 * the hardware.  Every time scan results are available, the
+	 * driver should report scan results event for wpa_supplicant
+	 * which will eventually request the results with
+	 * wpa_driver_get_scan_results2().  This operation is optional
+	 * and if not provided or if it returns -1, we fall back to
+	 * normal host-scheduled scans.
+	 */
+	int (*sched_scan)(void *priv, struct wpa_driver_scan_params *params,
+			  u32 long_interval, u32 short_interval,
+			  u8 num_short_intervals);
+
+	/**
+	 * stop_sched_scan - Request the driver to stop a scheduled scan
+	 * @priv: private driver interface data
+	 *
+	 * Returns: 0 on success, -1 on failure
+	 *
+	 * This should cause the scheduled scan to be stopped and
+	 * results should stop being sent.  Must be supported if
+	 * sched_scan is supported.
+	 */
+	int (*stop_sched_scan)(void *priv);
+
+	/**
 	 * authenticate - Request driver to authenticate
 	 * @priv: private driver interface data
 	 * @params: authentication parameters
@@ -2034,6 +2079,9 @@
 	 */
 	int (*cancel_remain_on_channel)(void *priv);
 
+	int (*set_priority)(void *priv);
+	int (*cancel_priority)(void *priv);
+
 	/**
 	 * probe_req_report - Request Probe Request frames to be indicated
 	 * @priv: Private driver interface data
@@ -2126,6 +2174,19 @@
 	int (*shared_freq)(void *priv);
 
 	/**
+	 * shared_ap_freq - get operating frequency of shared AP interfaces(s)
+	 * @priv: Private driver interface data
+	 * @info: Shared AP channel info
+	 * Returns: 1 if shared AP was found, 0 if no shared AP is in operation
+	 * or -1 on failure
+	 *
+	 * This function is very similar to shared_freq() for AP interfaces,
+	 * but can also be used to detect APs operating within a different
+	 * instance of hostapd/wpa_supplicant.
+	 */
+	int (*shared_ap_freq)(void *priv, struct wpa_channel_info *info);
+
+	/**
 	 * get_noa - Get current Notice of Absence attribute payload
 	 * @priv: Private driver interface data
 	 * @buf: Buffer for returning NoA
@@ -2537,35 +2598,6 @@
 	int (*add_sta_node)(void *priv, const u8 *addr, u16 auth_alg);
 
 	/**
-	 * sched_scan - Request the driver to initiate scheduled scan
-	 * @priv: Private driver interface data
-	 * @params: Scan parameters
-	 * @interval: Interval between scan cycles in milliseconds
-	 * Returns: 0 on success, -1 on failure
-	 *
-	 * This operation should be used for scheduled scan offload to
-	 * the hardware. Every time scan results are available, the
-	 * driver should report scan results event for wpa_supplicant
-	 * which will eventually request the results with
-	 * wpa_driver_get_scan_results2(). This operation is optional
-	 * and if not provided or if it returns -1, we fall back to
-	 * normal host-scheduled scans.
-	 */
-	int (*sched_scan)(void *priv, struct wpa_driver_scan_params *params,
-			  u32 interval);
-
-	/**
-	 * stop_sched_scan - Request the driver to stop a scheduled scan
-	 * @priv: Private driver interface data
-	 * Returns: 0 on success, -1 on failure
-	 *
-	 * This should cause the scheduled scan to be stopped and
-	 * results should stop being sent. Must be supported if
-	 * sched_scan is supported.
-	 */
-	int (*stop_sched_scan)(void *priv);
-
-	/**
 	 * poll_client - Probe (null data or such) the given station
 	 * @priv: Private driver interface data
 	 * @own_addr: MAC address of sending interface
@@ -2602,6 +2634,28 @@
 	 * avoid frequency conflict in single channel concurrency.
 	 */
 	int (*switch_channel)(void *priv, unsigned int freq);
+
+	/**
+	 * driver_cmd - execute driver-specific command
+	 * @priv: private driver interface data
+	 * @cmd: command to execute
+	 * @buf: return buffer
+	 * @buf_len: buffer length
+	 *
+	 * Returns: 0 on success, -1 on failure
+	 */
+	 int (*driver_cmd)(void *priv, char *cmd, char *buf, size_t buf_len);
+
+	/**
+	 * stop_ap - Removes beacon from AP
+	 * @priv: Private driver interface data
+	 * Returns: 0 on success, -1 on failure (or if not supported)
+	 *
+	 * This optional function can be used to disable AP mode related
+	 * configuration. Unlike deinit_ap, it does not change to station
+	 * mode.
+	 */
+	int (*stop_ap)(void *priv);
 };
 
 
@@ -3046,7 +3100,12 @@
 	 *
 	 * This event can be used to request a WNM operation to be performed.
 	 */
-	EVENT_WNM
+	EVENT_WNM,
+
+	EVENT_START_ROAMING,
+
+	EVENT_SMART_CONFIG_SYNC,
+	EVENT_SMART_CONFIG_DECODE,
 };
 
 
@@ -3443,6 +3502,7 @@
 	/**
 	 * struct scan_info - Optional data for EVENT_SCAN_RESULTS events
 	 * @aborted: Whether the scan was aborted
+	 * @sched_scan: Whether the scan results are from the sched scan
 	 * @freqs: Scanned frequencies in MHz (%NULL = all channels scanned)
 	 * @num_freqs: Number of entries in freqs array
 	 * @ssids: Scanned SSIDs (%NULL or zero-length SSID indicates wildcard
@@ -3451,6 +3511,7 @@
 	 */
 	struct scan_info {
 		int aborted;
+		int sched_scan;
 		const int *freqs;
 		size_t num_freqs;
 		struct wpa_driver_scan_ssid ssids[WPAS_MAX_SCAN_SSIDS];
@@ -3671,6 +3732,18 @@
 		int ht_enabled;
 		int ch_offset;
 	} ch_switch;
+
+	struct smart_config_sync {
+		u32 freq;
+	} smart_config_sync;
+
+	struct smart_config_decode {
+		u8 *ssid;
+		u8 ssid_len;
+
+		u8 *psk;
+		u8 psk_len;
+	} smart_config_decode;
 };
 
 /**
diff -Nur hostapd-2.0/src/drivers/driver_nl80211.c hostapd-2.0-TI/src/drivers/driver_nl80211.c
--- hostapd-2.0/src/drivers/driver_nl80211.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/drivers/driver_nl80211.c	2014-04-18 15:12:16.000000000 +0800
@@ -24,6 +24,7 @@
 #include <linux/filter.h>
 #include <linux/errqueue.h>
 #include "nl80211_copy.h"
+#include "testmode_copy.h"
 
 #include "common.h"
 #include "eloop.h"
@@ -60,12 +61,6 @@
 
 #ifdef ANDROID
 #include "android_drv.h"
-
-/* system/core/libnl_2 in AOSP does not include nla_put_u32() */
-int nla_put_u32(struct nl_msg *msg, int attrtype, uint32_t value)
-{
-	return nla_put(msg, attrtype, sizeof(uint32_t), &value);
-}
 #endif /* ANDROID */
 #ifdef CONFIG_LIBNL20
 /* libnl 2.0 compatibility code */
@@ -170,6 +165,10 @@
 	int ioctl_sock; /* socket for ioctl() use */
 
 	struct nl_handle *nl_event;
+#ifdef ANDROID
+	int wowlan_triggers;
+	int wowlan_enabled;
+#endif
 };
 
 struct nl80211_wiphy_data {
@@ -201,12 +200,15 @@
 
 	int freq;
 
-	void *ctx;
 	struct nl_handle *nl_preq, *nl_mgmt;
 	struct nl_cb *nl_cb;
 
 	struct nl80211_wiphy_data *wiphy_data;
 	struct dl_list wiphy_list;
+
+#ifdef ANDROID
+	int rx_filter_idx;
+#endif
 };
 
 struct wpa_driver_nl80211_data {
@@ -244,6 +246,7 @@
 
 	unsigned int disabled_11b_rates:1;
 	unsigned int pending_remain_on_chan:1;
+	unsigned int pending_priority:1;
 	unsigned int in_interface_list:1;
 	unsigned int device_ap_sme:1;
 	unsigned int poll_command_supported:1;
@@ -312,6 +315,10 @@
 static int android_pno_start(struct i802_bss *bss,
 			     struct wpa_driver_scan_params *params);
 static int android_pno_stop(struct i802_bss *bss);
+static int nl80211_register_rx_filter(struct i802_bss *bss, char *name,
+				      u8 *pattern, int len, u8 *mask,
+				      u8 action);
+static int nl80211_unregister_rx_filter(struct i802_bss *bss, int filter_idx);
 #endif /* ANDROID */
 
 #ifdef HOSTAPD
@@ -1530,7 +1537,7 @@
 }
 
 
-static void mlme_event_michael_mic_failure(struct i802_bss *bss,
+static void mlme_event_michael_mic_failure(struct wpa_driver_nl80211_data *drv,
 					   struct nlattr *tb[])
 {
 	union wpa_event_data data;
@@ -1562,7 +1569,7 @@
 		wpa_printf(MSG_DEBUG, "nl80211: Key Id %d", key_id);
 	}
 
-	wpa_supplicant_event(bss->ctx, EVENT_MICHAEL_MIC_FAILURE, &data);
+	wpa_supplicant_event(drv->ctx, EVENT_MICHAEL_MIC_FAILURE, &data);
 }
 
 
@@ -1632,7 +1639,7 @@
 
 
 static void send_scan_event(struct wpa_driver_nl80211_data *drv, int aborted,
-			    struct nlattr *tb[])
+			    int sched_scan_res, struct nlattr *tb[])
 {
 	union wpa_event_data event;
 	struct nlattr *nl;
@@ -1676,6 +1683,7 @@
 		info->freqs = freqs;
 		info->num_freqs = num_freqs;
 	}
+	info->sched_scan = sched_scan_res;
 	wpa_supplicant_event(drv->ctx, EVENT_SCAN_RESULTS, &event);
 }
 
@@ -1938,6 +1946,10 @@
 		wpa_printf(MSG_DEBUG, "nl80211: Connection quality monitor "
 			   "event: RSSI low");
 		ed.signal_change.above_threshold = 0;
+	} else if (event == NL80211_CQM_RSSI_BEACON_LOSS_EVENT) {
+		wpa_printf(MSG_DEBUG, "nl80211: Connection quality monitor "
+			   "event: beacon loss!");
+		wpa_supplicant_event(drv->ctx, EVENT_START_ROAMING, &ed);
 	} else
 		return;
 
@@ -2150,6 +2162,85 @@
 	wpa_supplicant_event(drv->ctx, EVENT_TDLS, &data);
 }
 
+static void nl80211_stop_ap(struct wpa_driver_nl80211_data *drv,
+			    struct nlattr **tb)
+{
+	wpa_supplicant_event(drv->ctx, EVENT_INTERFACE_UNAVAILABLE, NULL);
+}
+
+static void
+nl80211_testmode_sc_sync_event(struct wpa_driver_nl80211_data *drv,
+			       struct nlattr **testmode)
+{
+	union wpa_event_data data;
+	u32 freq;
+
+	wpa_printf(MSG_DEBUG, "nl80211: testmode sc sync event");
+
+	if (!testmode[WL1271_TM_ATTR_FREQ])
+		return;
+
+	freq = nla_get_u32(testmode[WL1271_TM_ATTR_FREQ]);
+	wpa_printf(MSG_DEBUG, "found freq=%d", freq);
+
+	os_memset(&data, 0, sizeof(data));
+	data.smart_config_sync.freq = freq;
+	wpa_supplicant_event(drv->ctx, EVENT_SMART_CONFIG_SYNC, &data);
+}
+
+static void
+nl80211_testmode_sc_decode_event(struct wpa_driver_nl80211_data *drv,
+				 struct nlattr **testmode)
+{
+	union wpa_event_data data = {};
+	struct smart_config_decode *sc_data = &data.smart_config_decode;
+	wpa_printf(MSG_DEBUG, "nl80211: testmode sc decode event");
+
+	if (!testmode[WL1271_TM_ATTR_SSID])
+		return;
+
+	sc_data->ssid = nla_data(testmode[WL1271_TM_ATTR_SSID]);
+	sc_data->ssid_len = nla_len(testmode[WL1271_TM_ATTR_SSID]);
+
+	if (testmode[WL1271_TM_ATTR_PSK]) {
+		sc_data->psk = nla_data(testmode[WL1271_TM_ATTR_PSK]);
+		sc_data->psk_len = nla_len(testmode[WL1271_TM_ATTR_PSK]);
+	}
+
+	wpa_supplicant_event(drv->ctx, EVENT_SMART_CONFIG_DECODE, &data);
+}
+
+static void nl80211_testmode_event(struct wpa_driver_nl80211_data *drv,
+				       struct nlattr **tb)
+{
+	struct nlattr *testmode[WL1271_TM_ATTR_MAX];
+	u8 testmode_event;
+
+	wpa_printf(MSG_DEBUG, "nl80211: testmode event");
+
+	if (!tb[NL80211_ATTR_TESTDATA])
+		return;
+
+	if (nla_parse_nested(testmode, WL1271_TM_ATTR_MAX, tb[NL80211_ATTR_TESTDATA],
+			     NULL))
+		return;
+
+	if (!testmode[WL1271_TM_ATTR_SMART_CONFIG_EVENT])
+		return;
+
+	testmode_event = nla_get_u8(testmode[WL1271_TM_ATTR_SMART_CONFIG_EVENT]);
+	switch (testmode_event) {
+	case WLCORE_TM_SC_EVENT_SYNC:
+		nl80211_testmode_sc_sync_event(drv, testmode);
+		break;
+	case WLCORE_TM_SC_EVENT_DECODE:
+		nl80211_testmode_sc_decode_event(drv, testmode);
+		break;
+	default:
+		wpa_printf(MSG_DEBUG, "ERROR - invalid testmode smart config event");
+	}
+}
+
 
 static void nl80211_spurious_frame(struct i802_bss *bss, struct nlattr **tb,
 				   int wds)
@@ -2169,11 +2260,9 @@
 }
 
 
-static void do_process_drv_event(struct i802_bss *bss, int cmd,
-				 struct nlattr **tb)
+static void do_process_drv_event(struct wpa_driver_nl80211_data *drv,
+				 int cmd, struct nlattr **tb)
 {
-	struct wpa_driver_nl80211_data *drv = bss->drv;
-
 	if (drv->ap_scan_as_station != NL80211_IFTYPE_UNSPECIFIED &&
 	    (cmd == NL80211_CMD_NEW_SCAN_RESULTS ||
 	     cmd == NL80211_CMD_SCAN_ABORTED)) {
@@ -2198,12 +2287,12 @@
 		drv->scan_complete_events = 1;
 		eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout, drv,
 				     drv->ctx);
-		send_scan_event(drv, 0, tb);
+		send_scan_event(drv, 0, 0, tb);
 		break;
 	case NL80211_CMD_SCHED_SCAN_RESULTS:
 		wpa_printf(MSG_DEBUG,
 			   "nl80211: New sched scan results available");
-		send_scan_event(drv, 0, tb);
+		send_scan_event(drv, 0, 1, tb);
 		break;
 	case NL80211_CMD_SCAN_ABORTED:
 		wpa_printf(MSG_DEBUG, "nl80211: Scan aborted");
@@ -2213,7 +2302,7 @@
 		 */
 		eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout, drv,
 				     drv->ctx);
-		send_scan_event(drv, 1, tb);
+		send_scan_event(drv, 1, 0, tb);
 		break;
 	case NL80211_CMD_AUTHENTICATE:
 	case NL80211_CMD_ASSOCIATE:
@@ -2246,7 +2335,7 @@
 				      tb[NL80211_ATTR_DISCONNECTED_BY_AP]);
 		break;
 	case NL80211_CMD_MICHAEL_MIC_FAILURE:
-		mlme_event_michael_mic_failure(bss, tb);
+		mlme_event_michael_mic_failure(drv, tb);
 		break;
 	case NL80211_CMD_JOIN_IBSS:
 		mlme_event_join_ibss(drv, tb);
@@ -2288,6 +2377,15 @@
 	case NL80211_CMD_TDLS_OPER:
 		nl80211_tdls_oper_event(drv, tb);
 		break;
+	case NL80211_CMD_TESTMODE:
+		wpa_printf(MSG_DEBUG, "TESTMODE event!");
+		nl80211_testmode_event(drv, tb);
+		break;
+	case NL80211_CMD_STOP_AP:
+		nl80211_stop_ap(drv, tb);
+		wpa_supplicant_event(drv->ctx, EVENT_INTERFACE_DISABLED, NULL);
+		wpa_supplicant_event(drv->ctx, EVENT_INTERFACE_ENABLED, NULL);
+		break;
 	default:
 		wpa_printf(MSG_DEBUG, "nl80211: Ignored unknown event "
 			   "(cmd=%d)", cmd);
@@ -2301,25 +2399,21 @@
 	struct wpa_driver_nl80211_data *drv = arg;
 	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
 	struct nlattr *tb[NL80211_ATTR_MAX + 1];
-	struct i802_bss *bss;
-	int ifidx = -1;
 
 	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
 		  genlmsg_attrlen(gnlh, 0), NULL);
 
-	if (tb[NL80211_ATTR_IFINDEX])
-		ifidx = nla_get_u32(tb[NL80211_ATTR_IFINDEX]);
-
-	for (bss = &drv->first_bss; bss; bss = bss->next) {
-		if (ifidx == -1 || ifidx == bss->ifindex) {
-			do_process_drv_event(bss, gnlh->cmd, tb);
+	if (tb[NL80211_ATTR_IFINDEX]) {
+		int ifindex = nla_get_u32(tb[NL80211_ATTR_IFINDEX]);
+		if (ifindex != drv->ifindex && !have_ifidx(drv, ifindex)) {
+			wpa_printf(MSG_DEBUG, "nl80211: Ignored event (cmd=%d)"
+				   " for foreign interface (ifindex %d)",
+				   gnlh->cmd, ifindex);
 			return NL_SKIP;
 		}
 	}
 
-	wpa_printf(MSG_DEBUG, "nl80211: Ignored event (cmd=%d) for foreign "
-		   "interface (ifindex %d)", gnlh->cmd, ifidx);
-
+	do_process_drv_event(drv, gnlh->cmd, tb);
 	return NL_SKIP;
 }
 
@@ -2331,7 +2425,6 @@
 	struct nlattr *tb[NL80211_ATTR_MAX + 1];
 	struct wpa_driver_nl80211_data *drv, *tmp;
 	int ifidx = -1;
-	struct i802_bss *bss;
 
 	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
 		  genlmsg_attrlen(gnlh, 0), NULL);
@@ -2341,12 +2434,9 @@
 
 	dl_list_for_each_safe(drv, tmp, &global->interfaces,
 			      struct wpa_driver_nl80211_data, list) {
-		for (bss = &drv->first_bss; bss; bss = bss->next) {
-			if (ifidx == -1 || ifidx == bss->ifindex) {
-				do_process_drv_event(bss, gnlh->cmd, tb);
-				return NL_SKIP;
-			}
-		}
+		if (ifidx == -1 || ifidx == drv->ifindex ||
+		    have_ifidx(drv, ifidx))
+			do_process_drv_event(drv, gnlh->cmd, tb);
 	}
 
 	return NL_SKIP;
@@ -2398,6 +2488,44 @@
 }
 
 
+static int get_country_handler(struct nl_msg *msg, void *arg)
+{
+	char * alpha2 = (char *) arg;
+	struct nlattr *tb_msg[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+
+	nla_parse(tb_msg, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+	if (!tb_msg[NL80211_ATTR_REG_ALPHA2]) {
+		wpa_printf(MSG_DEBUG, "nl80211: No country information "
+			   "available");
+		return NL_SKIP;
+	}
+	os_memcpy(alpha2, nla_data(tb_msg[NL80211_ATTR_REG_ALPHA2]), 3);
+	return NL_SKIP;
+}
+
+static int nl80211_get_country(struct wpa_driver_nl80211_data *drv,
+				char *alpha2)
+{
+	struct nl_msg *msg;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	nl80211_cmd(drv, msg, 0, NL80211_CMD_GET_REG);
+	return send_and_recv_msgs(drv, msg, get_country_handler, alpha2);
+}
+
+static int wpa_driver_nl80211_get_country(void *priv, char *alpha2_arg)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+
+	return nl80211_get_country(drv, alpha2_arg);
+}
+
 /**
  * wpa_driver_nl80211_set_country - ask nl80211 to set the regulatory domain
  * @priv: driver_nl80211 private data
@@ -2412,7 +2540,10 @@
 	struct i802_bss *bss = priv;
 	struct wpa_driver_nl80211_data *drv = bss->drv;
 	char alpha2[3];
+	char alpha2_res[3];
 	struct nl_msg *msg;
+	int count;
+	int ret;
 
 	msg = nlmsg_alloc();
 	if (!msg)
@@ -2427,7 +2558,24 @@
 	NLA_PUT_STRING(msg, NL80211_ATTR_REG_ALPHA2, alpha2);
 	if (send_and_recv_msgs(drv, msg, NULL, NULL))
 		return -EINVAL;
-	return 0;
+
+	/* Validate coutry setting and retry up to 3 times if not match */
+	for (count = 0; count < 3; count++) {
+		os_memset(alpha2_res, 0, sizeof(alpha2));
+		ret = nl80211_get_country(drv, alpha2_res);
+		if (ret)
+			return ret;
+		if (os_strncmp(alpha2, alpha2_res, 2)) {
+			wpa_printf(MSG_DEBUG, "wpa_driver_nl80211_set_country:"
+					"retry country set after delay");
+			os_sleep(1, 0);
+		} else {
+			/* contry set is completed */
+			return 0;
+		}
+	}
+	wpa_printf(MSG_ERROR, "wpa_driver_nl80211_set_country: failed");
+	return -EINVAL;
 nla_put_failure:
 	nlmsg_free(msg);
 	return -EINVAL;
@@ -2619,6 +2767,12 @@
 	if (tb[NL80211_ATTR_SUPPORT_AP_UAPSD])
 		capa->flags |= WPA_DRIVER_FLAGS_AP_UAPSD;
 
+	if (tb[NL80211_ATTR_FEATURE_FLAGS]) {
+		int features = nla_get_u32(tb[NL80211_ATTR_FEATURE_FLAGS]);
+		if (features & NL80211_FEATURE_SCHED_SCAN_INTERVALS)
+			capa->sched_scan_intervals_supported = 1;
+	}
+
 	if (tb[NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION])
 		capa->max_remain_on_chan =
 			nla_get_u32(tb[NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION]);
@@ -2881,6 +3035,16 @@
 		/* Continue without regulatory events */
 	}
 
+	ret = nl_get_multicast_id(global, "nl80211", "testmode");
+	if (ret >= 0)
+		ret = nl_socket_add_membership(global->nl_event, ret);
+	if (ret < 0) {
+		wpa_printf(MSG_DEBUG, "nl80211: Could not add multicast "
+			   "membership for testmode events: %d (%s)",
+			   ret, strerror(-ret));
+		goto err;
+	}
+
 	nl_cb_set(global->nl_cb, NL_CB_SEQ_CHECK, NL_CB_CUSTOM,
 		  no_seq_check, NULL);
 	nl_cb_set(global->nl_cb, NL_CB_VALID, NL_CB_CUSTOM,
@@ -3080,9 +3244,10 @@
 	drv->ctx = ctx;
 	bss = &drv->first_bss;
 	bss->drv = drv;
-	bss->ctx = ctx;
-
 	os_strlcpy(bss->ifname, ifname, sizeof(bss->ifname));
+#ifdef ANDROID
+	bss->rx_filter_idx = -1;
+#endif
 	drv->monitor_ifidx = -1;
 	drv->monitor_sock = -1;
 	drv->eapol_tx_sock = -1;
@@ -3279,9 +3444,6 @@
 	/* WNM - BSS Transition Management Request */
 	if (nl80211_register_action_frame(bss, (u8 *) "\x0a\x07", 2) < 0)
 		return -1;
-	/* WNM-Sleep Mode Response */
-	if (nl80211_register_action_frame(bss, (u8 *) "\x0a\x11", 2) < 0)
-		return -1;
 
 	return 0;
 }
@@ -3762,12 +3924,16 @@
  * wpa_driver_nl80211_sched_scan - Initiate a scheduled scan
  * @priv: Pointer to private driver data from wpa_driver_nl80211_init()
  * @params: Scan parameters
- * @interval: Interval between scan cycles in milliseconds
+ * @long_interval: interval between scan cycles after end of short cycles
+ * @short_interval: interval between initial short scan cycles
+ * @num_short_intervals: number of interval short scan intervals
  * Returns: 0 on success, -1 on failure or if not supported
  */
 static int wpa_driver_nl80211_sched_scan(void *priv,
 					 struct wpa_driver_scan_params *params,
-					 u32 interval)
+					 u32 long_interval,
+					 u32 short_interval,
+					 u8 num_short_intervals)
 {
 	struct i802_bss *bss = priv;
 	struct wpa_driver_nl80211_data *drv = bss->drv;
@@ -3786,7 +3952,17 @@
 	if (!msg)
 		goto nla_put_failure;
 
-	NLA_PUT_U32(msg, NL80211_ATTR_SCHED_SCAN_INTERVAL, interval);
+	NLA_PUT_U32(msg, NL80211_ATTR_SCHED_SCAN_INTERVAL, long_interval);
+
+	if (drv->capa.sched_scan_intervals_supported) {
+		NLA_PUT_U32(msg,
+			    NL80211_ATTR_SCHED_SCAN_SHORT_INTERVAL,
+			    short_interval);
+
+		NLA_PUT_U8(msg,
+			   NL80211_ATTR_SCHED_SCAN_NUM_SHORT_INTERVALS,
+			   num_short_intervals);
+	}
 
 	if ((drv->num_filter_ssids &&
 	    (int) drv->num_filter_ssids <= drv->capa.max_match_sets) ||
@@ -3844,8 +4020,9 @@
 		goto nla_put_failure;
 	}
 
-	wpa_printf(MSG_DEBUG, "nl80211: Sched scan requested (ret=%d) - "
-		   "scan interval %d msec", ret, interval);
+	wpa_printf(MSG_DEBUG, "nl80211: Sched scan requested (ret=%d) "
+		   "intervals: short=%d ms long=%d ms num_short_intervals=%d"
+		   , ret, short_interval, long_interval, num_short_intervals);
 
 nla_put_failure:
 	nlmsg_free(match_set_ssid);
@@ -4987,35 +5164,19 @@
 				/* crude heuristic */
 				if (mode->channels[idx].freq < 4000)
 					mode->mode = HOSTAPD_MODE_IEEE80211B;
-				else if (mode->channels[idx].freq > 50000)
-					mode->mode = HOSTAPD_MODE_IEEE80211AD;
 				else
 					mode->mode = HOSTAPD_MODE_IEEE80211A;
 				mode_is_set = 1;
 			}
 
-			switch (mode->mode) {
-			case HOSTAPD_MODE_IEEE80211AD:
-				mode->channels[idx].chan =
-					(mode->channels[idx].freq - 56160) /
-					2160;
-				break;
-			case HOSTAPD_MODE_IEEE80211A:
-				mode->channels[idx].chan =
-					mode->channels[idx].freq / 5 - 1000;
-				break;
-			case HOSTAPD_MODE_IEEE80211B:
-			case HOSTAPD_MODE_IEEE80211G:
+			/* crude heuristic */
+			if (mode->channels[idx].freq < 4000)
 				if (mode->channels[idx].freq == 2484)
 					mode->channels[idx].chan = 14;
 				else
-					mode->channels[idx].chan =
-						(mode->channels[idx].freq -
-						 2407) / 5;
-				break;
-			default:
-				break;
-			}
+					mode->channels[idx].chan = (mode->channels[idx].freq - 2407) / 5;
+			else
+				mode->channels[idx].chan = mode->channels[idx].freq/5 - 1000;
 
 			if (tb_freq[NL80211_FREQUENCY_ATTR_DISABLED])
 				mode->channels[idx].flag |=
@@ -5795,7 +5956,7 @@
 		NLA_PUT_U8(wme, NL80211_STA_WME_UAPSD_QUEUES,
 				params->qosinfo & WMM_QOSINFO_STA_AC_MASK);
 		NLA_PUT_U8(wme, NL80211_STA_WME_MAX_SP,
-				(params->qosinfo > WMM_QOSINFO_STA_SP_SHIFT) &
+				(params->qosinfo >> WMM_QOSINFO_STA_SP_SHIFT) &
 				WMM_QOSINFO_STA_SP_MASK);
 		if (nla_put_nested(msg, NL80211_ATTR_STA_WME, wme) < 0)
 			goto nla_put_failure;
@@ -6604,7 +6765,7 @@
 static int wpa_driver_nl80211_ap(struct wpa_driver_nl80211_data *drv,
 				 struct wpa_driver_associate_params *params)
 {
-	enum nl80211_iftype nlmode, old_mode;
+	enum nl80211_iftype nlmode;
 
 	if (params->p2p) {
 		wpa_printf(MSG_DEBUG, "nl80211: Setup AP operations for P2P "
@@ -6613,15 +6774,8 @@
 	} else
 		nlmode = NL80211_IFTYPE_AP;
 
-	old_mode = drv->nlmode;
-	if (wpa_driver_nl80211_set_mode(&drv->first_bss, nlmode)) {
-		nl80211_remove_monitor_interface(drv);
-		return -1;
-	}
-
-	if (wpa_driver_nl80211_set_freq(&drv->first_bss, params->freq, 0, 0)) {
-		if (old_mode != nlmode)
-			wpa_driver_nl80211_set_mode(&drv->first_bss, old_mode);
+	if (wpa_driver_nl80211_set_mode(&drv->first_bss, nlmode) ||
+	    wpa_driver_nl80211_set_freq(&drv->first_bss, params->freq, 0, 0)) {
 		nl80211_remove_monitor_interface(drv);
 		return -1;
 	}
@@ -7303,6 +7457,56 @@
 	return -ENOBUFS;
 }
 
+static int wpa_driver_nl80211_testmode_cmd(struct wpa_driver_nl80211_data *drv,
+					   struct nl_msg *nested)
+{
+	struct nl_msg *msg;
+	int ret;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	nl80211_cmd(drv, msg, 0, NL80211_CMD_TESTMODE);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+
+	/* note: we only "put" nested, not consume it */
+	ret = nla_put_nested(msg, NL80211_ATTR_TESTDATA, nested);
+	if (ret < 0)
+		goto nla_put_failure;
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	if (ret == -ENOENT)
+		return 0;
+	return ret;
+ nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+static int wpa_driver_nl80211_testmode_empty_cmd(
+					struct wpa_driver_nl80211_data *drv,
+					int cmd)
+{
+	struct nl_msg *msg;
+	int ret;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, cmd);
+
+	ret = wpa_driver_nl80211_testmode_cmd(drv, msg);
+
+	/* we still need to free our nested message */
+	nlmsg_free(msg);
+	return ret;
+nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
 
 /* Set kernel driver on given frequency (MHz) */
 static int i802_set_freq(void *priv, struct hostapd_freq_params *freq)
@@ -8062,6 +8266,10 @@
 	struct i802_bss *bss = priv;
 	struct wpa_driver_nl80211_data *drv = bss->drv;
 	int ifidx;
+#ifdef ANDROID
+	int filter_idx;
+#endif
+
 #ifdef HOSTAPD
 	struct i802_bss *new_bss = NULL;
 
@@ -8122,6 +8330,26 @@
 	}
 #endif /* CONFIG_P2P */
 
+#if defined(ANDROID) && !defined(HOSTAPD)
+	static u8 eth_addr_mask[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+
+	filter_idx = nl80211_register_rx_filter(bss, "unicast",
+					if_addr, ETH_ALEN,
+					eth_addr_mask,
+					NL80211_WOWLAN_ACTION_ALLOW);
+	if (filter_idx < 0) {
+		nl80211_remove_iface(drv, ifidx);
+		return -1;
+	}
+
+	if (bss->rx_filter_idx != -1)
+		wpa_printf(MSG_WARNING, "nl80211: Rx filter is already "
+			   "configured when it shouldn't be (idx=%d)",
+			   bss->rx_filter_idx);
+
+	bss->rx_filter_idx = filter_idx;
+#endif /* ANDROID && !HOSTAPD */
+
 #ifdef HOSTAPD
 	if (bridge &&
 	    i802_check_bridge(drv, new_bss, bridge, ifname) < 0) {
@@ -8145,7 +8373,6 @@
 		new_bss->drv = drv;
 		new_bss->next = drv->first_bss.next;
 		new_bss->freq = drv->first_bss.freq;
-		new_bss->ctx = bss_ctx;
 		drv->first_bss.next = new_bss;
 		if (drv_priv)
 			*drv_priv = new_bss;
@@ -8179,6 +8406,10 @@
 
 	nl80211_remove_iface(drv, ifindex);
 
+#ifdef ANDROID
+	nl80211_unregister_rx_filter(bss, bss->rx_filter_idx);
+#endif
+
 #ifdef HOSTAPD
 	if (type != WPA_IF_AP_BSS)
 		return 0;
@@ -8436,6 +8667,71 @@
 	return -1;
 }
 
+static int wpa_driver_nl80211_set_priority(void *priv)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	int ret;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	nl80211_cmd(drv, msg, 0, NL80211_CMD_SET_PRIORITY);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret == 0) {
+		wpa_printf(MSG_DEBUG, "nl80211: set priority");
+		drv->pending_priority = 1;
+		return 0;
+	}
+	wpa_printf(MSG_DEBUG, "nl80211: Failed to set priority: %d (%s)",
+		   ret, strerror(-ret));
+nla_put_failure:
+	nlmsg_free(msg);
+	return -1;
+}
+
+static int wpa_driver_nl80211_cancel_priority(void *priv)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	int ret;
+
+	if (!drv->pending_priority) {
+		wpa_printf(MSG_DEBUG, "nl80211: No pending priority "
+			   "to cancel");
+		return -1;
+	}
+
+	wpa_printf(MSG_DEBUG, "nl80211: Cancel priority");
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	nl80211_cmd(drv, msg, 0, NL80211_CMD_CANCEL_PRIORITY);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret == 0) {
+		drv->pending_remain_on_chan = 0;
+		return 0;
+	}
+	wpa_printf(MSG_DEBUG, "nl80211: Failed to cancel priority: %d (%s)",
+		   ret, strerror(-ret));
+nla_put_failure:
+	nlmsg_free(msg);
+	return -1;
+}
+
 
 static int wpa_driver_nl80211_probe_req_report(void *priv, int report)
 {
@@ -8553,6 +8849,18 @@
 }
 
 
+static int wpa_driver_nl80211_stop_ap(void *priv)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	if (!is_ap_interface(drv->nlmode))
+		return -1;
+	wpa_driver_nl80211_del_beacon(drv);
+	bss->beacon_set = 0;
+	return 0;
+}
+
+
 static int wpa_driver_nl80211_deinit_p2p_cli(void *priv)
 {
 	struct i802_bss *bss = priv;
@@ -8691,7 +8999,11 @@
 			 struct wpa_driver_nl80211_data, list) {
 		if (drv == driver ||
 		    os_strcmp(drv->phyname, driver->phyname) != 0 ||
+#ifdef ANDROID_P2P
+		    (!driver->associated && !is_ap_interface(driver->nlmode)))
+#else
 		    !driver->associated)
+#endif
 			continue;
 
 		wpa_printf(MSG_DEBUG, "nl80211: Found a match for PHY %s - %s "
@@ -8714,20 +9026,104 @@
 }
 
 
-static int nl80211_send_frame(void *priv, const u8 *data, size_t data_len,
-			      int encrypt)
-{
-	struct i802_bss *bss = priv;
-	return wpa_driver_nl80211_send_frame(bss, data, data_len, encrypt, 0,
-					     0, 0, 0, 0);
-}
+struct ap_freq_data {
+	u32 wiphy_idx; /* own idx */
+	struct wpa_channel_info *info;
+};
 
 
-static int nl80211_set_param(void *priv, const char *param)
+static int ap_freq_info_handler(struct nl_msg *msg, void *arg)
 {
-	wpa_printf(MSG_DEBUG, "nl80211: driver param='%s'", param);
-	if (param == NULL)
-		return 0;
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct ap_freq_data *data = arg;
+	enum nl80211_iftype iftype;
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb[NL80211_ATTR_WIPHY] || !tb[NL80211_ATTR_IFTYPE] ||
+	    !tb[NL80211_ATTR_WIPHY_FREQ] ||
+	    !tb[NL80211_ATTR_WIPHY_CHANNEL_TYPE])
+		goto out;
+
+	/* different phy */
+	if (data->wiphy_idx != nla_get_u32(tb[NL80211_ATTR_WIPHY]))
+		goto out;
+
+	/* we only care about APs */
+	iftype = nla_get_u32(tb[NL80211_ATTR_IFTYPE]);
+	if (iftype != NL80211_IFTYPE_AP && iftype != NL80211_IFTYPE_P2P_GO)
+		goto out;
+
+	data->info->frequency = nla_get_u32(tb[NL80211_ATTR_WIPHY_FREQ]);
+
+	switch(nla_get_u32(tb[NL80211_ATTR_WIPHY_CHANNEL_TYPE])) {
+	case NL80211_CHAN_HT40MINUS:
+		data->info->sec_channel_offset = -1;
+		break;
+	case NL80211_CHAN_HT40PLUS:
+		data->info->sec_channel_offset = 1;
+		break;
+	default:
+		data->info->sec_channel_offset = 0;
+		break;
+	}
+
+	wpa_printf(MSG_DEBUG, "nl80211: Got shared AP on freq %d sec chan: %d",
+		   data->info->frequency, data->info->sec_channel_offset);
+
+out:
+	return NL_SKIP;
+}
+
+
+static int wpa_driver_nl80211_shared_ap_freq(void *priv,
+					     struct wpa_channel_info *info)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct ap_freq_data data = {
+		.info = info,
+	};
+
+	wpa_printf(MSG_DEBUG, "nl80211: Get shared AP freq for PHY %s",
+		   drv->phyname);
+
+	data.wiphy_idx = nl80211_get_wiphy_index(bss);
+	if (data.wiphy_idx == -1)
+		return -1;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	nl80211_cmd(drv, msg, NLM_F_DUMP, NL80211_CMD_GET_INTERFACE);
+
+	info->frequency = 0;
+	if (send_and_recv_msgs(drv, msg, ap_freq_info_handler, &data) != 0)
+		return -1;
+
+	wpa_printf(MSG_DEBUG, "nl80211: AP shared freq %d", info->frequency);
+	return info->frequency == 0 ? 0 : 1;
+}
+
+
+static int nl80211_send_frame(void *priv, const u8 *data, size_t data_len,
+			      int encrypt)
+{
+	struct i802_bss *bss = priv;
+	return wpa_driver_nl80211_send_frame(bss, data, data_len, encrypt, 0,
+					     0, 0, 0, 0);
+}
+
+
+static int nl80211_set_param(void *priv, const char *param)
+{
+	wpa_printf(MSG_DEBUG, "nl80211: driver param='%s'", param);
+	if (param == NULL)
+		return 0;
 
 #ifdef CONFIG_P2P
 	if (os_strstr(param, "use_p2p_group_interface=1")) {
@@ -8739,6 +9135,15 @@
 		drv->capa.flags |= WPA_DRIVER_FLAGS_P2P_CONCURRENT;
 		drv->capa.flags |= WPA_DRIVER_FLAGS_P2P_MGMT_AND_NON_P2P;
 	}
+#ifdef ANDROID_P2P
+	if(os_strstr(param, "use_multi_chan_concurrent=1")) {
+		struct i802_bss *bss = priv;
+		struct wpa_driver_nl80211_data *drv = bss->drv;
+		wpa_printf(MSG_DEBUG, "nl80211: Use Multi channel "
+			   "concurrency");
+		drv->capa.flags |= WPA_DRIVER_FLAGS_MULTI_CHANNEL_CONCURRENT;
+	}
+#endif
 #endif /* CONFIG_P2P */
 
 	return 0;
@@ -8849,6 +9254,433 @@
 	return -ENOBUFS;
 }
 
+#ifdef ANDROID
+
+#define MAX_PATTERN_SIZE        256
+#define MAX_MASK_SIZE           (MAX_PATTERN_SIZE/8)
+
+/* Describes a single RX filter configuration */
+struct rx_filter {
+	/* name - A human recongmizable name for the filter */
+	char *name;
+
+	/* get_pattern_handler - A handler which enables the user to configure
+	 * the pattern dynamically (For example filter according to the HW addr).
+	 * If NULL the static pattern configured will be used.
+	 * buf - the pattern will be copied to buf
+	 * buflen - the size of buf
+	 * arg - A generic input argumet which can be passed to the handler
+	 */
+	int (* get_pattern_handler) (u8 *buf, int buflen, void* arg);
+
+	/* pattern - A static pattern to filter
+	 * This array contains the bytes of the pattern. The mask field
+	 * indicates which bytes should be used in the filter and which
+	 * can be discarded
+	 */
+	u8 pattern[MAX_PATTERN_SIZE];
+
+	/* pattern_len - The number of bytes used in pattern */
+	u8 pattern_len;
+
+	/* mask - A bit mask indicating which bytes in pattern should be
+	 * used for filtering. Each bit here corresponds to a byte in pattern
+	 */
+	u8 mask[MAX_MASK_SIZE];
+
+	/* mask_len - The number of bytes used in mask */
+	u8 mask_len;
+
+	/* action - can be either NL80211_WOWLAN_ACTION_ALLOW or DROP.
+	 * Allow this pattern (and wakeup in case of suspend) or drop
+	 * packets containing it despite matching another wowlan pattern.
+	 */
+	u8 action;
+};
+
+static u8 *nl80211_rx_filter_get_pattern(struct rx_filter *filter, void *arg)
+{
+	if (filter->get_pattern_handler) {
+		if (filter->get_pattern_handler(filter->pattern,
+					        filter->pattern_len, arg)) {
+			return NULL;
+		}
+	}
+
+	return filter->pattern;
+}
+
+static int
+nl80211_sta_unicast_filter_get_pattern_handler(u8 *buf, int buflen, void *arg)
+{
+	int ret;
+	struct i802_bss *bss = (struct i802_bss *)arg;
+
+	ret = linux_get_ifhwaddr(bss->drv->global->ioctl_sock,
+				 "wlan0", buf);
+	if (ret) {
+		wpa_printf(MSG_ERROR, "Failed to get own HW addr (%d)", ret);
+		return -1;
+	}
+	return 0;
+}
+
+#define NUM_RX_FILTERS 15
+
+static struct rx_filter rx_filters[NUM_RX_FILTERS] = {
+	/* ID 0 */
+	{.name = "sta_unicast",
+	 .pattern = {},
+	 .pattern_len = 6,
+	 .mask = { BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5) },
+	 .mask_len = 1,
+	 .get_pattern_handler = nl80211_sta_unicast_filter_get_pattern_handler,
+	 .action = NL80211_WOWLAN_ACTION_ALLOW,
+	},
+
+	/* ID 1 */
+	{.name = "bcast",
+	 .pattern = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
+	 .pattern_len = 6,
+	 .mask = { BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5) },
+	 .mask_len = 1,
+	 .action = NL80211_WOWLAN_ACTION_ALLOW,
+	},
+
+	/* ID 2 */
+	{.name = "ipv4mc",
+	 .pattern = {0x01,0x00,0x5E},
+	 .pattern_len = 3,
+	 .mask = { BIT(0) | BIT(1) | BIT(2) },
+	 .mask_len = 1,
+	 .action = NL80211_WOWLAN_ACTION_ALLOW,
+	},
+
+	/* ID 3 */
+	{.name = "ipv6mc",
+	 .pattern = {0x33,0x33},
+	 .pattern_len = 2,
+	 .mask = { BIT(0) | BIT(1) },
+	 .mask_len = 1,
+	 .action = NL80211_WOWLAN_ACTION_ALLOW,
+	},
+
+	/* ID 4 */
+	{.name = "dhcp",
+	 .pattern = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0   , 0   ,
+		     0   , 0   , 0   , 0   , 0   , 0   , 0x45, 0   ,
+		     0   , 0   , 0   , 0   , 0   , 0   , 0   , 0x11,
+		     0   , 0   , 0   , 0   , 0   , 0   , 0   , 0   ,
+		     0   , 0   , 0   , 0   , 0x00, 0x44},
+	 .pattern_len = 38,
+	 .mask = { BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5),
+		   BIT(6),                               /* OCTET 2 */
+		   BIT(7),                               /* OCTET 3 */
+		   0,                                    /* OCTET 4 */
+		   BIT(4) | BIT(5) },                    /* OCTET 5 */
+	 .mask_len = 5,
+	 .action = NL80211_WOWLAN_ACTION_ALLOW,
+	},
+
+	/* ID 5 */
+	{.name = "arp",
+	 .pattern = {0   , 0   , 0   , 0   , 0   , 0   , 0   , 0   ,
+		     0   , 0   , 0   , 0   , 0x08, 0x06},
+	 .pattern_len = 14,
+	 .mask = { 0,                                    /* OCTET 1 */
+		   BIT(4) | BIT(5) },                    /* OCTET 2 */
+	 .mask_len = 2,
+	 .action = NL80211_WOWLAN_ACTION_ALLOW,
+	},
+
+	/* ID 6 */
+	{.name = "ssdp",
+	 .pattern = {0x01, 0x00, 0x5E, 0   , 0   , 0   , 0   , 0   ,
+		     0   , 0   , 0   , 0   , 0   , 0   , 0x45, 0   ,
+		     0   , 0   , 0   , 0   , 0   , 0   , 0   , 0x11,
+		     0   , 0   , 0   , 0   , 0   , 0   , 0xEF, 0xFF,
+		     0xFF, 0xFA, 0   , 0   , 0x07, 0x6C},
+	 .pattern_len = 38,
+	 .mask = { BIT(0) | BIT(1) | BIT(2),             /* OCTET 1 */
+		   BIT(6),                               /* OCTET 2 */
+		   BIT(7),                               /* OCTET 3 */
+		   BIT(6) | BIT(7),                      /* OCTET 4 */
+		   BIT(0) | BIT(1) | BIT(4) | BIT(5) },  /* OCTET 5 */
+	 .mask_len = 5,
+	 .action = NL80211_WOWLAN_ACTION_ALLOW,
+	},
+
+	/* This is an example of an exception pattern which matches
+	 * any ICMP packet directed at 00:11:11:11:11:11
+	 */
+
+	/* ID 7 */
+	{.name = "blacklist",
+	 .pattern = {0   , 0x11, 0x11, 0x11, 0x11, 0x11, 0   , 0   ,
+		     0   , 0   , 0   , 0   , 0   , 0   , 0x45, 0   ,
+		     0   , 0   , 0   , 0   , 0   , 0   , 0   , 0x1 },
+	 .pattern_len = 24,
+	 .mask = { BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5),
+		   BIT(6),
+		   BIT(7) },
+	 .mask_len = 3,
+	 .action = NL80211_WOWLAN_ACTION_DROP,
+	},
+
+};
+
+#define DIV_ROUND_UP(x, y) (((x) + (y - 1)) / (y))
+
+static inline int nl80211_rx_filter_configured(struct rx_filter *rx_filter)
+{
+	return (rx_filter->name != NULL);
+}
+
+static int nl80211_set_wowlan_triggers(struct i802_bss *bss, int enable)
+{
+	struct nl80211_global *global = bss->drv->global;
+	struct nl_msg *msg, *pats = NULL;
+	struct nlattr *wowtrig, *pat;
+	int i, ret = -1;
+	int filters;
+
+	global->wowlan_enabled = !!enable;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	genlmsg_put(msg, 0, 0, global->nl80211_id, 0,
+		    0, NL80211_CMD_SET_WOWLAN, 0);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->drv->first_bss.ifindex);
+	wowtrig = nla_nest_start(msg, NL80211_ATTR_WOWLAN_TRIGGERS);
+
+	if (!wowtrig) {
+		ret = -ENOBUFS;
+		goto nla_put_failure;
+	}
+
+	if (!enable) {
+		NLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_ANY);
+	} else {
+		pats = nlmsg_alloc();
+		if (!pats) {
+			ret = -ENOMEM;
+			goto nla_put_failure;
+		}
+
+		/*
+		 * In GB filters 0 and 1 are always set but in ICS they
+		 * were completely removed. Add filter 0 (unicast) by default
+		 * so unicast traffic won't be dropped in any case.
+		 */
+
+		filters = global->wowlan_triggers |= 1;
+
+		for (i = 0; i < NUM_RX_FILTERS; i++) {
+			struct rx_filter *rx_filter = &rx_filters[i];
+			int patnr = 1;
+			u8 *pattern;
+
+			if (!nl80211_rx_filter_configured(rx_filter))
+				continue;
+
+			if (!(filters & (1 << i)))
+				continue;
+
+			pattern = nl80211_rx_filter_get_pattern(rx_filter, bss);
+			if (!pattern)
+				continue;
+
+			pat = nla_nest_start(pats, patnr++);
+			NLA_PUT(pats, NL80211_WOWLAN_PKTPAT_MASK,
+				rx_filter->mask_len,
+				rx_filter->mask);
+
+			NLA_PUT(pats, NL80211_WOWLAN_PKTPAT_PATTERN,
+				rx_filter->pattern_len,
+				pattern);
+
+			NLA_PUT_U8(pats, NL80211_WOWLAN_PKTPAT_ACTION,
+				   rx_filter->action);
+
+			nla_nest_end(pats, pat);
+		}
+	}
+
+	if (pats)
+		nla_put_nested(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN, pats);
+
+	nla_nest_end(msg, wowtrig);
+
+	ret = send_and_recv_msgs(bss->drv, msg, NULL, NULL);
+
+	if (ret < 0)
+		wpa_printf(MSG_ERROR, "Failed to set WoWLAN trigger:%d\n", ret);
+
+	if (pats)
+		nlmsg_free(pats);
+
+	return 0;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return ret;
+}
+
+static int nl80211_toggle_wowlan_trigger(struct i802_bss *bss, int nr,
+					 int enabled)
+{
+	struct nl80211_global *global = bss->drv->global;
+	int prev_triggers;
+	int ret = 0;
+
+	if (nr >= NUM_RX_FILTERS) {
+		wpa_printf(MSG_ERROR, "nl80211: Invalid RX filter: %d\n", nr);
+		return -1;
+	}
+
+	prev_triggers = global->wowlan_triggers;
+
+	if (enabled)
+		global->wowlan_triggers |= 1 << nr;
+	else
+		global->wowlan_triggers &= ~(1 << nr);
+
+	if (global->wowlan_enabled)
+		ret = nl80211_set_wowlan_triggers(bss, 1);
+
+	if (ret < 0) {
+		wpa_printf(MSG_ERROR, "nl80211: Failed to set wowlan triggers "
+			   "(%d)", ret);
+		global->wowlan_triggers = prev_triggers;
+	}
+
+	return ret;
+}
+
+static int nl80211_parse_wowlan_trigger_nr(char *s)
+{
+	long i;
+	char *endp;
+
+	i = strtol(s, &endp, 10);
+
+	if(endp == s)
+		return -1;
+	return i;
+}
+
+/* Helper for nl80211_register_rx_filter. Don't call directly */
+static int nl80211_add_rx_filter(char *name, u8 *pattern, int len,
+				 u8 *mask, u8 action)
+{
+	int i, j, pos;
+
+	if (name == NULL || pattern == NULL || mask == NULL) {
+		wpa_printf(MSG_ERROR, "nl80211: Add RX filter failed: "
+			   "invalid params");
+		return -1;
+	}
+
+	if (len > MAX_PATTERN_SIZE) {
+		wpa_printf(MSG_ERROR, "nl80211: Add RX filter failed: "
+			   "Pattern too big (len=%d)", len);
+		return -1;
+	}
+
+	if (action > MAX_NL80211_WOWLAN_ACTION) {
+		wpa_printf(MSG_ERROR, "nl80211: Add RX filter failed: "
+			   "bad action (action=%d)", action);
+		return -1;
+	}
+
+	for (i = 0; i < NUM_RX_FILTERS; i++) {
+		struct rx_filter *filter = &rx_filters[i];
+
+		if (filter->name)
+			continue;
+
+		filter->name = name;
+		filter->pattern_len = len;
+		memcpy(filter->pattern, pattern, len);
+		for (j = 0; j < len; j++)
+			if (mask[j]) {
+				pos = j / 8;
+				filter->mask[pos] |= 1 << (j % 8);
+			}
+
+		filter->mask_len = DIV_ROUND_UP(len, 8);
+		filter->action = action;
+		break;
+	}
+
+	if (i == NUM_RX_FILTERS) {
+		wpa_printf(MSG_ERROR, "nl80211: Out of RX filters");
+		return -1;
+	}
+
+	return i;
+}
+
+/* Helper for nl80211_unregister_rx_filter. Don't call directly */
+static int nl80211_remove_rx_filter(int filter_idx)
+{
+	struct rx_filter *filter;
+
+	if (filter_idx < 0 || filter_idx >= NUM_RX_FILTERS) {
+		wpa_printf(MSG_ERROR, "nl80211: Failed to remove RX filter: "
+			   "bad filter (idx=%d)", filter_idx);
+		return -1;
+	}
+
+	filter = &rx_filters[filter_idx];
+	filter->name = NULL;
+	memset(filter->pattern, 0, MAX_PATTERN_SIZE);
+	memset(filter->mask, 0, MAX_MASK_SIZE);
+	filter->mask_len = 0;
+	filter->pattern_len = 0;
+	filter->action = 0;
+
+	return 0;
+}
+
+static int nl80211_register_rx_filter(struct i802_bss *bss, char *name,
+				      u8 *pattern, int len, u8 *mask, u8 action)
+{
+	int filter_idx, ret;
+
+	filter_idx = nl80211_add_rx_filter(name, pattern, len, mask, action);
+
+	if (filter_idx < 0)
+		return -1;
+
+	ret = nl80211_toggle_wowlan_trigger(bss, filter_idx, 1);
+	if (ret < 0)
+		goto fail;
+
+	return filter_idx;
+
+fail:
+	nl80211_remove_rx_filter(filter_idx);
+	return -1;
+}
+
+static int nl80211_unregister_rx_filter(struct i802_bss *bss, int filter_idx)
+{
+	int ret;
+
+	ret = nl80211_toggle_wowlan_trigger(bss, filter_idx, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = nl80211_remove_rx_filter(filter_idx);
+
+	return ret;
+}
+
+#endif /* ANDROID */
 
 static int nl80211_add_pmkid(void *priv, const u8 *bssid, const u8 *pmkid)
 {
@@ -9232,8 +10064,188 @@
 	return android_priv_cmd(bss, "PNOFORCE 0");
 }
 
+
+static int wpa_driver_nl80211_driver_cmd_android(void *priv, char *cmd, char *buf,
+					 size_t buf_len)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	int ret = 0;
+
+	if (os_strcasecmp(cmd, "STOP") == 0) {
+		linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 0);
+		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STOPPED");
+	} else if (os_strcasecmp(cmd, "START") == 0) {
+		linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1);
+		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STARTED");
+	} else if (os_strcasecmp(cmd, "MACADDR") == 0) {
+		u8 macaddr[ETH_ALEN] = {};
+
+		ret = linux_get_ifhwaddr(drv->global->ioctl_sock, bss->ifname,
+					 macaddr);
+		if (!ret)
+			ret = os_snprintf(buf, buf_len,
+					  "Macaddr = " MACSTR "\n",
+					  MAC2STR(macaddr));
+	} else if (os_strcasecmp(cmd, "RELOAD") == 0) {
+		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
+	} else if( os_strncasecmp(cmd, "RXFILTER-ADD ", 13) == 0 ) {
+		int i = nl80211_parse_wowlan_trigger_nr(cmd + 13);
+		if(i < 0)
+			return i;
+		return nl80211_toggle_wowlan_trigger(bss, i, 1);
+	} else if( os_strncasecmp(cmd, "RXFILTER-REMOVE ", 16) == 0 ) {
+		int i = nl80211_parse_wowlan_trigger_nr(cmd + 16);
+		if(i < 0)
+			return i;
+		return nl80211_toggle_wowlan_trigger(bss, i, 0);
+	} else if (os_strncasecmp(cmd, "SETBAND ", 8) == 0) {
+		/* Do nothing: Handled by wpa_supplicant_driver_cmd */
+		return 0;
+	} else if(os_strncasecmp(cmd, "COUNTRY ", 8) == 0) {
+		return wpa_driver_nl80211_set_country(priv, cmd + 8);
+	} else if( os_strcasecmp(cmd, "RXFILTER-START") == 0 ) {
+		return nl80211_set_wowlan_triggers(bss, 1);
+	} else if( os_strcasecmp(cmd, "RXFILTER-STOP") == 0 ) {
+		return nl80211_set_wowlan_triggers(bss, 0);
+	/* useless commands in our case - do nothing */
+	} else if (os_strncasecmp(cmd, "SCAN-ACTIVE", 11) == 0 ||
+		   os_strncasecmp(cmd, "SCAN-PASSIVE", 12) == 0 ||
+		   os_strncasecmp(cmd, "BTCOEXMODE", 10) == 0 ||
+		   os_strncasecmp(cmd, "BTCOEXSCAN-START", 16) == 0 ||
+		   os_strncasecmp(cmd, "BTCOEXSCAN-STOP", 15) == 0 ||
+		   os_strncasecmp(cmd, "SETSUSPENDMODE", 14) == 0) {
+		return 0;
+	} else {
+		wpa_printf(MSG_ERROR, "Unsupported command: %s", cmd);
+		ret = -1;
+	}
+
+	return ret;
+}
+
 #endif /* ANDROID */
 
+static int nl80211_testmode_cmd_smart_config_start(
+				struct wpa_driver_nl80211_data *drv,
+				u16 group_bitmap)
+{
+	struct nl_msg *msg;
+	int ret;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID,
+		    WL1271_TM_CMD_SMART_CONFIG_START);
+	NLA_PUT_U32(msg, WL1271_TM_ATTR_GROUP_ID, group_bitmap);
+
+	ret = wpa_driver_nl80211_testmode_cmd(drv, msg);
+
+	/* we still need to free our nested message */
+	nlmsg_free(msg);
+	return ret;
+nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+static int
+nl80211_smart_config_start(struct wpa_driver_nl80211_data *drv,
+			   const char *buf)
+{
+	char *endp;
+	unsigned long group_id;
+
+	/* buf = <group_id> */
+	group_id = strtoul(buf, &endp, 0);
+	if (buf == endp || *endp != '\0')
+		return -1;
+
+	wpa_printf(MSG_DEBUG, "group_id: %ld", group_id);
+	wpa_printf(MSG_DEBUG, "Send testmode SMART_CONFIG_START cmd");
+
+	return nl80211_testmode_cmd_smart_config_start(drv, group_id);
+}
+
+static int nl80211_testmode_cmd_set_group_key(
+				struct wpa_driver_nl80211_data *drv,
+				u16 group_id,
+				int key_len, const char *key)
+{
+	struct nl_msg *msg;
+	int ret;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID,
+		    WL1271_TM_CMD_SMART_CONFIG_SET_GROUP_KEY);
+
+	NLA_PUT_U32(msg, WL1271_TM_ATTR_GROUP_ID, group_id);
+	NLA_PUT(msg, WL1271_TM_ATTR_GROUP_KEY, key_len, key);
+
+	ret = wpa_driver_nl80211_testmode_cmd(drv, msg);
+
+	/* we still need to free our nested message */
+	nlmsg_free(msg);
+	return ret;
+nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+static int
+nl80211_smart_config_set_group_key(struct wpa_driver_nl80211_data *drv,
+				   const char *buf)
+{
+	char *endp;
+	long group_id;
+
+	/* buf = <group_id> <key> */
+	group_id = strtol(buf, &endp, 10);
+
+	if (buf == endp || *endp != ' ' || group_id < 0)
+		return -1;
+
+	/* skip spaces */
+	while (*endp == ' ')
+		endp++;
+
+	wpa_printf(MSG_DEBUG, "group_id: %ld, key_len: %d, key: %s",
+		   group_id, strlen(endp), endp);
+	wpa_printf(MSG_DEBUG, "Send testmode SMART_CONFIG_SET_GROUP_KEY cmd");
+
+	return nl80211_testmode_cmd_set_group_key(drv, group_id,
+						  os_strlen(endp), endp);
+}
+
+static int wpa_driver_nl80211_driver_cmd(void *priv, char *cmd, char *buf,
+					 size_t buf_len)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	int ret = -1;
+
+	if (os_strcasecmp(cmd, "SMART_CONFIG_START") == 0) {
+		wpa_printf(MSG_DEBUG, "Send testmode SMART_CONFIG_START cmd");
+		ret = nl80211_smart_config_start(drv, buf);
+	} else if (os_strcasecmp(cmd, "SMART_CONFIG_STOP") == 0) {
+		wpa_printf(MSG_DEBUG, "Send testmode SMART_CONFIG_STOP cmd");
+		ret = wpa_driver_nl80211_testmode_empty_cmd(drv,
+				WL1271_TM_CMD_SMART_CONFIG_STOP);
+	} else if (os_strcasecmp(cmd, "SMART_CONFIG_SET_GROUP_KEY") == 0) {
+		ret = nl80211_smart_config_set_group_key(drv, buf);
+	} else {
+#ifdef ANDROID
+	ret = wpa_driver_nl80211_driver_cmd_android(priv, cmd, buf, buf_len);
+#endif
+	}
+	return ret;
+}
+
 
 const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.name = "nl80211",
@@ -9256,6 +10268,7 @@
 	.set_operstate = wpa_driver_nl80211_set_operstate,
 	.set_supp_port = wpa_driver_nl80211_set_supp_port,
 	.set_country = wpa_driver_nl80211_set_country,
+	.get_country = wpa_driver_nl80211_get_country,
 	.set_ap = wpa_driver_nl80211_set_ap,
 	.if_add = wpa_driver_nl80211_if_add,
 	.if_remove = wpa_driver_nl80211_if_remove,
@@ -9289,6 +10302,8 @@
 	.remain_on_channel = wpa_driver_nl80211_remain_on_channel,
 	.cancel_remain_on_channel =
 	wpa_driver_nl80211_cancel_remain_on_channel,
+	.set_priority = wpa_driver_nl80211_set_priority,
+	.cancel_priority = wpa_driver_nl80211_cancel_priority,
 	.probe_req_report = wpa_driver_nl80211_probe_req_report,
 	.deinit_ap = wpa_driver_nl80211_deinit_ap,
 	.deinit_p2p_cli = wpa_driver_nl80211_deinit_p2p_cli,
@@ -9298,6 +10313,7 @@
 	.signal_poll = nl80211_signal_poll,
 	.send_frame = nl80211_send_frame,
 	.shared_freq = wpa_driver_nl80211_shared_freq,
+	.shared_ap_freq = wpa_driver_nl80211_shared_ap_freq,
 	.set_param = nl80211_set_param,
 	.get_radio_name = nl80211_get_radio_name,
 	.add_pmkid = nl80211_add_pmkid,
@@ -9306,8 +10322,10 @@
 	.set_rekey_info = nl80211_set_rekey_info,
 	.poll_client = nl80211_poll_client,
 	.set_p2p_powersave = nl80211_set_p2p_powersave,
+	.stop_ap = wpa_driver_nl80211_stop_ap,
 #ifdef CONFIG_TDLS
 	.send_tdls_mgmt = nl80211_send_tdls_mgmt,
 	.tdls_oper = nl80211_tdls_oper,
 #endif /* CONFIG_TDLS */
+	.driver_cmd = wpa_driver_nl80211_driver_cmd,
 };
diff -Nur hostapd-2.0/src/drivers/drivers.mak hostapd-2.0-TI/src/drivers/drivers.mak
--- hostapd-2.0/src/drivers/drivers.mak	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/drivers/drivers.mak	2014-03-28 17:49:34.000000000 +0800
@@ -30,7 +30,10 @@
 ifdef CONFIG_LIBNL32
   DRV_LIBS += -lnl-3
   DRV_LIBS += -lnl-genl-3
-  DRV_CFLAGS += -DCONFIG_LIBNL20 -I/usr/include/libnl3
+  DRV_CFLAGS += -DCONFIG_LIBNL20
+ifndef LIBNL_PATH
+  DRV_CFLAGS += -I/usr/include/libnl3
+endif
 else
   ifdef CONFIG_LIBNL_TINY
     DRV_LIBS += -lnl-tiny
diff -Nur hostapd-2.0/src/drivers/driver_wext.c hostapd-2.0-TI/src/drivers/driver_wext.c
--- hostapd-2.0/src/drivers/driver_wext.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/drivers/driver_wext.c	2014-03-28 17:49:34.000000000 +0800
@@ -33,6 +33,15 @@
 
 #ifdef ANDROID
 #include "android_drv.h"
+
+/* FIX: Must not include internal header files into driver wrapper */
+#include "wpa_supplicant_i.h"
+#include "scan.h"
+
+#define WEXT_CSCAN_AMOUNT 9
+
+static int wpa_driver_wext_combo_scan(void *priv,
+				      struct wpa_driver_scan_params *params);
 #endif /* ANDROID */
 
 static int wpa_driver_wext_flush_pmkid(void *priv);
@@ -478,10 +487,20 @@
 				drv->assoc_req_ies = NULL;
 				os_free(drv->assoc_resp_ies);
 				drv->assoc_resp_ies = NULL;
+#ifdef ANDROID
+				if (!drv->skip_disconnect) {
+					drv->skip_disconnect = 1;
+#endif /* ANDROID */
 				wpa_supplicant_event(drv->ctx, EVENT_DISASSOC,
 						     NULL);
+#ifdef ANDROID
+				}
+#endif /* ANDROID */
 			
 			} else {
+#ifdef ANDROID
+				drv->skip_disconnect = 0;
+#endif /* ANDROID */
 				wpa_driver_wext_event_assoc_ies(drv);
 				wpa_supplicant_event(drv->ctx, EVENT_ASSOC,
 						     NULL);
@@ -863,6 +882,7 @@
 #ifdef ANDROID
 	drv->errors = 0;
 	drv->driver_is_started = TRUE;
+	drv->skip_disconnect = 0;
 	drv->bgscan_enabled = 0;
 #endif /* ANDROID */
 
@@ -1026,6 +1046,13 @@
 	const u8 *ssid = params->ssids[0].ssid;
 	size_t ssid_len = params->ssids[0].ssid_len;
 
+#ifdef ANDROID
+	if (drv->capa.max_scan_ssids > 1) {
+		ret = wpa_driver_wext_combo_scan(priv, params);
+		goto scan_out;
+	}
+#endif /* ANDROID */
+
 	if (ssid_len > IW_ESSID_MAX_SIZE) {
 		wpa_printf(MSG_DEBUG, "%s: too long SSID (%lu)",
 			   __FUNCTION__, (unsigned long) ssid_len);
@@ -1051,6 +1078,9 @@
 		ret = -1;
 	}
 
+#ifdef ANDROID
+scan_out:
+#endif /* ANDROID */
 	/* Not all drivers generate "scan completed" wireless event, so try to
 	 * read results after a timeout. */
 	timeout = 10;
@@ -1585,7 +1615,11 @@
 		drv->capa.auth = WPA_DRIVER_AUTH_OPEN |
 			WPA_DRIVER_AUTH_SHARED |
 			WPA_DRIVER_AUTH_LEAP;
+#ifdef ANDROID
+		drv->capa.max_scan_ssids = WEXT_CSCAN_AMOUNT;
+#else /* ANDROID */
 		drv->capa.max_scan_ssids = 1;
+#endif /* ANDROID */
 
 		wpa_printf(MSG_DEBUG, "  capabilities: key_mgmt 0x%x enc 0x%x "
 			   "flags 0x%x",
@@ -2046,6 +2080,10 @@
 
 	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
 
+#ifdef ANDROID
+	drv->skip_disconnect = 0;
+#endif /* ANDROID */
+
 	if (drv->cfg80211) {
 		/*
 		 * Stop cfg80211 from trying to associate before we are done
@@ -2342,6 +2380,198 @@
 
 #ifdef ANDROID
 
+#define WPA_DRIVER_WEXT_WAIT_US		400000
+#define WEXT_CSCAN_BUF_LEN		360
+#define WEXT_CSCAN_HEADER		"CSCAN S\x01\x00\x00S\x00"
+#define WEXT_CSCAN_HEADER_SIZE		12
+#define WEXT_CSCAN_SSID_SECTION		'S'
+#define WEXT_CSCAN_CHANNEL_SECTION	'C'
+#define WEXT_CSCAN_NPROBE_SECTION	'N'
+#define WEXT_CSCAN_ACTV_DWELL_SECTION	'A'
+#define WEXT_CSCAN_PASV_DWELL_SECTION	'P'
+#define WEXT_CSCAN_HOME_DWELL_SECTION	'H'
+#define WEXT_CSCAN_TYPE_SECTION		'T'
+#define WEXT_CSCAN_TYPE_DEFAULT		0
+#define WEXT_CSCAN_TYPE_PASSIVE		1
+#define WEXT_CSCAN_PASV_DWELL_TIME	130
+#define WEXT_CSCAN_PASV_DWELL_TIME_DEF	250
+#define WEXT_CSCAN_PASV_DWELL_TIME_MAX	3000
+#define WEXT_CSCAN_HOME_DWELL_TIME	130
+
+/**
+ * wpa_driver_wext_set_scan_timeout - Set scan timeout to report scan completion
+ * @priv: Pointer to private wext data from wpa_driver_wext_init()
+ *
+ * This function can be used to set registered timeout when starting a scan to
+ * generate a scan completed event if the driver does not report this.
+ */
+static void wpa_driver_wext_set_scan_timeout(void *priv)
+{
+	struct wpa_driver_wext_data *drv = priv;
+	int timeout = 10; /* In case scan A and B bands it can be long */
+
+	/* Not all drivers generate "scan completed" wireless event, so try to
+	 * read results after a timeout. */
+	if (drv->scan_complete_events) {
+		/*
+		 * The driver seems to deliver SIOCGIWSCAN events to notify
+		 * when scan is complete, so use longer timeout to avoid race
+		 * conditions with scanning and following association request.
+		 */
+		timeout = 30;
+	}
+	wpa_printf(MSG_DEBUG, "Scan requested - scan timeout %d seconds",
+		   timeout);
+	eloop_cancel_timeout(wpa_driver_wext_scan_timeout, drv, drv->ctx);
+	eloop_register_timeout(timeout, 0, wpa_driver_wext_scan_timeout, drv,
+			       drv->ctx);
+}
+
+
+/**
+ * wpa_driver_wext_combo_scan - Request the driver to initiate combo scan
+ * @priv: Pointer to private wext data from wpa_driver_wext_init()
+ * @params: Scan parameters
+ * Returns: 0 on success, -1 on failure
+ */
+static int wpa_driver_wext_combo_scan(void *priv,
+				      struct wpa_driver_scan_params *params)
+{
+	char buf[WEXT_CSCAN_BUF_LEN];
+	struct wpa_driver_wext_data *drv = priv;
+	struct iwreq iwr;
+	int ret, bp;
+	unsigned i;
+
+	if (!drv->driver_is_started) {
+		wpa_printf(MSG_DEBUG, "%s: Driver stopped", __func__);
+		return 0;
+	}
+
+	wpa_printf(MSG_DEBUG, "%s: Start", __func__);
+
+	/* Set list of SSIDs */
+	bp = WEXT_CSCAN_HEADER_SIZE;
+	os_memcpy(buf, WEXT_CSCAN_HEADER, bp);
+	for(i=0; i < params->num_ssids; i++) {
+		if ((bp + IW_ESSID_MAX_SIZE + 10) >= (int) sizeof(buf))
+			break;
+		wpa_printf(MSG_DEBUG, "For Scan: %s", params->ssids[i].ssid);
+		buf[bp++] = WEXT_CSCAN_SSID_SECTION;
+		buf[bp++] = params->ssids[i].ssid_len;
+		os_memcpy(&buf[bp], params->ssids[i].ssid,
+			  params->ssids[i].ssid_len);
+		bp += params->ssids[i].ssid_len;
+	}
+
+	/* Set list of channels */
+	buf[bp++] = WEXT_CSCAN_CHANNEL_SECTION;
+	buf[bp++] = 0;
+
+	/* Set passive dwell time (default is 250) */
+	buf[bp++] = WEXT_CSCAN_PASV_DWELL_SECTION;
+	buf[bp++] = (u8) WEXT_CSCAN_PASV_DWELL_TIME;
+	buf[bp++] = (u8) (WEXT_CSCAN_PASV_DWELL_TIME >> 8);
+
+	/* Set home dwell time (default is 40) */
+	buf[bp++] = WEXT_CSCAN_HOME_DWELL_SECTION;
+	buf[bp++] = (u8) WEXT_CSCAN_HOME_DWELL_TIME;
+	buf[bp++] = (u8) (WEXT_CSCAN_HOME_DWELL_TIME >> 8);
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.data.pointer = buf;
+	iwr.u.data.length = bp;
+
+	if ((ret = ioctl(drv->ioctl_sock, SIOCSIWPRIV, &iwr)) < 0) {
+		if (!drv->bgscan_enabled)
+			wpa_printf(MSG_ERROR, "ioctl[SIOCSIWPRIV] (cscan): %d",
+				   ret);
+		else
+			ret = 0; /* Hide error in case of bg scan */
+	}
+	return ret;
+}
+
+
+static int wpa_driver_wext_set_cscan_params(char *buf, size_t buf_len,
+					    char *cmd)
+{
+	char *pasv_ptr;
+	int bp, i;
+	u16 pasv_dwell = WEXT_CSCAN_PASV_DWELL_TIME_DEF;
+	u8 channel;
+
+	wpa_printf(MSG_DEBUG, "%s: %s", __func__, cmd);
+
+	/* Get command parameters */
+	pasv_ptr = os_strstr(cmd, ",TIME=");
+	if (pasv_ptr) {
+		*pasv_ptr = '\0';
+		pasv_ptr += 6;
+		pasv_dwell = (u16) atoi(pasv_ptr);
+		if (pasv_dwell == 0)
+			pasv_dwell = WEXT_CSCAN_PASV_DWELL_TIME_DEF;
+	}
+	channel = (u8) atoi(cmd + 5);
+
+	bp = WEXT_CSCAN_HEADER_SIZE;
+	os_memcpy(buf, WEXT_CSCAN_HEADER, bp);
+
+	/* Set list of channels */
+	buf[bp++] = WEXT_CSCAN_CHANNEL_SECTION;
+	buf[bp++] = channel;
+	if (channel != 0) {
+		i = (pasv_dwell - 1) / WEXT_CSCAN_PASV_DWELL_TIME_DEF;
+		for (; i > 0; i--) {
+			if ((size_t) (bp + 12) >= buf_len)
+				break;
+			buf[bp++] = WEXT_CSCAN_CHANNEL_SECTION;
+			buf[bp++] = channel;
+		}
+	} else {
+		if (pasv_dwell > WEXT_CSCAN_PASV_DWELL_TIME_MAX)
+			pasv_dwell = WEXT_CSCAN_PASV_DWELL_TIME_MAX;
+	}
+
+	/* Set passive dwell time (default is 250) */
+	buf[bp++] = WEXT_CSCAN_PASV_DWELL_SECTION;
+	if (channel != 0) {
+		buf[bp++] = (u8) WEXT_CSCAN_PASV_DWELL_TIME_DEF;
+		buf[bp++] = (u8) (WEXT_CSCAN_PASV_DWELL_TIME_DEF >> 8);
+	} else {
+		buf[bp++] = (u8) pasv_dwell;
+		buf[bp++] = (u8) (pasv_dwell >> 8);
+	}
+
+	/* Set home dwell time (default is 40) */
+	buf[bp++] = WEXT_CSCAN_HOME_DWELL_SECTION;
+	buf[bp++] = (u8) WEXT_CSCAN_HOME_DWELL_TIME;
+	buf[bp++] = (u8) (WEXT_CSCAN_HOME_DWELL_TIME >> 8);
+
+	/* Set cscan type */
+	buf[bp++] = WEXT_CSCAN_TYPE_SECTION;
+	buf[bp++] = WEXT_CSCAN_TYPE_PASSIVE;
+	return bp;
+}
+
+
+#define WEXT_NUMBER_SCAN_CHANNELS_FCC	11
+#define WEXT_NUMBER_SCAN_CHANNELS_ETSI	13
+#define WEXT_NUMBER_SCAN_CHANNELS_MKK1	14
+
+static char * wpa_driver_get_country_code(int channels)
+{
+	char *country = "US"; /* WEXT_NUMBER_SCAN_CHANNELS_FCC */
+
+	if (channels == WEXT_NUMBER_SCAN_CHANNELS_ETSI)
+		country = "EU";
+	else if (channels == WEXT_NUMBER_SCAN_CHANNELS_MKK1)
+		country = "JP";
+	return country;
+}
+
+
 static int android_wext_cmd(struct wpa_driver_wext_data *drv, const char *cmd)
 {
 	struct iwreq iwr;
@@ -2460,6 +2690,129 @@
 	return android_wext_cmd(drv, "PNOFORCE 0");
 }
 
+
+static int wpa_driver_wext_driver_cmd(void *priv, char *cmd, char *buf,
+				      size_t buf_len)
+{
+	struct wpa_driver_wext_data *drv = priv;
+	struct iwreq iwr;
+	int ret = 0, flags;
+
+	wpa_printf(MSG_DEBUG, "%s %s len = %d", __func__, cmd, buf_len);
+
+	if (!drv->driver_is_started && os_strcasecmp(cmd, "START") != 0) {
+		wpa_printf(MSG_ERROR, "WEXT: Driver not initialized yet");
+		return -1;
+	}
+
+	if (os_strcasecmp(cmd, "RSSI-APPROX") == 0) {
+		os_strncpy(cmd, RSSI_CMD, MAX_DRV_CMD_SIZE);
+	} else if (os_strncasecmp(cmd, "SCAN-CHANNELS", 13) == 0) {
+		int no_of_chan = atoi(cmd + 13);
+		os_snprintf(cmd, MAX_DRV_CMD_SIZE, "COUNTRY %s",
+			    wpa_driver_get_country_code(no_of_chan));
+	} else if (os_strcasecmp(cmd, "STOP") == 0) {
+		(void)linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 0);
+	} else if (os_strcasecmp(cmd, "RELOAD") == 0) {
+		wpa_printf(MSG_DEBUG, "Reload command");
+		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
+		return ret;
+	}
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	os_memcpy(buf, cmd, strlen(cmd) + 1);
+	iwr.u.data.pointer = buf;
+	iwr.u.data.length = buf_len;
+
+	if (os_strncasecmp(cmd, "CSCAN", 5) == 0 ) {
+		/* FIX: Must not dereference wpa_s from driver wrapper */
+		struct wpa_supplicant *wpa_s = drv->ctx;
+		if (!wpa_s->scanning && ((wpa_s->wpa_state <= WPA_SCANNING) ||
+					 (wpa_s->wpa_state >= WPA_COMPLETED)))
+		{
+			iwr.u.data.length = wpa_driver_wext_set_cscan_params(
+				buf, buf_len, cmd);
+		} else {
+			wpa_printf(MSG_ERROR, "Ongoing Scan action...");
+			return ret;
+		}
+	}
+
+	ret = ioctl(drv->ioctl_sock, SIOCSIWPRIV, &iwr);
+	if (ret < 0) {
+		wpa_printf(MSG_ERROR, "%s failed (%d): %s", __func__, ret,
+			   cmd);
+		drv->errors++;
+		if (drv->errors > DRV_NUMBER_SEQUENTIAL_ERRORS) {
+			drv->errors = 0;
+			wpa_msg(drv->ctx, MSG_INFO,
+				WPA_EVENT_DRIVER_STATE "HANGED");
+		}
+	} else {
+		drv->errors = 0;
+		ret = 0;
+		if ((os_strcasecmp(cmd, RSSI_CMD) == 0) ||
+		    (os_strcasecmp(cmd, LINKSPEED_CMD) == 0) ||
+		    (os_strcasecmp(cmd, "MACADDR") == 0) ||
+		    (os_strcasecmp(cmd, "GETPOWER") == 0) ||
+		    (os_strcasecmp(cmd, "GETBAND") == 0)) {
+			ret = os_strlen(buf);
+		} else if (os_strcasecmp(cmd, "START") == 0) {
+			drv->driver_is_started = TRUE;
+			linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 1);
+#if 0
+			os_sleep(0, WPA_DRIVER_WEXT_WAIT_US);
+			wpa_msg(drv->ctx, MSG_INFO,
+				WPA_EVENT_DRIVER_STATE "STARTED");
+#endif
+		} else if (os_strcasecmp(cmd, "STOP") == 0) {
+			drv->driver_is_started = FALSE;
+#if 0
+			wpa_msg(drv->ctx, MSG_INFO,
+				WPA_EVENT_DRIVER_STATE "STOPPED");
+#endif
+		} else if (os_strncasecmp(cmd, "CSCAN", 5) == 0) {
+			wpa_driver_wext_set_scan_timeout(priv);
+			/* FIX: Must not call internal wpa_supplicant functions
+			 * directly from driver wrapper */
+			wpa_supplicant_notify_scanning(drv->ctx, 1);
+		}
+		wpa_printf(MSG_DEBUG, "%s %s len = %d, %d", __func__, buf, ret,
+			   os_strlen(buf));
+	}
+
+	return ret;
+}
+
+
+static int wpa_driver_signal_poll(void *priv, struct wpa_signal_info *si)
+{
+	char buf[MAX_DRV_CMD_SIZE];
+	struct wpa_driver_wext_data *drv = priv;
+	char *prssi;
+	int res;
+
+	os_memset(si, 0, sizeof(*si));
+	res = wpa_driver_wext_driver_cmd(priv, RSSI_CMD, buf, sizeof(buf));
+	/* Answer: SSID rssi -Val */
+	if (res < 0)
+		return res;
+	prssi = strcasestr(buf, RSSI_CMD);
+	if (!prssi)
+		return -1;
+	si->current_signal = atoi(prssi + strlen(RSSI_CMD) + 1);
+
+	res = wpa_driver_wext_driver_cmd(priv, LINKSPEED_CMD, buf,
+					 sizeof(buf));
+	/* Answer: LinkSpeed Val */
+	if (res < 0)
+		return res;
+	si->current_txrate = atoi(buf + strlen(LINKSPEED_CMD) + 1) * 1000;
+
+	return 0;
+}
+
 #endif /* ANDROID */
 
 
@@ -2483,6 +2836,8 @@
 	.set_operstate = wpa_driver_wext_set_operstate,
 	.get_radio_name = wext_get_radio_name,
 #ifdef ANDROID
+	.signal_poll = wpa_driver_signal_poll,
+	.driver_cmd = wpa_driver_wext_driver_cmd,
 	.sched_scan = wext_sched_scan,
 	.stop_sched_scan = wext_stop_sched_scan,
 #endif /* ANDROID */
diff -Nur hostapd-2.0/src/drivers/driver_wext.h hostapd-2.0-TI/src/drivers/driver_wext.h
--- hostapd-2.0/src/drivers/driver_wext.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/drivers/driver_wext.h	2014-03-28 17:49:34.000000000 +0800
@@ -48,6 +48,7 @@
 #ifdef ANDROID
 	int errors;
 	int driver_is_started;
+	int skip_disconnect;
 	int bgscan_enabled;
 #endif /* ANDROID */
 };
diff -Nur hostapd-2.0/src/drivers/nl80211_copy.h hostapd-2.0-TI/src/drivers/nl80211_copy.h
--- hostapd-2.0/src/drivers/nl80211_copy.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/drivers/nl80211_copy.h	2014-03-28 17:49:34.000000000 +0800
@@ -36,7 +36,21 @@
  * The station is still assumed to belong to the AP interface it was added
  * to.
  *
- * TODO: need more info?
+ * Station handling varies per interface type and depending on the driver's
+ * capabilities.
+ *
+ * For drivers supporting TDLS with external setup (WIPHY_FLAG_SUPPORTS_TDLS
+ * and WIPHY_FLAG_TDLS_EXTERNAL_SETUP), the station lifetime is as follows:
+ *  - a setup station entry is added, not yet authorized, without any rate
+ *    or capability information, this just exists to avoid race conditions
+ *  - when the TDLS setup is done, a single NL80211_CMD_SET_STATION is valid
+ *    to add rate and capability information to the station and at the same
+ *    time mark it authorized.
+ *  - %NL80211_TDLS_ENABLE_LINK is then used
+ *  - after this, the only valid operation is to remove it by tearing down
+ *    the TDLS link (%NL80211_TDLS_DISABLE_LINK)
+ *
+ * TODO: need more info for other interface types
  */
 
 /**
@@ -118,8 +132,9 @@
  *	to get a list of all present wiphys.
  * @NL80211_CMD_SET_WIPHY: set wiphy parameters, needs %NL80211_ATTR_WIPHY or
  *	%NL80211_ATTR_IFINDEX; can be used to set %NL80211_ATTR_WIPHY_NAME,
- *	%NL80211_ATTR_WIPHY_TXQ_PARAMS, %NL80211_ATTR_WIPHY_FREQ,
- *	%NL80211_ATTR_WIPHY_CHANNEL_TYPE, %NL80211_ATTR_WIPHY_RETRY_SHORT,
+ *	%NL80211_ATTR_WIPHY_TXQ_PARAMS, %NL80211_ATTR_WIPHY_FREQ (and the
+ *	attributes determining the channel width; this is used for setting
+ *	monitor mode channel),  %NL80211_ATTR_WIPHY_RETRY_SHORT,
  *	%NL80211_ATTR_WIPHY_RETRY_LONG, %NL80211_ATTR_WIPHY_FRAG_THRESHOLD,
  *	and/or %NL80211_ATTR_WIPHY_RTS_THRESHOLD.
  *	However, for setting the channel, see %NL80211_CMD_SET_CHANNEL
@@ -169,9 +184,10 @@
  *	%NL80211_ATTR_HIDDEN_SSID, %NL80211_ATTR_CIPHERS_PAIRWISE,
  *	%NL80211_ATTR_CIPHER_GROUP, %NL80211_ATTR_WPA_VERSIONS,
  *	%NL80211_ATTR_AKM_SUITES, %NL80211_ATTR_PRIVACY,
- *	%NL80211_ATTR_AUTH_TYPE and %NL80211_ATTR_INACTIVITY_TIMEOUT.
+ *	%NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_INACTIVITY_TIMEOUT,
+ *	%NL80211_ATTR_ACL_POLICY and %NL80211_ATTR_MAC_ADDRS.
  *	The channel to use can be set on the interface or be given using the
- *	%NL80211_ATTR_WIPHY_FREQ and %NL80211_ATTR_WIPHY_CHANNEL_TYPE attrs.
+ *	%NL80211_ATTR_WIPHY_FREQ and the attributes determining channel width.
  * @NL80211_CMD_NEW_BEACON: old alias for %NL80211_CMD_START_AP
  * @NL80211_CMD_STOP_AP: Stop AP operation on the given interface
  * @NL80211_CMD_DEL_BEACON: old alias for %NL80211_CMD_STOP_AP
@@ -373,8 +389,8 @@
  *	requests to connect to a specified network but without separating
  *	auth and assoc steps. For this, you need to specify the SSID in a
  *	%NL80211_ATTR_SSID attribute, and can optionally specify the association
- *	IEs in %NL80211_ATTR_IE, %NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_MAC,
- *	%NL80211_ATTR_WIPHY_FREQ, %NL80211_ATTR_CONTROL_PORT,
+ *	IEs in %NL80211_ATTR_IE, %NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_USE_MFP,
+ *	%NL80211_ATTR_MAC, %NL80211_ATTR_WIPHY_FREQ, %NL80211_ATTR_CONTROL_PORT,
  *	%NL80211_ATTR_CONTROL_PORT_ETHERTYPE and
  *	%NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT.
  *	Background scan period can optionally be
@@ -401,8 +417,7 @@
  *	a response while being associated to an AP on another channel.
  *	%NL80211_ATTR_IFINDEX is used to specify which interface (and thus
  *	radio) is used. %NL80211_ATTR_WIPHY_FREQ is used to specify the
- *	frequency for the operation and %NL80211_ATTR_WIPHY_CHANNEL_TYPE may be
- *	optionally used to specify additional channel parameters.
+ *	frequency for the operation.
  *	%NL80211_ATTR_DURATION is used to specify the duration in milliseconds
  *	to remain on the channel. This command is also used as an event to
  *	notify when the requested duration starts (it may take a while for the
@@ -440,12 +455,11 @@
  *	as an event indicating reception of a frame that was not processed in
  *	kernel code, but is for us (i.e., which may need to be processed in a
  *	user space application). %NL80211_ATTR_FRAME is used to specify the
- *	frame contents (including header). %NL80211_ATTR_WIPHY_FREQ (and
- *	optionally %NL80211_ATTR_WIPHY_CHANNEL_TYPE) is used to indicate on
- *	which channel the frame is to be transmitted or was received. If this
- *	channel is not the current channel (remain-on-channel or the
- *	operational channel) the device will switch to the given channel and
- *	transmit the frame, optionally waiting for a response for the time
+ *	frame contents (including header). %NL80211_ATTR_WIPHY_FREQ is used
+ *	to indicate on which channel the frame is to be transmitted or was
+ *	received. If this channel is not the current channel (remain-on-channel
+ *	or the operational channel) the device will switch to the given channel
+ *	and transmit the frame, optionally waiting for a response for the time
  *	specified using %NL80211_ATTR_DURATION. When called, this operation
  *	returns a cookie (%NL80211_ATTR_COOKIE) that will be included with the
  *	TX status event pertaining to the TX request.
@@ -473,8 +487,8 @@
  *	command is used as an event to indicate the that a trigger level was
  *	reached.
  * @NL80211_CMD_SET_CHANNEL: Set the channel (using %NL80211_ATTR_WIPHY_FREQ
- *	and %NL80211_ATTR_WIPHY_CHANNEL_TYPE) the given interface (identifed
- *	by %NL80211_ATTR_IFINDEX) shall operate on.
+ *	and the attributes determining channel width) the given interface
+ *	(identifed by %NL80211_ATTR_IFINDEX) shall operate on.
  *	In case multiple channels are supported by the device, the mechanism
  *	with which it switches channels is implementation-defined.
  *	When a monitor interface is given, it can only switch channel while
@@ -499,9 +513,11 @@
  * @NL80211_CMD_NEW_PEER_CANDIDATE: Notification on the reception of a
  *      beacon or probe response from a compatible mesh peer.  This is only
  *      sent while no station information (sta_info) exists for the new peer
- *      candidate and when @NL80211_MESH_SETUP_USERSPACE_AUTH is set.  On
- *      reception of this notification, userspace may decide to create a new
- *      station (@NL80211_CMD_NEW_STATION).  To stop this notification from
+ *      candidate and when @NL80211_MESH_SETUP_USERSPACE_AUTH,
+ *      @NL80211_MESH_SETUP_USERSPACE_AMPE, or
+ *      @NL80211_MESH_SETUP_USERSPACE_MPM is set.  On reception of this
+ *      notification, userspace may decide to create a new station
+ *      (@NL80211_CMD_NEW_STATION).  To stop this notification from
  *      reoccurring, the userspace authentication daemon may want to create the
  *      new station with the AUTHENTICATED flag unset and maybe change it later
  *      depending on the authentication result.
@@ -513,6 +529,12 @@
  *	command with the %NL80211_ATTR_WOWLAN_TRIGGERS attribute. For
  *	more background information, see
  *	http://wireless.kernel.org/en/users/Documentation/WoWLAN.
+ *	The @NL80211_CMD_SET_WOWLAN command can also be used as a notification
+ *	from the driver reporting the wakeup reason. In this case, the
+ *	@NL80211_ATTR_WOWLAN_TRIGGERS attribute will contain the reason
+ *	for the wakeup, if it was caused by wireless. If it is not present
+ *	in the wakeup notification, the wireless device didn't cause the
+ *	wakeup but reports that it was woken up.
  *
  * @NL80211_CMD_SET_REKEY_OFFLOAD: This command is used give the driver
  *	the necessary information for supporting GTK rekey offload. This
@@ -568,8 +590,8 @@
  *
  * @NL80211_CMD_CH_SWITCH_NOTIFY: An AP or GO may decide to switch channels
  *	independently of the userspace SME, send this event indicating
- *	%NL80211_ATTR_IFINDEX is now on %NL80211_ATTR_WIPHY_FREQ with
- *	%NL80211_ATTR_WIPHY_CHANNEL_TYPE.
+ *	%NL80211_ATTR_IFINDEX is now on %NL80211_ATTR_WIPHY_FREQ and the
+ *	attributes determining channel width.
  *
  * @NL80211_CMD_START_P2P_DEVICE: Start the given P2P Device, identified by
  *	its %NL80211_ATTR_WDEV identifier. It must have been created with
@@ -587,6 +609,71 @@
  * @NL80211_CMD_SET_MCAST_RATE: Change the rate used to send multicast frames
  *	for IBSS or MESH vif.
  *
+ * @NL80211_CMD_SET_MAC_ACL: sets ACL for MAC address based access control.
+ *	This is to be used with the drivers advertising the support of MAC
+ *	address based access control. List of MAC addresses is passed in
+ *	%NL80211_ATTR_MAC_ADDRS and ACL policy is passed in
+ *	%NL80211_ATTR_ACL_POLICY. Driver will enable ACL with this list, if it
+ *	is not already done. The new list will replace any existing list. Driver
+ *	will clear its ACL when the list of MAC addresses passed is empty. This
+ *	command is used in AP/P2P GO mode. Driver has to make sure to clear its
+ *	ACL list during %NL80211_CMD_STOP_AP.
+ *
+ * @NL80211_CMD_RADAR_DETECT: Start a Channel availability check (CAC). Once
+ *	a radar is detected or the channel availability scan (CAC) has finished
+ *	or was aborted, or a radar was detected, usermode will be notified with
+ *	this event. This command is also used to notify userspace about radars
+ *	while operating on this channel.
+ *	%NL80211_ATTR_RADAR_EVENT is used to inform about the type of the
+ *	event.
+ *
+ * @NL80211_CMD_GET_PROTOCOL_FEATURES: Get global nl80211 protocol features,
+ *	i.e. features for the nl80211 protocol rather than device features.
+ *	Returns the features in the %NL80211_ATTR_PROTOCOL_FEATURES bitmap.
+ *
+ * @NL80211_CMD_UPDATE_FT_IES: Pass down the most up-to-date Fast Transition
+ *	Information Element to the WLAN driver
+ *
+ * @NL80211_CMD_FT_EVENT: Send a Fast transition event from the WLAN driver
+ *	to the supplicant. This will carry the target AP's MAC address along
+ *	with the relevant Information Elements. This event is used to report
+ *	received FT IEs (MDIE, FTIE, RSN IE, TIE, RICIE).
+ *
+ * @NL80211_CMD_CRIT_PROTOCOL_START: Indicates user-space will start running
+ *	a critical protocol that needs more reliability in the connection to
+ *	complete.
+ *
+ * @NL80211_CMD_CRIT_PROTOCOL_STOP: Indicates the connection reliability can
+ *	return back to normal.
+ *
+ * @NL80211_CMD_SCAN_CANCEL: Stop currently running scan (both sw and hw).
+ *	This operation will eventually invoke %NL80211_CMD_SCAN_ABORTED
+ *	event, partial scan results will be available. Returns -ENOENT
+ *	if scan is not running.
+ *
+ * @NL80211_CMD_IM_SCAN_RESULT: Intermediate scan result notification event,
+ *	this event could be enabled with @NL80211_ATTR_IM_SCAN_RESULT
+ *	flag during @NL80211_CMD_TRIGGER_SCAN. This event contains
+ *	%NL80211_BSS_BSSID which is used to specify the BSSID of received
+ *	scan result and %NL80211_BSS_SIGNAL_MBM to indicate signal strength.
+ *	On reception of this notification, userspace may decide to stop earlier
+ *	currently running scan with (@NL80211_CMD_SCAN_CANCEL).
+ *
+ * @NL80211_CMD_ROAMING_SUPPORT: A notify event used to alert userspace
+ *      regarding changes in roaming support by the driver. If roaming is
+ *      disabled (marked by the presence of @NL80211_ATTR_ROAMING_DISABLED flag)
+ *      userspace should disable background scans and roaming attempts.
+ *
+ * @NL80211_CMD_AP_CH_SWITCH: Perform a channel switch in the driver (for
+ *	AP/GO).
+ *	%NL80211_ATTR_WIPHY_FREQ: new channel frequency.
+ *	%NL80211_ATTR_CH_SWITCH_BLOCK_TX: block tx on the current channel.
+ *	%NL80211_ATTR_CH_SWITCH_POST_BLOCK_TX: block tx on the target channel.
+ *	%NL80211_FREQ_ATTR_CH_SWITCH_COUNT: number of TBTT's until the channel
+ *	switch event.
+ *
+ * @NL80211_CMD_REQ_CH_SW: Request a channel switch from a GO/AP.
+ *
  * @NL80211_CMD_MAX: highest used command number
  * @__NL80211_CMD_AFTER_LAST: internal use
  */
@@ -737,6 +824,31 @@
 
 	NL80211_CMD_SET_MCAST_RATE,
 
+	NL80211_CMD_SET_MAC_ACL,
+
+	NL80211_CMD_RADAR_DETECT,
+
+	NL80211_CMD_GET_PROTOCOL_FEATURES,
+
+	NL80211_CMD_UPDATE_FT_IES,
+	NL80211_CMD_FT_EVENT,
+
+	NL80211_CMD_CRIT_PROTOCOL_START,
+	NL80211_CMD_CRIT_PROTOCOL_STOP,
+
+	/* leave some room for adding nl80211 commands for old kernels */
+	NL80211_CMD_SCAN_CANCEL = NL80211_CMD_FT_EVENT + 40,
+
+	NL80211_CMD_IM_SCAN_RESULT,
+
+	NL80211_CMD_ROAMING_SUPPORT,
+
+	/* set/cancel_priority is depcrecated. keep it for backward compat */
+	NL80211_CMD_SET_PRIORITY,
+	NL80211_CMD_CANCEL_PRIORITY,
+
+	NL80211_CMD_AP_CH_SWITCH,
+	NL80211_CMD_REQ_CH_SW,
 	/* add new commands above here */
 
 	/* used to define NL80211_CMD_MAX below */
@@ -773,14 +885,26 @@
  *	/sys/class/ieee80211/<phyname>/index
  * @NL80211_ATTR_WIPHY_NAME: wiphy name (used for renaming)
  * @NL80211_ATTR_WIPHY_TXQ_PARAMS: a nested array of TX queue parameters
- * @NL80211_ATTR_WIPHY_FREQ: frequency of the selected channel in MHz
+ * @NL80211_ATTR_WIPHY_FREQ: frequency of the selected channel in MHz,
+ *	defines the channel together with the (deprecated)
+ *	%NL80211_ATTR_WIPHY_CHANNEL_TYPE attribute or the attributes
+ *	%NL80211_ATTR_CHANNEL_WIDTH and if needed %NL80211_ATTR_CENTER_FREQ1
+ *	and %NL80211_ATTR_CENTER_FREQ2
+ * @NL80211_ATTR_CHANNEL_WIDTH: u32 attribute containing one of the values
+ *	of &enum nl80211_chan_width, describing the channel width. See the
+ *	documentation of the enum for more information.
+ * @NL80211_ATTR_CENTER_FREQ1: Center frequency of the first part of the
+ *	channel, used for anything but 20 MHz bandwidth
+ * @NL80211_ATTR_CENTER_FREQ2: Center frequency of the second part of the
+ *	channel, used only for 80+80 MHz bandwidth
  * @NL80211_ATTR_WIPHY_CHANNEL_TYPE: included with NL80211_ATTR_WIPHY_FREQ
- *	if HT20 or HT40 are allowed (i.e., 802.11n disabled if not included):
+ *	if HT20 or HT40 are to be used (i.e., HT disabled if not included):
  *	NL80211_CHAN_NO_HT = HT not allowed (i.e., same as not including
  *		this attribute)
  *	NL80211_CHAN_HT20 = HT20 only
  *	NL80211_CHAN_HT40MINUS = secondary channel is below the primary channel
  *	NL80211_CHAN_HT40PLUS = secondary channel is above the primary channel
+ *	This attribute is now deprecated.
  * @NL80211_ATTR_WIPHY_RETRY_SHORT: TX retry limit for frames whose length is
  *	less than or equal to the RTS threshold; allowed range: 1..255;
  *	dot11ShortRetryLimit; u8
@@ -844,7 +968,8 @@
  *	consisting of a nested array.
  *
  * @NL80211_ATTR_MESH_ID: mesh id (1-32 bytes).
- * @NL80211_ATTR_STA_PLINK_ACTION: action to perform on the mesh peer link.
+ * @NL80211_ATTR_STA_PLINK_ACTION: action to perform on the mesh peer link
+ *	(see &enum nl80211_plink_action).
  * @NL80211_ATTR_MPATH_NEXT_HOP: MAC address of the next hop for a mesh path.
  * @NL80211_ATTR_MPATH_INFO: information about a mesh_path, part of mesh path
  * 	info given for %NL80211_CMD_GET_MPATH, nested attribute described at
@@ -947,7 +1072,7 @@
  * @NL80211_ATTR_USE_MFP: Whether management frame protection (IEEE 802.11w) is
  *	used for the association (&enum nl80211_mfp, represented as a u32);
  *	this attribute can be used
- *	with %NL80211_CMD_ASSOCIATE request
+ *	with %NL80211_CMD_ASSOCIATE and %NL80211_CMD_CONNECT requests
  *
  * @NL80211_ATTR_STA_FLAGS2: Attribute containing a
  *	&struct nl80211_sta_flag_update.
@@ -1127,10 +1252,10 @@
  * @NL80211_ATTR_SUPPORT_MESH_AUTH: Currently, this means the underlying driver
  *	allows auth frames in a mesh to be passed to userspace for processing via
  *	the @NL80211_MESH_SETUP_USERSPACE_AUTH flag.
- * @NL80211_ATTR_STA_PLINK_STATE: The state of a mesh peer link as
- *	defined in &enum nl80211_plink_state. Used when userspace is
- *	driving the peer link management state machine.
- *	@NL80211_MESH_SETUP_USERSPACE_AMPE must be enabled.
+ * @NL80211_ATTR_STA_PLINK_STATE: The state of a mesh peer link as defined in
+ *	&enum nl80211_plink_state. Used when userspace is driving the peer link
+ *	management state machine.  @NL80211_MESH_SETUP_USERSPACE_AMPE or
+ *	@NL80211_MESH_SETUP_USERSPACE_MPM must be enabled.
  *
  * @NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED: indicates, as part of the wiphy
  *	capabilities, the supported WoWLAN triggers
@@ -1140,7 +1265,9 @@
  *	triggers.
  *
  * @NL80211_ATTR_SCHED_SCAN_INTERVAL: Interval between scheduled scan
- *	cycles, in msecs.
+ *	cycles, in msecs. If short interval is supported by the driver
+ *      and configured then this will be used only after the requested
+ *      number of short intervals
  *
  * @NL80211_ATTR_SCHED_SCAN_MATCH: Nested attribute with one or more
  *	sets of attributes to match during scheduled scans.  Only BSSs
@@ -1292,6 +1419,100 @@
  *
  * @NL80211_ATTR_SCAN_FLAGS: scan request control flags (u32)
  *
+ * @NL80211_ATTR_P2P_CTWINDOW: P2P GO Client Traffic Window (u8), used with
+ *	the START_AP and SET_BSS commands
+ * @NL80211_ATTR_P2P_OPPPS: P2P GO opportunistic PS (u8), used with the
+ *	START_AP and SET_BSS commands. This can have the values 0 or 1;
+ *	if not given in START_AP 0 is assumed, if not given in SET_BSS
+ *	no change is made.
+ *
+ * @NL80211_ATTR_LOCAL_MESH_POWER_MODE: local mesh STA link-specific power mode
+ *	defined in &enum nl80211_mesh_power_mode.
+ *
+ * @NL80211_ATTR_ACL_POLICY: ACL policy, see &enum nl80211_acl_policy,
+ *	carried in a u32 attribute
+ *
+ * @NL80211_ATTR_MAC_ADDRS: Array of nested MAC addresses, used for
+ *	MAC ACL.
+ *
+ * @NL80211_ATTR_MAC_ACL_MAX: u32 attribute to advertise the maximum
+ *	number of MAC addresses that a device can support for MAC
+ *	ACL.
+ *
+ * @NL80211_ATTR_RADAR_EVENT: Type of radar event for notification to userspace,
+ *	contains a value of enum nl80211_radar_event (u32).
+ *
+ * @NL80211_ATTR_EXT_CAPA: 802.11 extended capabilities that the kernel driver
+ *	has and handles. The format is the same as the IE contents. See
+ *	802.11-2012 8.4.2.29 for more information.
+ * @NL80211_ATTR_EXT_CAPA_MASK: Extended capabilities that the kernel driver
+ *	has set in the %NL80211_ATTR_EXT_CAPA value, for multibit fields.
+ *
+ * @NL80211_ATTR_STA_CAPABILITY: Station capabilities (u16) are advertised to
+ *	the driver, e.g., to enable TDLS power save (PU-APSD).
+ *
+ * @NL80211_ATTR_STA_EXT_CAPABILITY: Station extended capabilities are
+ *	advertised to the driver, e.g., to enable TDLS off channel operations
+ *	and PU-APSD.
+ *
+ * @NL80211_ATTR_PROTOCOL_FEATURES: global nl80211 feature flags, see
+ *	&enum nl80211_protocol_features, the attribute is a u32.
+ *
+ * @NL80211_ATTR_SPLIT_WIPHY_DUMP: flag attribute, userspace supports
+ *	receiving the data for a single wiphy split across multiple
+ *	messages, given with wiphy dump message
+ *
+ * @NL80211_ATTR_MDID: Mobility Domain Identifier
+ *
+ * @NL80211_ATTR_IE_RIC: Resource Information Container Information
+ *	Element
+ *
+ * @NL80211_ATTR_CRIT_PROT_ID: critical protocol identifier requiring increased
+ *	reliability, see &enum nl80211_crit_proto_id (u16).
+ * @NL80211_ATTR_MAX_CRIT_PROT_DURATION: duration in milliseconds in which
+ *      the connection should have increased reliability (u16).
+ *
+ * @%NL80211_ATTR_IM_SCAN_RESULT: Flag attribute to enable intermediate
+ *	scan result notification event (%NL80211_CMD_IM_SCAN_RESULT)
+ *	for the %NL80211_CMD_TRIGGER_SCAN command.
+ *	When set: will notify on each new scan result in the cache.
+ *
+ * @%NL80211_ATTR_IM_SCAN_RESULT_MIN_RSSI: Intermediate event filtering.
+ *	When set: will notify only those new scan result whose signal
+ *	strength of probe response/beacon (in dBm) is stronger than this
+ *	negative value (usually: -20 dBm > X > -95 dBm).
+ *
+ * @%NL80211_ATTR_SCAN_MIN_DWELL: Minimum scan dwell time (in TUs), u32
+ *	attribute to setup minimum time to wait on each channel, if received
+ *	at least one probe response during this period will continue waiting
+ *	%NL80211_ATTR_SCAN_MAX_DWELL, otherwise will move to next channel.
+ *	Relevant only for active scan, used with %NL80211_CMD_TRIGGER_SCAN
+ *	command. This is optional attribute, so if it's not set driver should
+ *	use hardware default values.
+ * @%NL80211_ATTR_SCAN_MAX_DWELL: Maximum scan dwell time (in TUs), u32
+ *	attribute to setup maximum time to wait on each channel.
+ *	Relevant only for active scan, used with %NL80211_CMD_TRIGGER_SCAN
+ *	command. This is optional attribute, so if it's not set driver should
+ *	use hardware default values.
+ * @%NL80211_ATTR_SCAN_NUM_PROBE:  Attribute (u8) to setup number of probe
+ *	requests to transmit on each active scan channel, used with
+ *	%NL80211_CMD_TRIGGER_SCAN command.
+ *
+ * @NL80211_ATTR_SCHED_SCAN_SHORT_INTERVAL: interval between
+ *      each short interval scheduled scan cycle in msecs.
+ * @NL80211_ATTR_SCHED_SCAN_NUM_SHORT_INTERVALS: number of short
+ *      sched scan intervals before switching to the long interval
+ * @NL80211_ATTR_ROAMING_DISABLED: indicates that the driver can't do roaming
+ *      currently.
+ *
+ * @NL80211_ATTR_CH_SWITCH_COUNT: the number of TBTT's until the channel
+ *	switch event
+ * @NL80211_ATTR_CH_SWITCH_BLOCK_TX: block tx on the current channel before the
+ *	channel switch operation.
+ * @NL80211_ATTR_CH_SWITCH_POST_BLOCK_TX: block tx on the target channel after
+ *	the channel switch operation, should be set if the target channel is
+ *	DFS channel.
+ *
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
  */
@@ -1555,6 +1776,57 @@
 
 	NL80211_ATTR_SCAN_FLAGS,
 
+	NL80211_ATTR_CHANNEL_WIDTH,
+	NL80211_ATTR_CENTER_FREQ1,
+	NL80211_ATTR_CENTER_FREQ2,
+
+	NL80211_ATTR_P2P_CTWINDOW,
+	NL80211_ATTR_P2P_OPPPS,
+
+	NL80211_ATTR_LOCAL_MESH_POWER_MODE,
+
+	NL80211_ATTR_ACL_POLICY,
+
+	NL80211_ATTR_MAC_ADDRS,
+
+	NL80211_ATTR_MAC_ACL_MAX,
+
+	NL80211_ATTR_RADAR_EVENT,
+
+	NL80211_ATTR_EXT_CAPA,
+	NL80211_ATTR_EXT_CAPA_MASK,
+
+	NL80211_ATTR_STA_CAPABILITY,
+	NL80211_ATTR_STA_EXT_CAPABILITY,
+
+	NL80211_ATTR_PROTOCOL_FEATURES,
+	NL80211_ATTR_SPLIT_WIPHY_DUMP,
+
+	NL80211_ATTR_DISABLE_VHT,
+	NL80211_ATTR_VHT_CAPABILITY_MASK,
+
+	NL80211_ATTR_MDID,
+	NL80211_ATTR_IE_RIC,
+
+	NL80211_ATTR_CRIT_PROT_ID,
+	NL80211_ATTR_MAX_CRIT_PROT_DURATION,
+
+	/* leave some room for new attributes in nl80211 updates */
+	NL80211_ATTR_IM_SCAN_RESULT = NL80211_ATTR_IE_RIC + 40,
+	NL80211_ATTR_IM_SCAN_RESULT_MIN_RSSI,
+
+	NL80211_ATTR_SCAN_MIN_DWELL,
+	NL80211_ATTR_SCAN_MAX_DWELL,
+	NL80211_ATTR_SCAN_NUM_PROBE,
+
+	NL80211_ATTR_SCHED_SCAN_SHORT_INTERVAL,
+	NL80211_ATTR_SCHED_SCAN_NUM_SHORT_INTERVALS,
+
+	NL80211_ATTR_ROAMING_DISABLED,
+	NL80211_ATTR_CH_SWITCH_COUNT,
+	NL80211_ATTR_CH_SWITCH_BLOCK_TX,
+	NL80211_ATTR_CH_SWITCH_POST_BLOCK_TX,
+
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
@@ -1672,6 +1944,9 @@
  *	flag can't be changed, it is only valid while adding a station, and
  *	attempts to change it will silently be ignored (rather than rejected
  *	as errors.)
+ * @NL80211_STA_FLAG_ASSOCIATED: station is associated; used with drivers
+ *	that support %NL80211_FEATURE_FULL_AP_CLIENT_STATE to transition a
+ *	previously added station into associated state
  * @NL80211_STA_FLAG_MAX: highest station flag number currently defined
  * @__NL80211_STA_FLAG_AFTER_LAST: internal use
  */
@@ -1683,6 +1958,7 @@
 	NL80211_STA_FLAG_MFP,
 	NL80211_STA_FLAG_AUTHENTICATED,
 	NL80211_STA_FLAG_TDLS_PEER,
+	NL80211_STA_FLAG_ASSOCIATED,
 
 	/* keep last */
 	__NL80211_STA_FLAG_AFTER_LAST,
@@ -1719,10 +1995,15 @@
  * @__NL80211_RATE_INFO_INVALID: attribute number 0 is reserved
  * @NL80211_RATE_INFO_BITRATE: total bitrate (u16, 100kbit/s)
  * @NL80211_RATE_INFO_MCS: mcs index for 802.11n (u8)
- * @NL80211_RATE_INFO_40_MHZ_WIDTH: 40 Mhz dualchannel bitrate
+ * @NL80211_RATE_INFO_40_MHZ_WIDTH: 40 MHz dualchannel bitrate
  * @NL80211_RATE_INFO_SHORT_GI: 400ns guard interval
  * @NL80211_RATE_INFO_BITRATE32: total bitrate (u32, 100kbit/s)
  * @NL80211_RATE_INFO_MAX: highest rate_info number currently defined
+ * @NL80211_RATE_INFO_VHT_MCS: MCS index for VHT (u8)
+ * @NL80211_RATE_INFO_VHT_NSS: number of streams in VHT (u8)
+ * @NL80211_RATE_INFO_80_MHZ_WIDTH: 80 MHz VHT rate
+ * @NL80211_RATE_INFO_80P80_MHZ_WIDTH: 80+80 MHz VHT rate
+ * @NL80211_RATE_INFO_160_MHZ_WIDTH: 160 MHz VHT rate
  * @__NL80211_RATE_INFO_AFTER_LAST: internal use
  */
 enum nl80211_rate_info {
@@ -1732,6 +2013,11 @@
 	NL80211_RATE_INFO_40_MHZ_WIDTH,
 	NL80211_RATE_INFO_SHORT_GI,
 	NL80211_RATE_INFO_BITRATE32,
+	NL80211_RATE_INFO_VHT_MCS,
+	NL80211_RATE_INFO_VHT_NSS,
+	NL80211_RATE_INFO_80_MHZ_WIDTH,
+	NL80211_RATE_INFO_80P80_MHZ_WIDTH,
+	NL80211_RATE_INFO_160_MHZ_WIDTH,
 
 	/* keep last */
 	__NL80211_RATE_INFO_AFTER_LAST,
@@ -1778,6 +2064,8 @@
  * @NL80211_STA_INFO_INACTIVE_TIME: time since last activity (u32, msecs)
  * @NL80211_STA_INFO_RX_BYTES: total received bytes (u32, from this station)
  * @NL80211_STA_INFO_TX_BYTES: total transmitted bytes (u32, to this station)
+ * @NL80211_STA_INFO_RX_BYTES64: total received bytes (u64, from this station)
+ * @NL80211_STA_INFO_TX_BYTES64: total transmitted bytes (u64, to this station)
  * @NL80211_STA_INFO_SIGNAL: signal strength of last received PPDU (u8, dBm)
  * @NL80211_STA_INFO_TX_BITRATE: current unicast tx rate, nested attribute
  * 	containing info as possible, see &enum nl80211_rate_info
@@ -1799,6 +2087,10 @@
  * @NL80211_STA_INFO_STA_FLAGS: Contains a struct nl80211_sta_flag_update.
  * @NL80211_STA_INFO_BEACON_LOSS: count of times beacon loss was detected (u32)
  * @NL80211_STA_INFO_T_OFFSET: timing offset with respect to this STA (s64)
+ * @NL80211_STA_INFO_LOCAL_PM: local mesh STA link-specific power mode
+ * @NL80211_STA_INFO_PEER_PM: peer mesh STA link-specific power mode
+ * @NL80211_STA_INFO_NONPEER_PM: neighbor mesh STA power save mode towards
+ *	non-peer STA
  * @__NL80211_STA_INFO_AFTER_LAST: internal
  * @NL80211_STA_INFO_MAX: highest possible station info attribute
  */
@@ -1823,6 +2115,11 @@
 	NL80211_STA_INFO_STA_FLAGS,
 	NL80211_STA_INFO_BEACON_LOSS,
 	NL80211_STA_INFO_T_OFFSET,
+	NL80211_STA_INFO_LOCAL_PM,
+	NL80211_STA_INFO_PEER_PM,
+	NL80211_STA_INFO_NONPEER_PM,
+	NL80211_STA_INFO_RX_BYTES64,
+	NL80211_STA_INFO_TX_BYTES64,
 
 	/* keep last */
 	__NL80211_STA_INFO_AFTER_LAST,
@@ -1932,6 +2229,20 @@
  *	on this channel in current regulatory domain.
  * @NL80211_FREQUENCY_ATTR_MAX_TX_POWER: Maximum transmission power in mBm
  *	(100 * dBm).
+ * @NL80211_FREQUENCY_ATTR_DFS_STATE: current state for DFS
+ *	(enum nl80211_dfs_state)
+ * @NL80211_FREQUENCY_ATTR_DFS_TIME: time in miliseconds for how long
+ *	this channel is in this DFS state.
+ * @NL80211_FREQUENCY_ATTR_NO_HT40_MINUS: HT40- isn't possible with this
+ *	channel as the control channel
+ * @NL80211_FREQUENCY_ATTR_NO_HT40_PLUS: HT40+ isn't possible with this
+ *	channel as the control channel
+ * @NL80211_FREQUENCY_ATTR_NO_80MHZ: any 80 MHz channel using this channel
+ *	as the primary or any of the secondary channels isn't possible,
+ *	this includes 80+80 channels
+ * @NL80211_FREQUENCY_ATTR_NO_160MHZ: any 160 MHz (but not 80+80) channel
+ *	using this channel as the primary or any of the secondary channels
+ *	isn't possible
  * @NL80211_FREQUENCY_ATTR_MAX: highest frequency attribute number
  *	currently defined
  * @__NL80211_FREQUENCY_ATTR_AFTER_LAST: internal use
@@ -1944,6 +2255,12 @@
 	NL80211_FREQUENCY_ATTR_NO_IBSS,
 	NL80211_FREQUENCY_ATTR_RADAR,
 	NL80211_FREQUENCY_ATTR_MAX_TX_POWER,
+	NL80211_FREQUENCY_ATTR_DFS_STATE,
+	NL80211_FREQUENCY_ATTR_DFS_TIME,
+	NL80211_FREQUENCY_ATTR_NO_HT40_MINUS,
+	NL80211_FREQUENCY_ATTR_NO_HT40_PLUS,
+	NL80211_FREQUENCY_ATTR_NO_80MHZ,
+	NL80211_FREQUENCY_ATTR_NO_160MHZ,
 
 	/* keep last */
 	__NL80211_FREQUENCY_ATTR_AFTER_LAST,
@@ -2214,6 +2531,34 @@
 };
 
 /**
+ * enum nl80211_mesh_power_mode - mesh power save modes
+ *
+ * @NL80211_MESH_POWER_UNKNOWN: The mesh power mode of the mesh STA is
+ *	not known or has not been set yet.
+ * @NL80211_MESH_POWER_ACTIVE: Active mesh power mode. The mesh STA is
+ *	in Awake state all the time.
+ * @NL80211_MESH_POWER_LIGHT_SLEEP: Light sleep mode. The mesh STA will
+ *	alternate between Active and Doze states, but will wake up for
+ *	neighbor's beacons.
+ * @NL80211_MESH_POWER_DEEP_SLEEP: Deep sleep mode. The mesh STA will
+ *	alternate between Active and Doze states, but may not wake up
+ *	for neighbor's beacons.
+ *
+ * @__NL80211_MESH_POWER_AFTER_LAST - internal use
+ * @NL80211_MESH_POWER_MAX - highest possible power save level
+ */
+
+enum nl80211_mesh_power_mode {
+	NL80211_MESH_POWER_UNKNOWN,
+	NL80211_MESH_POWER_ACTIVE,
+	NL80211_MESH_POWER_LIGHT_SLEEP,
+	NL80211_MESH_POWER_DEEP_SLEEP,
+
+	__NL80211_MESH_POWER_AFTER_LAST,
+	NL80211_MESH_POWER_MAX = __NL80211_MESH_POWER_AFTER_LAST - 1
+};
+
+/**
  * enum nl80211_meshconf_params - mesh configuration parameters
  *
  * Mesh configuration parameters. These can be changed while the mesh is
@@ -2240,8 +2585,10 @@
  * @NL80211_MESHCONF_TTL: specifies the value of TTL field set at a source mesh
  *	point.
  *
- * @NL80211_MESHCONF_AUTO_OPEN_PLINKS: whether we should automatically
- *	open peer links when we detect compatible mesh peers.
+ * @NL80211_MESHCONF_AUTO_OPEN_PLINKS: whether we should automatically open
+ *	peer links when we detect compatible mesh peers. Disabled if
+ *	@NL80211_MESH_SETUP_USERSPACE_MPM or @NL80211_MESH_SETUP_USERSPACE_AMPE are
+ *	set.
  *
  * @NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES: the number of action frames
  *	containing a PREQ that an MP can send to a particular destination (path
@@ -2307,6 +2654,11 @@
  *	(in TUs) during which a mesh STA can send only one Action frame
  *	containing a PREQ element for root path confirmation.
  *
+ * @NL80211_MESHCONF_POWER_MODE: Default mesh power mode for new peer links.
+ *	type &enum nl80211_mesh_power_mode (u32)
+ *
+ * @NL80211_MESHCONF_AWAKE_WINDOW: awake window duration (in TUs)
+ *
  * @__NL80211_MESHCONF_ATTR_AFTER_LAST: internal use
  */
 enum nl80211_meshconf_params {
@@ -2336,6 +2688,8 @@
 	NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT,
 	NL80211_MESHCONF_HWMP_ROOT_INTERVAL,
 	NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL,
+	NL80211_MESHCONF_POWER_MODE,
+	NL80211_MESHCONF_AWAKE_WINDOW,
 
 	/* keep last */
 	__NL80211_MESHCONF_ATTR_AFTER_LAST,
@@ -2380,6 +2734,9 @@
  *	vendor specific synchronization method or disable it to use the default
  *	neighbor offset synchronization
  *
+ * @NL80211_MESH_SETUP_USERSPACE_MPM: Enable this option if userspace will
+ *	implement an MPM which handles peer allocation and state.
+ *
  * @NL80211_MESH_SETUP_ATTR_MAX: highest possible mesh setup attribute number
  *
  * @__NL80211_MESH_SETUP_ATTR_AFTER_LAST: Internal use
@@ -2392,6 +2749,7 @@
 	NL80211_MESH_SETUP_USERSPACE_AUTH,
 	NL80211_MESH_SETUP_USERSPACE_AMPE,
 	NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC,
+	NL80211_MESH_SETUP_USERSPACE_MPM,
 
 	/* keep last */
 	__NL80211_MESH_SETUP_ATTR_AFTER_LAST,
@@ -2440,6 +2798,15 @@
 #define NL80211_TXQ_Q_BE	NL80211_AC_BE
 #define NL80211_TXQ_Q_BK	NL80211_AC_BK
 
+/**
+ * enum nl80211_channel_type - channel type
+ * @NL80211_CHAN_NO_HT: 20 MHz, non-HT channel
+ * @NL80211_CHAN_HT20: 20 MHz HT channel
+ * @NL80211_CHAN_HT40MINUS: HT40 channel, secondary channel
+ *	below the control channel
+ * @NL80211_CHAN_HT40PLUS: HT40 channel, secondary channel
+ *	above the control channel
+ */
 enum nl80211_channel_type {
 	NL80211_CHAN_NO_HT,
 	NL80211_CHAN_HT20,
@@ -2448,6 +2815,32 @@
 };
 
 /**
+ * enum nl80211_chan_width - channel width definitions
+ *
+ * These values are used with the %NL80211_ATTR_CHANNEL_WIDTH
+ * attribute.
+ *
+ * @NL80211_CHAN_WIDTH_20_NOHT: 20 MHz, non-HT channel
+ * @NL80211_CHAN_WIDTH_20: 20 MHz HT channel
+ * @NL80211_CHAN_WIDTH_40: 40 MHz channel, the %NL80211_ATTR_CENTER_FREQ1
+ *	attribute must be provided as well
+ * @NL80211_CHAN_WIDTH_80: 80 MHz channel, the %NL80211_ATTR_CENTER_FREQ1
+ *	attribute must be provided as well
+ * @NL80211_CHAN_WIDTH_80P80: 80+80 MHz channel, the %NL80211_ATTR_CENTER_FREQ1
+ *	and %NL80211_ATTR_CENTER_FREQ2 attributes must be provided as well
+ * @NL80211_CHAN_WIDTH_160: 160 MHz channel, the %NL80211_ATTR_CENTER_FREQ1
+ *	attribute must be provided as well
+ */
+enum nl80211_chan_width {
+	NL80211_CHAN_WIDTH_20_NOHT,
+	NL80211_CHAN_WIDTH_20,
+	NL80211_CHAN_WIDTH_40,
+	NL80211_CHAN_WIDTH_80,
+	NL80211_CHAN_WIDTH_80P80,
+	NL80211_CHAN_WIDTH_160,
+};
+
+/**
  * enum nl80211_bss - netlink attributes for a BSS
  *
  * @__NL80211_BSS_INVALID: invalid
@@ -2746,10 +3139,20 @@
  *	corresponds to the lowest-order bit in the second byte of the mask.
  *	For example: The match 00:xx:00:00:xx:00:00:00:00:xx:xx:xx (where
  *	xx indicates "don't care") would be represented by a pattern of
- *	twelve zero bytes, and a mask of "0xed,0x07".
+ *	twelve zero bytes, and a mask of "0xed,0x01".
  *	Note that the pattern matching is done as though frames were not
  *	802.11 frames but 802.3 frames, i.e. the frame is fully unpacked
  *	first (including SNAP header unpacking) and then matched.
+ * @NL80211_WOWLAN_PKTPAT_OFFSET: packet offset, pattern is matched after
+ *	these fixed number of bytes of received packet
+ *
+ * @NL80211_WOWLAN_ACTION: pattern action which can be either to wake up
+ *      on this pattern or drop it and avoid wake up. This can be used to
+ *      specify an excpetion/blacklist pattern that shouldn't cause wakeup
+ *      despite the packet matching another wowlan pattern. For example:
+ *      configure all IPv4 multicast to wake up except certain type of packets
+ *      This can be either NL80211_WOWLAN_ACTION_ALLOW or DROP.
+ *      If this attribute is missing the default would be ALLOW.
  * @NUM_NL80211_WOWLAN_PKTPAT: number of attributes
  * @MAX_NL80211_WOWLAN_PKTPAT: max attribute number
  */
@@ -2757,16 +3160,37 @@
 	__NL80211_WOWLAN_PKTPAT_INVALID,
 	NL80211_WOWLAN_PKTPAT_MASK,
 	NL80211_WOWLAN_PKTPAT_PATTERN,
+	NL80211_WOWLAN_PKTPAT_OFFSET,
+	NL80211_WOWLAN_PKTPAT_ACTION = NL80211_WOWLAN_PKTPAT_PATTERN + 10,
 
 	NUM_NL80211_WOWLAN_PKTPAT,
 	MAX_NL80211_WOWLAN_PKTPAT = NUM_NL80211_WOWLAN_PKTPAT - 1,
 };
 
+
+/**
+ * enum nl80211_wowlan_action - WoWLAN packet pattern action
+ * @NL80211_WOWLAN_ACTION_ALLOW: this pattern should wake up the host
+ * and the packet should be forwarded to the host unless this packet
+ * matches a DROP rule.
+ * @NL80211_WOWLAN_ACTION_DROP: a packet containing this pattern shouldn't
+ * wake up the host.
+ */
+enum nl80211_wowlan_action {
+	NL80211_WOWLAN_ACTION_ALLOW,
+	NL80211_WOWLAN_ACTION_DROP,
+
+	/* keep last */
+	NUM_NL80211_WOWLAN_ACTION,
+	MAX_NL80211_WOWLAN_ACTION = NUM_NL80211_WOWLAN_ACTION - 1,
+};
+
 /**
  * struct nl80211_wowlan_pattern_support - pattern support information
  * @max_patterns: maximum number of patterns supported
  * @min_pattern_len: minimum length of each pattern
  * @max_pattern_len: maximum length of each pattern
+ * @max_pkt_offset: maximum Rx packet offset
  *
  * This struct is carried in %NL80211_WOWLAN_TRIG_PKT_PATTERN when
  * that is part of %NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED in the
@@ -2776,6 +3200,7 @@
 	__u32 max_patterns;
 	__u32 min_pattern_len;
 	__u32 max_pattern_len;
+	__u32 max_pkt_offset;
 } __attribute__((packed));
 
 /**
@@ -2791,12 +3216,17 @@
  * @NL80211_WOWLAN_TRIG_PKT_PATTERN: wake up on the specified packet patterns
  *	which are passed in an array of nested attributes, each nested attribute
  *	defining a with attributes from &struct nl80211_wowlan_trig_pkt_pattern.
- *	Each pattern defines a wakeup packet. The matching is done on the MSDU,
- *	i.e. as though the packet was an 802.3 packet, so the pattern matching
- *	is done after the packet is converted to the MSDU.
+ *	Each pattern defines a wakeup packet. Packet offset is associated with
+ *	each pattern which is used while matching the pattern. The matching is
+ *	done on the MSDU, i.e. as though the packet was an 802.3 packet, so the
+ *	pattern matching is done after the packet is converted to the MSDU.
  *
  *	In %NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED, it is a binary attribute
  *	carrying a &struct nl80211_wowlan_pattern_support.
+ *
+ *	When reporting wakeup. it is a u32 attribute containing the 0-based
+ *	index of the pattern that caused the wakeup, in the patterns passed
+ *	to the kernel when configuring.
  * @NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED: Not a real trigger, and cannot be
  *	used when setting, used only to indicate that GTK rekeying is supported
  *	by the device (flag)
@@ -2807,8 +3237,36 @@
  * @NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE: wake up on 4-way handshake (flag)
  * @NL80211_WOWLAN_TRIG_RFKILL_RELEASE: wake up when rfkill is released
  *	(on devices that have rfkill in the device) (flag)
+ * @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211: For wakeup reporting only, contains
+ *	the 802.11 packet that caused the wakeup, e.g. a deauth frame. The frame
+ *	may be truncated, the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN
+ *	attribute contains the original length.
+ * @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN: Original length of the 802.11
+ *	packet, may be bigger than the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211
+ *	attribute if the packet was truncated somewhere.
+ * @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023: For wakeup reporting only, contains the
+ *	802.11 packet that caused the wakeup, e.g. a magic packet. The frame may
+ *	be truncated, the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN attribute
+ *	contains the original length.
+ * @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN: Original length of the 802.3
+ *	packet, may be bigger than the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023
+ *	attribute if the packet was truncated somewhere.
+ * @NL80211_WOWLAN_TRIG_TCP_CONNECTION: TCP connection wake, see DOC section
+ *	"TCP connection wakeup" for more details. This is a nested attribute
+ *	containing the exact information for establishing and keeping alive
+ *	the TCP connection.
+ * @NL80211_WOWLAN_TRIG_TCP_WAKEUP_MATCH: For wakeup reporting only, the
+ *	wakeup packet was received on the TCP connection
+ * @NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST: For wakeup reporting only, the
+ *	TCP connection was lost or failed to be established
+ * @NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS: For wakeup reporting only,
+ *	the TCP connection ran out of tokens to use for data to send to the
+ *	service
  * @NUM_NL80211_WOWLAN_TRIG: number of wake on wireless triggers
  * @MAX_NL80211_WOWLAN_TRIG: highest wowlan trigger attribute number
+ *
+ * These nested attributes are used to configure the wakeup triggers and
+ * to report the wakeup reason(s).
  */
 enum nl80211_wowlan_triggers {
 	__NL80211_WOWLAN_TRIG_INVALID,
@@ -2821,6 +3279,14 @@
 	NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST,
 	NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE,
 	NL80211_WOWLAN_TRIG_RFKILL_RELEASE,
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211,
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN,
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023,
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN,
+	NL80211_WOWLAN_TRIG_TCP_CONNECTION,
+	NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH,
+	NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST,
+	NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS,
 
 	/* keep last */
 	NUM_NL80211_WOWLAN_TRIG,
@@ -2828,6 +3294,116 @@
 };
 
 /**
+ * DOC: TCP connection wakeup
+ *
+ * Some devices can establish a TCP connection in order to be woken up by a
+ * packet coming in from outside their network segment, or behind NAT. If
+ * configured, the device will establish a TCP connection to the given
+ * service, and periodically send data to that service. The first data
+ * packet is usually transmitted after SYN/ACK, also ACKing the SYN/ACK.
+ * The data packets can optionally include a (little endian) sequence
+ * number (in the TCP payload!) that is generated by the device, and, also
+ * optionally, a token from a list of tokens. This serves as a keep-alive
+ * with the service, and for NATed connections, etc.
+ *
+ * During this keep-alive period, the server doesn't send any data to the
+ * client. When receiving data, it is compared against the wakeup pattern
+ * (and mask) and if it matches, the host is woken up. Similarly, if the
+ * connection breaks or cannot be established to start with, the host is
+ * also woken up.
+ *
+ * Developer's note: ARP offload is required for this, otherwise TCP
+ * response packets might not go through correctly.
+ */
+
+/**
+ * struct nl80211_wowlan_tcp_data_seq - WoWLAN TCP data sequence
+ * @start: starting value
+ * @offset: offset of sequence number in packet
+ * @len: length of the sequence value to write, 1 through 4
+ *
+ * Note: don't confuse with the TCP sequence number(s), this is for the
+ * keepalive packet payload. The actual value is written into the packet
+ * in little endian.
+ */
+struct nl80211_wowlan_tcp_data_seq {
+	__u32 start, offset, len;
+};
+
+/**
+ * struct nl80211_wowlan_tcp_data_token - WoWLAN TCP data token config
+ * @offset: offset of token in packet
+ * @len: length of each token
+ * @token_stream: stream of data to be used for the tokens, the length must
+ *	be a multiple of @len for this to make sense
+ */
+struct nl80211_wowlan_tcp_data_token {
+	__u32 offset, len;
+	__u8 token_stream[];
+};
+
+/**
+ * struct nl80211_wowlan_tcp_data_token_feature - data token features
+ * @min_len: minimum token length
+ * @max_len: maximum token length
+ * @bufsize: total available token buffer size (max size of @token_stream)
+ */
+struct nl80211_wowlan_tcp_data_token_feature {
+	__u32 min_len, max_len, bufsize;
+};
+
+/**
+ * enum nl80211_wowlan_tcp_attrs - WoWLAN TCP connection parameters
+ * @__NL80211_WOWLAN_TCP_INVALID: invalid number for nested attributes
+ * @NL80211_WOWLAN_TCP_SRC_IPV4: source IPv4 address (in network byte order)
+ * @NL80211_WOWLAN_TCP_DST_IPV4: destination IPv4 address
+ *	(in network byte order)
+ * @NL80211_WOWLAN_TCP_DST_MAC: destination MAC address, this is given because
+ *	route lookup when configured might be invalid by the time we suspend,
+ *	and doing a route lookup when suspending is no longer possible as it
+ *	might require ARP querying.
+ * @NL80211_WOWLAN_TCP_SRC_PORT: source port (u16); optional, if not given a
+ *	socket and port will be allocated
+ * @NL80211_WOWLAN_TCP_DST_PORT: destination port (u16)
+ * @NL80211_WOWLAN_TCP_DATA_PAYLOAD: data packet payload, at least one byte.
+ *	For feature advertising, a u32 attribute holding the maximum length
+ *	of the data payload.
+ * @NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ: data packet sequence configuration
+ *	(if desired), a &struct nl80211_wowlan_tcp_data_seq. For feature
+ *	advertising it is just a flag
+ * @NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN: data packet token configuration,
+ *	see &struct nl80211_wowlan_tcp_data_token and for advertising see
+ *	&struct nl80211_wowlan_tcp_data_token_feature.
+ * @NL80211_WOWLAN_TCP_DATA_INTERVAL: data interval in seconds, maximum
+ *	interval in feature advertising (u32)
+ * @NL80211_WOWLAN_TCP_WAKE_PAYLOAD: wake packet payload, for advertising a
+ *	u32 attribute holding the maximum length
+ * @NL80211_WOWLAN_TCP_WAKE_MASK: Wake packet payload mask, not used for
+ *	feature advertising. The mask works like @NL80211_WOWLAN_PKTPAT_MASK
+ *	but on the TCP payload only.
+ * @NUM_NL80211_WOWLAN_TCP: number of TCP attributes
+ * @MAX_NL80211_WOWLAN_TCP: highest attribute number
+ */
+enum nl80211_wowlan_tcp_attrs {
+	__NL80211_WOWLAN_TCP_INVALID,
+	NL80211_WOWLAN_TCP_SRC_IPV4,
+	NL80211_WOWLAN_TCP_DST_IPV4,
+	NL80211_WOWLAN_TCP_DST_MAC,
+	NL80211_WOWLAN_TCP_SRC_PORT,
+	NL80211_WOWLAN_TCP_DST_PORT,
+	NL80211_WOWLAN_TCP_DATA_PAYLOAD,
+	NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ,
+	NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN,
+	NL80211_WOWLAN_TCP_DATA_INTERVAL,
+	NL80211_WOWLAN_TCP_WAKE_PAYLOAD,
+	NL80211_WOWLAN_TCP_WAKE_MASK,
+
+	/* keep last */
+	NUM_NL80211_WOWLAN_TCP,
+	MAX_NL80211_WOWLAN_TCP = NUM_NL80211_WOWLAN_TCP - 1
+};
+
+/**
  * enum nl80211_iface_limit_attrs - limit attributes
  * @NL80211_IFACE_LIMIT_UNSPEC: (reserved)
  * @NL80211_IFACE_LIMIT_MAX: maximum number of interfaces that
@@ -2863,6 +3439,8 @@
  *	the infrastructure network's beacon interval.
  * @NL80211_IFACE_COMB_NUM_CHANNELS: u32 attribute specifying how many
  *	different channels may be used within this group.
+ * @NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS: u32 attribute containing the bitmap
+ *	of supported channel widths for radar detection.
  * @NUM_NL80211_IFACE_COMB: number of attributes
  * @MAX_NL80211_IFACE_COMB: highest attribute number
  *
@@ -2895,6 +3473,7 @@
 	NL80211_IFACE_COMB_MAXNUM,
 	NL80211_IFACE_COMB_STA_AP_BI_MATCH,
 	NL80211_IFACE_COMB_NUM_CHANNELS,
+	NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS,
 
 	/* keep last */
 	NUM_NL80211_IFACE_COMB,
@@ -2934,6 +3513,23 @@
 	MAX_NL80211_PLINK_STATES = NUM_NL80211_PLINK_STATES - 1
 };
 
+/**
+ * enum nl80211_plink_action - actions to perform in mesh peers
+ *
+ * @NL80211_PLINK_ACTION_NO_ACTION: perform no action
+ * @NL80211_PLINK_ACTION_OPEN: start mesh peer link establishment
+ * @NL80211_PLINK_ACTION_BLOCK: block traffic from this mesh peer
+ * @NUM_NL80211_PLINK_ACTIONS: number of possible actions
+ */
+enum plink_actions {
+	NL80211_PLINK_ACTION_NO_ACTION,
+	NL80211_PLINK_ACTION_OPEN,
+	NL80211_PLINK_ACTION_BLOCK,
+
+	NUM_NL80211_PLINK_ACTIONS,
+};
+
+
 #define NL80211_KCK_LEN			16
 #define NL80211_KEK_LEN			16
 #define NL80211_REPLAY_CTR_LEN		8
@@ -3066,6 +3662,28 @@
  * @NL80211_FEATURE_NEED_OBSS_SCAN: The driver expects userspace to perform
  *	OBSS scans and generate 20/40 BSS coex reports. This flag is used only
  *	for drivers implementing the CONNECT API, for AUTH/ASSOC it is implied.
+ * @NL80211_FEATURE_P2P_GO_CTWIN: P2P GO implementation supports CT Window
+ *	setting
+ * @NL80211_FEATURE_P2P_GO_OPPPS: P2P GO implementation supports opportunistic
+ *	powersave
+ * @NL80211_FEATURE_FULL_AP_CLIENT_STATE: The driver supports full state
+ *	transitions for AP clients. Without this flag (and if the driver
+ *	doesn't have the AP SME in the device) the driver supports adding
+ *	stations only when they're associated and adds them in associated
+ *	state (to later be transitioned into authorized), with this flag
+ *	they should be added before even sending the authentication reply
+ *	and then transitioned into authenticated, associated and authorized
+ *	states using station flags.
+ *	Note that even for drivers that support this, the default is to add
+ *	stations in authenticated/associated state, so to add unauthenticated
+ *	stations the authenticated/associated bits have to be set in the mask.
+ * @NL80211_FEATURE_ADVERTISE_CHAN_LIMITS: cfg80211 advertises channel limits
+ *	(HT40, VHT 80/160 MHz) if this flag is set
+ * @NL80211_FEATURE_USERSPACE_MPM: This driver supports a userspace Mesh
+ *	Peering Management entity which may be implemented by registering for
+ *	beacons or NL80211_CMD_NEW_PEER_CANDIDATE events. The mesh beacon is
+ *	still generated by the driver.
+ * @NL80211_FEATURE_AP_CH_SWITCH: This driver supports AP channel switch.
  */
 enum nl80211_feature_flags {
 	NL80211_FEATURE_SK_TX_STATUS			= 1 << 0,
@@ -3079,6 +3697,14 @@
 	NL80211_FEATURE_AP_SCAN				= 1 << 8,
 	NL80211_FEATURE_VIF_TXPOWER			= 1 << 9,
 	NL80211_FEATURE_NEED_OBSS_SCAN			= 1 << 10,
+	NL80211_FEATURE_P2P_GO_CTWIN			= 1 << 11,
+	NL80211_FEATURE_P2P_GO_OPPPS			= 1 << 12,
+	/* bit 13 is reserved */
+	NL80211_FEATURE_ADVERTISE_CHAN_LIMITS		= 1 << 14,
+	NL80211_FEATURE_FULL_AP_CLIENT_STATE		= 1 << 15,
+	NL80211_FEATURE_USERSPACE_MPM			= 1 << 16,
+	NL80211_FEATURE_SCHED_SCAN_INTERVALS  = 1 << 20,
+	NL80211_FEATURE_AP_CH_SWITCH	= 1 << 21,
 };
 
 /**
@@ -3106,7 +3732,7 @@
  * enum nl80211_connect_failed_reason - connection request failed reasons
  * @NL80211_CONN_FAIL_MAX_CLIENTS: Maximum number of clients that can be
  *	handled by the AP is reached.
- * @NL80211_CONN_FAIL_BLOCKED_CLIENT: Client's MAC is in the AP's blocklist.
+ * @NL80211_CONN_FAIL_BLOCKED_CLIENT: Connection request is rejected due to ACL.
  */
 enum nl80211_connect_failed_reason {
 	NL80211_CONN_FAIL_MAX_CLIENTS,
@@ -3134,4 +3760,95 @@
 	NL80211_SCAN_FLAG_AP				= 1<<2,
 };
 
+/**
+ * enum nl80211_acl_policy - access control policy
+ *
+ * Access control policy is applied on a MAC list set by
+ * %NL80211_CMD_START_AP and %NL80211_CMD_SET_MAC_ACL, to
+ * be used with %NL80211_ATTR_ACL_POLICY.
+ *
+ * @NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED: Deny stations which are
+ *	listed in ACL, i.e. allow all the stations which are not listed
+ *	in ACL to authenticate.
+ * @NL80211_ACL_POLICY_DENY_UNLESS_LISTED: Allow the stations which are listed
+ *	in ACL, i.e. deny all the stations which are not listed in ACL.
+ */
+enum nl80211_acl_policy {
+	NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED,
+	NL80211_ACL_POLICY_DENY_UNLESS_LISTED,
+};
+
+/**
+ * enum nl80211_radar_event - type of radar event for DFS operation
+ *
+ * Type of event to be used with NL80211_ATTR_RADAR_EVENT to inform userspace
+ * about detected radars or success of the channel available check (CAC)
+ *
+ * @NL80211_RADAR_DETECTED: A radar pattern has been detected. The channel is
+ *	now unusable.
+ * @NL80211_RADAR_CAC_FINISHED: Channel Availability Check has been finished,
+ *	the channel is now available.
+ * @NL80211_RADAR_CAC_ABORTED: Channel Availability Check has been aborted, no
+ *	change to the channel status.
+ * @NL80211_RADAR_NOP_FINISHED: The Non-Occupancy Period for this channel is
+ *	over, channel becomes usable.
+ */
+enum nl80211_radar_event {
+	NL80211_RADAR_DETECTED,
+	NL80211_RADAR_CAC_FINISHED,
+	NL80211_RADAR_CAC_ABORTED,
+	NL80211_RADAR_NOP_FINISHED,
+};
+
+/**
+ * enum nl80211_dfs_state - DFS states for channels
+ *
+ * Channel states used by the DFS code.
+ *
+ * @IEEE80211_DFS_USABLE: The channel can be used, but channel availability
+ *	check (CAC) must be performed before using it for AP or IBSS.
+ * @IEEE80211_DFS_UNAVAILABLE: A radar has been detected on this channel, it
+ *	is therefore marked as not available.
+ * @IEEE80211_DFS_AVAILABLE: The channel has been CAC checked and is available.
+ */
+
+enum nl80211_dfs_state {
+	NL80211_DFS_USABLE,
+	NL80211_DFS_UNAVAILABLE,
+	NL80211_DFS_AVAILABLE,
+};
+
+/**
+ * enum enum nl80211_protocol_features - nl80211 protocol features
+ * @NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP: nl80211 supports splitting
+ *	wiphy dumps (if requested by the application with the attribute
+ *	%NL80211_ATTR_SPLIT_WIPHY_DUMP. Also supported is filtering the
+ *	wiphy dump by %NL80211_ATTR_WIPHY, %NL80211_ATTR_IFINDEX or
+ *	%NL80211_ATTR_WDEV.
+ */
+enum nl80211_protocol_features {
+	NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP =	1 << 0,
+};
+
+/**
+ * enum nl80211_crit_proto_id - nl80211 critical protocol identifiers
+ *
+ * @NL80211_CRIT_PROTO_UNSPEC: protocol unspecified.
+ * @NL80211_CRIT_PROTO_DHCP: BOOTP or DHCPv6 protocol.
+ * @NL80211_CRIT_PROTO_EAPOL: EAPOL protocol.
+ * @NL80211_CRIT_PROTO_APIPA: APIPA protocol.
+ * @NUM_NL80211_CRIT_PROTO: must be kept last.
+ */
+enum nl80211_crit_proto_id {
+	NL80211_CRIT_PROTO_UNSPEC,
+	NL80211_CRIT_PROTO_DHCP,
+	NL80211_CRIT_PROTO_EAPOL,
+	NL80211_CRIT_PROTO_APIPA,
+	/* add other protocols before this one */
+	NUM_NL80211_CRIT_PROTO
+};
+
+/* maximum duration for critical protocol measures */
+#define NL80211_CRIT_PROTO_MAX_DURATION		5000 /* msec */
+
 #endif /* __LINUX_NL80211_H */
diff -Nur hostapd-2.0/src/drivers/testmode_copy.h hostapd-2.0-TI/src/drivers/testmode_copy.h
--- hostapd-2.0/src/drivers/testmode_copy.h	1970-01-01 08:00:00.000000000 +0800
+++ hostapd-2.0-TI/src/drivers/testmode_copy.h	2014-03-28 17:49:34.000000000 +0800
@@ -0,0 +1,75 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2010 Nokia Corporation
+ *
+ * Contact: Luciano Coelho <luciano.coelho@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __TESTMODE_H__
+#define __TESTMODE_H__
+
+#ifdef __KERNEL__
+#include <net/mac80211.h>
+
+int wl1271_tm_cmd(struct ieee80211_hw *hw, void *data, int len);
+#endif
+
+enum wl1271_tm_commands {
+	WL1271_TM_CMD_UNSPEC,
+	WL1271_TM_CMD_TEST,
+	WL1271_TM_CMD_INTERROGATE,
+	WL1271_TM_CMD_CONFIGURE,
+	WL1271_TM_CMD_NVS_PUSH,		/* Not in use. Keep to not break ABI */
+	WL1271_TM_CMD_SET_PLT_MODE,
+	WL1271_TM_CMD_RECOVER,		/* Not in use. Keep to not break ABI */
+	WL1271_TM_CMD_GET_MAC,
+
+	WL1271_TM_CMD_SMART_CONFIG_START,
+	WL1271_TM_CMD_SMART_CONFIG_STOP,
+	WL1271_TM_CMD_SMART_CONFIG_SET_GROUP_KEY,
+
+	__WL1271_TM_CMD_AFTER_LAST
+};
+#define WL1271_TM_CMD_MAX (__WL1271_TM_CMD_AFTER_LAST - 1)
+
+enum wl1271_tm_attrs {
+	WL1271_TM_ATTR_UNSPEC,
+	WL1271_TM_ATTR_CMD_ID,
+	WL1271_TM_ATTR_ANSWER,
+	WL1271_TM_ATTR_DATA,
+	WL1271_TM_ATTR_IE_ID,
+	WL1271_TM_ATTR_PLT_MODE,
+
+	WL1271_TM_ATTR_SMART_CONFIG_EVENT,
+	WL1271_TM_ATTR_FREQ,
+	WL1271_TM_ATTR_PSK,
+	WL1271_TM_ATTR_SSID,
+	WL1271_TM_ATTR_GROUP_ID,
+	WL1271_TM_ATTR_GROUP_KEY,
+
+	__WL1271_TM_ATTR_AFTER_LAST
+};
+#define WL1271_TM_ATTR_MAX (__WL1271_TM_ATTR_AFTER_LAST - 1)
+
+enum wlcore_tm_attr_smart_config_event {
+	WLCORE_TM_SC_EVENT_SYNC,
+	WLCORE_TM_SC_EVENT_DECODE,
+};
+
+#endif /* __WL1271_TESTMODE_H__ */
diff -Nur hostapd-2.0/src/eap_peer/eap_fast_pac.c hostapd-2.0-TI/src/eap_peer/eap_fast_pac.c
--- hostapd-2.0/src/eap_peer/eap_fast_pac.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/eap_peer/eap_fast_pac.c	2014-03-28 17:49:32.000000000 +0800
@@ -422,12 +422,8 @@
 	if (eap_fast_init_pac_data(sm, pac_file, &rc) < 0)
 		return 0;
 
-	if (eap_fast_read_line(&rc, &pos) < 0) {
-		/* empty file - assume it is fine to overwrite */
-		eap_fast_deinit_pac_data(&rc);
-		return 0;
-	}
-	if (os_strcmp(pac_file_hdr, rc.buf) != 0)
+	if (eap_fast_read_line(&rc, &pos) < 0 ||
+	    os_strcmp(pac_file_hdr, rc.buf) != 0)
 		err = "Unrecognized header line";
 
 	while (!err && eap_fast_read_line(&rc, &pos) == 0) {
diff -Nur hostapd-2.0/src/eap_server/eap_server_aka.c hostapd-2.0-TI/src/eap_server/eap_server_aka.c
--- hostapd-2.0/src/eap_server/eap_server_aka.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/eap_server/eap_server_aka.c	2014-03-28 17:49:34.000000000 +0800
@@ -731,17 +731,6 @@
 		return;
 	}
 
-	if (((data->eap_method == EAP_TYPE_AKA_PRIME &&
-	      username[0] == EAP_AKA_PRIME_REAUTH_ID_PREFIX) ||
-	     (data->eap_method == EAP_TYPE_AKA &&
-	      username[0] == EAP_AKA_REAUTH_ID_PREFIX)) &&
-	    data->identity_round == 1) {
-		/* Remain in IDENTITY state for another round to request full
-		 * auth identity since we did not recognize reauth id */
-		os_free(username);
-		return;
-	}
-
 	if ((data->eap_method == EAP_TYPE_AKA_PRIME &&
 	     username[0] == EAP_AKA_PRIME_PSEUDONYM_PREFIX) ||
 	    (data->eap_method == EAP_TYPE_AKA &&
diff -Nur hostapd-2.0/src/p2p/p2p.c hostapd-2.0-TI/src/p2p/p2p.c
--- hostapd-2.0/src/p2p/p2p.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/p2p/p2p.c	2014-03-28 17:49:34.000000000 +0800
@@ -42,10 +42,40 @@
  * P2P_PEER_EXPIRATION_AGE - Number of seconds after which inactive peer
  * entries will be removed
  */
+#ifdef ANDROID_P2P
+#define P2P_PEER_EXPIRATION_AGE 30
+#else
 #define P2P_PEER_EXPIRATION_AGE 300
+#endif
 
 #define P2P_PEER_EXPIRATION_INTERVAL (P2P_PEER_EXPIRATION_AGE / 2)
 
+#ifdef ANDROID_P2P
+int p2p_connection_in_progress(struct p2p_data *p2p)
+{
+	int ret = 0;
+
+	switch (p2p->state) {
+		case P2P_CONNECT:
+		case P2P_CONNECT_LISTEN:
+		case P2P_GO_NEG:
+		case P2P_WAIT_PEER_CONNECT:
+		case P2P_WAIT_PEER_IDLE:
+		case P2P_PROVISIONING:
+		case P2P_INVITE:
+		case P2P_INVITE_LISTEN:
+			ret = 1;
+			break;
+
+		default:
+			wpa_printf(MSG_DEBUG, "p2p_connection_in_progress state %d", p2p->state);
+			ret = 0;
+	}
+
+	return ret;
+}
+#endif
+
 static void p2p_expire_peers(struct p2p_data *p2p)
 {
 	struct p2p_device *dev, *n;
@@ -82,8 +112,20 @@
 			continue;
 		}
 
-		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG, "P2P: Expiring old peer "
+#ifdef ANDROID_P2P
+		/* If Connection is in progress, don't expire the peer
+		*/
+		if (p2p_connection_in_progress(p2p))
+			continue;
+#endif
+
+		wpa_msg(p2p->cfg->msg_ctx, MSG_ERROR, "P2P: Expiring old peer "
 			"entry " MACSTR, MAC2STR(dev->info.p2p_device_addr));
+#ifdef ANDROID_P2P
+		/* SD_FAIR_POLICY: Update the current sd_dev_list pointer to next device */
+		if(&dev->list == p2p->sd_dev_list)
+			p2p->sd_dev_list = dev->list.next;
+#endif
 		dl_list_del(&dev->list);
 		p2p_device_free(p2p, dev);
 	}
@@ -391,6 +433,11 @@
 		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
 			"P2P: Remove oldest peer entry to make room for a new "
 			"peer");
+#ifdef ANDROID_P2P
+		/* SD_FAIR_POLICY: Update the current sd_dev_list pointer to next device */
+		if(&oldest->list == p2p->sd_dev_list)
+			p2p->sd_dev_list = oldest->list.next;
+#endif
 		dl_list_del(&oldest->list);
 		p2p_device_free(p2p, oldest);
 	}
@@ -568,7 +615,6 @@
 		dev->ext_listen_interval =
 			WPA_GET_LE16(msg->ext_listen_timing + 2);
 	}
-
 	if (!probe_req) {
 		dev->info.config_methods = msg->config_methods ?
 			msg->config_methods : msg->wps_config_methods;
@@ -583,7 +629,6 @@
  *	P2P Device Address or P2P Interface Address)
  * @level: Signal level (signal strength of the received frame from the peer)
  * @freq: Frequency on which the Beacon or Probe Response frame was received
- * @age_ms: Age of the information in milliseconds
  * @ies: IEs from the Beacon or Probe Response frame
  * @ies_len: Length of ies buffer in octets
  * @scan_res: Whether this was based on scan results
@@ -601,8 +646,9 @@
 	struct p2p_device *dev;
 	struct p2p_message msg;
 	const u8 *p2p_dev_addr;
-	int i;
+	int i, changed = 0;
 	struct os_time time_now, time_tmp_age, entry_ts;
+	enum p2p_go_state old_state;
 
 	os_memset(&msg, 0, sizeof(msg));
 	if (p2p_parse_ies(ies, ies_len, &msg)) {
@@ -629,7 +675,6 @@
 		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG, "P2P: Do not add peer "
 			"filter for " MACSTR " due to peer filter",
 			MAC2STR(p2p_dev_addr));
-		p2p_parse_free(&msg);
 		return 0;
 	}
 
@@ -648,11 +693,10 @@
 	 * Update the device entry only if the new peer
 	 * entry is newer than the one previously stored.
 	 */
+
 	if (dev->last_seen.usec > 0 &&
-	    os_time_before(&entry_ts, &dev->last_seen)) {
-		p2p_parse_free(&msg);
+	    os_time_before(&entry_ts, &dev->last_seen))
 		return -1;
-	}
 
 	os_memcpy(&dev->last_seen, &entry_ts, sizeof(struct os_time));
 
@@ -690,12 +734,22 @@
 			"results (" MACSTR " %d -> %d MHz (DS param %d)",
 			MAC2STR(dev->info.p2p_device_addr), dev->listen_freq,
 			freq, msg.ds_params ? *msg.ds_params : -1);
+		changed = 1;
 	}
+
 	if (scan_res) {
 		dev->listen_freq = freq;
 		if (msg.group_info)
 			dev->oper_freq = freq;
+
+		old_state = dev->go_state;
+		if (msg.group_info)
+			dev->go_state = REMOTE_GO;
+		else
+			dev->go_state = UNKNOWN_GO;
+		changed |= (old_state != dev->go_state);
 	}
+
 	dev->info.level = level;
 
 	p2p_copy_wps_info(dev, 0, &msg);
@@ -729,7 +783,7 @@
 	if (p2p_pending_sd_req(p2p, dev))
 		dev->flags |= P2P_DEV_SD_SCHEDULE;
 
-	if (dev->flags & P2P_DEV_REPORTED)
+	if ((dev->flags & P2P_DEV_REPORTED) && !changed)
 		return 0;
 
 	wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
@@ -912,7 +966,15 @@
 				      p2p->after_scan_tx->wait_time);
 		os_free(p2p->after_scan_tx);
 		p2p->after_scan_tx = NULL;
+#ifdef ANDROID_P2P
+		/* For SD frames, there is a scenario, where we can receive a SD request frame during p2p_scan.
+		 * At that moment, we will send the SD response from this context. After sending the SD response,
+		 * we need to continue p2p_find. But if we return 1 from here, p2p_find is going to be stopped.
+		 */
+		return 0;
+#else
 		return 1;
+#endif
 	}
 
 	op = p2p->start_after_scan;
@@ -1120,103 +1182,82 @@
 }
 
 
-static int p2p_prepare_channel_pref(struct p2p_data *p2p,
-				    unsigned int force_freq,
-				    unsigned int pref_freq)
-{
-	u8 op_class, op_channel;
-	unsigned int freq = force_freq ? force_freq : pref_freq;
-
-	if (p2p_freq_to_channel(p2p->cfg->country, freq,
-				&op_class, &op_channel) < 0) {
-		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
-			"P2P: Unsupported frequency %u MHz", freq);
-		return -1;
-	}
-
-	if (!p2p_channels_includes(&p2p->cfg->channels, op_class, op_channel)) {
-		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
-			"P2P: Frequency %u MHz (oper_class %u channel %u) not "
-			"allowed for P2P", freq, op_class, op_channel);
-		return -1;
-	}
-
-	p2p->op_reg_class = op_class;
-	p2p->op_channel = op_channel;
-
-	if (force_freq) {
-		p2p->channels.reg_classes = 1;
-		p2p->channels.reg_class[0].channels = 1;
-		p2p->channels.reg_class[0].reg_class = p2p->op_reg_class;
-		p2p->channels.reg_class[0].channel[0] = p2p->op_channel;
-	} else {
-		os_memcpy(&p2p->channels, &p2p->cfg->channels,
-			  sizeof(struct p2p_channels));
-	}
-
-	return 0;
-}
-
-
-static void p2p_prepare_channel_best(struct p2p_data *p2p)
+static int p2p_prepare_channel(struct p2p_data *p2p, unsigned int force_freq,
+			       unsigned int pref_freq)
 {
-	u8 op_class, op_channel;
-
-	if (!p2p->cfg->cfg_op_channel && p2p->best_freq_overall > 0 &&
-	    p2p_supported_freq(p2p, p2p->best_freq_overall) &&
-	    p2p_freq_to_channel(p2p->cfg->country, p2p->best_freq_overall,
-				&op_class, &op_channel) == 0) {
-		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG, "P2P: Select best "
-			"overall channel as operating channel preference");
-		p2p->op_reg_class = op_class;
-		p2p->op_channel = op_channel;
-	} else if (!p2p->cfg->cfg_op_channel && p2p->best_freq_5 > 0 &&
-		   p2p_supported_freq(p2p, p2p->best_freq_5) &&
-		   p2p_freq_to_channel(p2p->cfg->country, p2p->best_freq_5,
-				       &op_class, &op_channel) == 0) {
-		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG, "P2P: Select best 5 GHz "
-			"channel as operating channel preference");
-		p2p->op_reg_class = op_class;
-		p2p->op_channel = op_channel;
-	} else if (!p2p->cfg->cfg_op_channel && p2p->best_freq_24 > 0 &&
-		   p2p_supported_freq(p2p, p2p->best_freq_24) &&
-		   p2p_freq_to_channel(p2p->cfg->country, p2p->best_freq_24,
-				       &op_class, &op_channel) == 0) {
-		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG, "P2P: Select best 2.4 "
-			"GHz channel as operating channel preference");
-		p2p->op_reg_class = op_class;
+	if (force_freq || pref_freq) {
+		u8 op_reg_class, op_channel;
+		unsigned int freq = force_freq ? force_freq : pref_freq;
+		if (p2p_freq_to_channel(p2p->cfg->country, freq,
+					&op_reg_class, &op_channel) < 0) {
+			wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
+				"P2P: Unsupported frequency %u MHz",
+				freq);
+			return -1;
+		}
+		if (!p2p_channels_includes(&p2p->cfg->channels, op_reg_class,
+					   op_channel)) {
+			wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
+				"P2P: Frequency %u MHz (oper_class %u "
+				"channel %u) not allowed for P2P",
+				freq, op_reg_class, op_channel);
+			return -1;
+		}
+		p2p->op_reg_class = op_reg_class;
 		p2p->op_channel = op_channel;
+		if (force_freq) {
+			p2p->channels.reg_classes = 1;
+			p2p->channels.reg_class[0].channels = 1;
+			p2p->channels.reg_class[0].reg_class =
+				p2p->op_reg_class;
+			p2p->channels.reg_class[0].channel[0] = p2p->op_channel;
+		} else {
+			os_memcpy(&p2p->channels, &p2p->cfg->channels,
+				  sizeof(struct p2p_channels));
+		}
 	} else {
-		p2p->op_reg_class = p2p->cfg->op_reg_class;
-		p2p->op_channel = p2p->cfg->op_channel;
-	}
-
-	os_memcpy(&p2p->channels, &p2p->cfg->channels,
-		  sizeof(struct p2p_channels));
-}
+		u8 op_reg_class, op_channel;
 
+		if (!p2p->cfg->cfg_op_channel && p2p->best_freq_overall > 0 &&
+		    p2p_supported_freq(p2p, p2p->best_freq_overall) &&
+		    p2p_freq_to_channel(p2p->cfg->country,
+					p2p->best_freq_overall,
+					&op_reg_class, &op_channel) == 0) {
+			wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
+				"P2P: Select best overall channel as "
+				"operating channel preference");
+			p2p->op_reg_class = op_reg_class;
+			p2p->op_channel = op_channel;
+		} else if (!p2p->cfg->cfg_op_channel && p2p->best_freq_5 > 0 &&
+			   p2p_supported_freq(p2p, p2p->best_freq_5) &&
+			   p2p_freq_to_channel(p2p->cfg->country,
+					       p2p->best_freq_5,
+					       &op_reg_class, &op_channel) ==
+			   0) {
+			wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
+				"P2P: Select best 5 GHz channel as "
+				"operating channel preference");
+			p2p->op_reg_class = op_reg_class;
+			p2p->op_channel = op_channel;
+		} else if (!p2p->cfg->cfg_op_channel &&
+			   p2p->best_freq_24 > 0 &&
+			   p2p_supported_freq(p2p, p2p->best_freq_24) &&
+			   p2p_freq_to_channel(p2p->cfg->country,
+					       p2p->best_freq_24,
+					       &op_reg_class, &op_channel) ==
+			   0) {
+			wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
+				"P2P: Select best 2.4 GHz channel as "
+				"operating channel preference");
+			p2p->op_reg_class = op_reg_class;
+			p2p->op_channel = op_channel;
+		} else {
+			p2p->op_reg_class = p2p->cfg->op_reg_class;
+			p2p->op_channel = p2p->cfg->op_channel;
+		}
 
-/**
- * p2p_prepare_channel - Select operating channel for GO Negotiation
- * @p2p: P2P module context from p2p_init()
- * @dev: Selected peer device
- * @force_freq: Forced frequency in MHz or 0 if not forced
- * @pref_freq: Preferred frequency in MHz or 0 if no preference
- * Returns: 0 on success, -1 on failure (channel not supported for P2P)
- *
- * This function is used to do initial operating channel selection for GO
- * Negotiation prior to having received peer information. The selected channel
- * may be further optimized in p2p_reselect_channel() once the peer information
- * is available.
- */
-static int p2p_prepare_channel(struct p2p_data *p2p, struct p2p_device *dev,
-			       unsigned int force_freq, unsigned int pref_freq)
-{
-	if (force_freq || pref_freq) {
-		if (p2p_prepare_channel_pref(p2p, force_freq, pref_freq) < 0)
-			return -1;
-	} else {
-		p2p_prepare_channel_best(p2p);
+		os_memcpy(&p2p->channels, &p2p->cfg->channels,
+			  sizeof(struct p2p_channels));
 	}
 	wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
 		"P2P: Own preference for operation channel: "
@@ -1224,11 +1265,6 @@
 		p2p->op_reg_class, p2p->op_channel,
 		force_freq ? " (forced)" : "");
 
-	if (force_freq)
-		dev->flags |= P2P_DEV_FORCE_FREQ;
-	else
-		dev->flags &= ~P2P_DEV_FORCE_FREQ;
-
 	return 0;
 }
 
@@ -1269,6 +1305,9 @@
 		MAC2STR(peer_addr), go_intent, MAC2STR(own_interface_addr),
 		wps_method, persistent_group, pd_before_go_neg);
 
+	if (p2p_prepare_channel(p2p, force_freq, pref_freq) < 0)
+		return -1;
+
 	dev = p2p_get_device(p2p, peer_addr);
 	if (dev == NULL || (dev->flags & P2P_DEV_PROBE_REQ_ONLY)) {
 		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
@@ -1277,9 +1316,6 @@
 		return -1;
 	}
 
-	if (p2p_prepare_channel(p2p, dev, force_freq, pref_freq) < 0)
-		return -1;
-
 	if (dev->flags & P2P_DEV_GROUP_CLIENT_ONLY) {
 		if (!(dev->info.dev_capab &
 		      P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY)) {
@@ -1347,6 +1383,11 @@
 	dev->wps_method = wps_method;
 	dev->status = P2P_SC_SUCCESS;
 
+	if (force_freq)
+		dev->flags |= P2P_DEV_FORCE_FREQ;
+	else
+		dev->flags &= ~P2P_DEV_FORCE_FREQ;
+
 	if (p2p->p2p_scan_running) {
 		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
 			"P2P: p2p_scan running - delay connect send");
@@ -1376,6 +1417,9 @@
 		MAC2STR(peer_addr), go_intent, MAC2STR(own_interface_addr),
 		wps_method, persistent_group);
 
+	if (p2p_prepare_channel(p2p, force_freq, pref_freq) < 0)
+		return -1;
+
 	dev = p2p_get_device(p2p, peer_addr);
 	if (dev == NULL) {
 		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
@@ -1384,9 +1428,6 @@
 		return -1;
 	}
 
-	if (p2p_prepare_channel(p2p, dev, force_freq, pref_freq) < 0)
-		return -1;
-
 	p2p->ssid_set = 0;
 	if (force_ssid) {
 		wpa_hexdump_ascii(MSG_DEBUG, "P2P: Forced SSID",
@@ -1407,6 +1448,11 @@
 	dev->wps_method = wps_method;
 	dev->status = P2P_SC_SUCCESS;
 
+	if (force_freq)
+		dev->flags |= P2P_DEV_FORCE_FREQ;
+	else
+		dev->flags &= ~P2P_DEV_FORCE_FREQ;
+
 	return 0;
 }
 
@@ -2375,7 +2421,16 @@
 			p2p->cfg->num_pref_chan = 0;
 	}
 
+#ifdef ANDROID_P2P
+	/* 100ms listen time is too less to receive the response frames in some scenarios
+	 * increasing min listen time to 200ms.
+	 */
+	p2p->min_disc_int = 2;
+	/* SD_FAIR_POLICY: Initializing the SD current serviced pointer to NULL */
+	p2p->sd_dev_list = NULL;
+#else
 	p2p->min_disc_int = 1;
+#endif
 	p2p->max_disc_int = 3;
 	p2p->max_disc_tu = -1;
 
@@ -2444,6 +2499,10 @@
 		dl_list_del(&dev->list);
 		p2p_device_free(p2p, dev);
 	}
+#ifdef ANDROID_P2P
+	/* SD_FAIR_POLICY: Initializing the SD current serviced pointer to NULL */
+	p2p->sd_dev_list = NULL;
+#endif
 	p2p_free_sd_queries(p2p);
 	os_free(p2p->after_scan_tx);
 	p2p->after_scan_tx = NULL;
@@ -2622,8 +2681,37 @@
 void p2p_continue_find(struct p2p_data *p2p)
 {
 	struct p2p_device *dev;
+#ifdef ANDROID_P2P
+	int skip=1;
+#endif
 	p2p_set_state(p2p, P2P_SEARCH);
 	dl_list_for_each(dev, &p2p->devices, struct p2p_device, list) {
+#ifdef ANDROID_P2P
+		/* SD_FAIR_POLICY: We need to give chance to all devices in the device list
+		 * There may be a scenario, where a particular peer device have
+		 * not registered any query response. When we send a SD request to such device,
+		 * no response will be received. And if we continue to get probe responses from that device,
+		 * and if that device happens to be on top in our device list,
+		 * we will always continue to send SD requests always to that peer only.
+		 * We will not be able to send SD requests to other devices in that case.
+		 * This implementation keeps track of last serviced peer device.
+		 * And then takes the next one from the device list, in the next iteration.
+		 */
+		if (p2p->sd_dev_list && p2p->sd_dev_list != &p2p->devices) {
+			if(skip) {
+				if ((&dev->list == p2p->sd_dev_list) ) {
+					skip = 0;
+					if (dev->list.next == &p2p->devices)
+						p2p->sd_dev_list = NULL;
+				}
+				continue;
+			}
+		}
+		p2p->sd_dev_list = &dev->list;
+		wpa_printf(MSG_DEBUG, "P2P: ### Servicing %p dev->flags 0x%x SD schedule %s devaddr " MACSTR,
+			p2p->sd_dev_list, dev->flags, dev->flags & P2P_DEV_SD_SCHEDULE ? "TRUE": "FALSE",
+			MAC2STR(dev->info.p2p_device_addr));
+#endif
 		if (dev->flags & P2P_DEV_SD_SCHEDULE) {
 			if (p2p_start_sd(p2p, dev) == 0)
 				return;
@@ -2738,7 +2826,11 @@
 			p2p_continue_find(p2p);
 		else if (p2p->user_initiated_pd) {
 			p2p->pending_action_state = P2P_PENDING_PD;
+#ifdef ANDROID_P2P
+			p2p_set_timeout(p2p, 0, 350000);
+#else
 			p2p_set_timeout(p2p, 0, 300000);
+#endif
 		}
 		return;
 	}
@@ -2755,7 +2847,11 @@
 	/* Wait for response from the peer */
 	if (p2p->state == P2P_SEARCH)
 		p2p_set_state(p2p, P2P_PD_DURING_FIND);
+#ifdef ANDROID_P2P
+	p2p_set_timeout(p2p, 0, 350000);
+#else
 	p2p_set_timeout(p2p, 0, 200000);
+#endif
 }
 
 
@@ -2871,7 +2967,11 @@
 	 * channel.
 	 */
 	p2p_set_state(p2p, P2P_CONNECT);
+#ifdef ANDROID_P2P
+	p2p_set_timeout(p2p, 0, 350000);
+#else
 	p2p_set_timeout(p2p, 0, success ? 200000 : 100000);
+#endif
 }
 
 
@@ -2887,7 +2987,11 @@
 		return;
 	}
 	p2p_set_state(p2p, P2P_CONNECT);
+#ifdef ANDROID_P2P
+	p2p_set_timeout(p2p, 0, 350000);
+#else
 	p2p_set_timeout(p2p, 0, 250000);
+#endif
 }
 
 
@@ -3101,14 +3205,6 @@
 static void p2p_timeout_connect(struct p2p_data *p2p)
 {
 	p2p->cfg->send_action_done(p2p->cfg->cb_ctx);
-	if (p2p->go_neg_peer &&
-	    (p2p->go_neg_peer->flags & P2P_DEV_WAIT_GO_NEG_CONFIRM)) {
-		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG, "P2P: Wait for GO "
-			"Negotiation Confirm timed out - assume GO "
-			"Negotiation failed");
-		p2p_go_neg_failed(p2p, p2p->go_neg_peer, -1);
-		return;
-	}
 	p2p_set_state(p2p, P2P_CONNECT_LISTEN);
 	p2p_listen_in_find(p2p, 0);
 }
@@ -4149,6 +4245,15 @@
 	return &dev->info;
 }
 
+#ifdef ANDROID_P2P
+int p2p_search_in_progress(struct p2p_data *p2p)
+{
+	if (p2p == NULL)
+		return 0;
+
+	return p2p->state == P2P_SEARCH;
+}
+#endif
 
 int p2p_in_progress(struct p2p_data *p2p)
 {
diff -Nur hostapd-2.0/src/p2p/p2p_go_neg.c hostapd-2.0-TI/src/p2p/p2p_go_neg.c
--- hostapd-2.0/src/p2p/p2p_go_neg.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/p2p/p2p_go_neg.c	2014-03-28 17:49:34.000000000 +0800
@@ -336,17 +336,6 @@
 }
 
 
-/**
- * p2p_reselect_channel - Re-select operating channel based on peer information
- * @p2p: P2P module context from p2p_init()
- * @intersection: Support channel list intersection from local and peer
- *
- * This function is used to re-select the best channel after having received
- * information from the peer to allow supported channel lists to be intersected.
- * This can be used to improve initial channel selection done in
- * p2p_prepare_channel() prior to the start of GO Negotiation. In addition, this
- * can be used for Invitation case.
- */
 void p2p_reselect_channel(struct p2p_data *p2p,
 			  struct p2p_channels *intersection)
 {
@@ -355,6 +344,10 @@
 	u8 op_reg_class, op_channel;
 	unsigned int i;
 
+	wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG, "P2P: Selected operating "
+		"channel (reg_class %u channel %u) not acceptable to the "
+		"peer", p2p->op_reg_class, p2p->op_channel);
+
 	/* First, try to pick the best channel from another band */
 	freq = p2p_channel_to_freq(p2p->cfg->country, p2p->op_reg_class,
 				   p2p->op_channel);
@@ -421,7 +414,7 @@
 				  p2p->op_channel)) {
 		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
 			"P2P: Using original operating class and channel "
-			"(op_class %u channel %u) from intersection",
+			"(reg_class %u channel %u) from intersection",
 			p2p->op_reg_class, p2p->op_channel);
 		return;
 	}
@@ -439,60 +432,6 @@
 }
 
 
-static int p2p_go_select_channel(struct p2p_data *p2p, struct p2p_device *dev,
-				 u8 *status)
-{
-	struct p2p_channels intersection;
-	size_t i;
-
-	p2p_channels_intersect(&p2p->channels, &dev->channels, &intersection);
-	if (intersection.reg_classes == 0 ||
-	    intersection.reg_class[0].channels == 0) {
-		*status = P2P_SC_FAIL_NO_COMMON_CHANNELS;
-		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
-			"P2P: No common channels found");
-		return -1;
-	}
-
-	for (i = 0; i < intersection.reg_classes; i++) {
-		struct p2p_reg_class *c;
-		c = &intersection.reg_class[i];
-		wpa_printf(MSG_DEBUG, "P2P: reg_class %u", c->reg_class);
-		wpa_hexdump(MSG_DEBUG, "P2P: channels",
-			    c->channel, c->channels);
-	}
-
-	if (!p2p_channels_includes(&intersection, p2p->op_reg_class,
-				   p2p->op_channel)) {
-		if (dev->flags & P2P_DEV_FORCE_FREQ) {
-			*status = P2P_SC_FAIL_NO_COMMON_CHANNELS;
-			wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG, "P2P: Peer does "
-				"not support the forced channel");
-			return -1;
-		}
-
-		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG, "P2P: Selected operating "
-			"channel (op_class %u channel %u) not acceptable to "
-			"the peer", p2p->op_reg_class, p2p->op_channel);
-		p2p_reselect_channel(p2p, &intersection);
-	} else if (!(dev->flags & P2P_DEV_FORCE_FREQ) &&
-		   !p2p->cfg->cfg_op_channel) {
-		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG, "P2P: Try to optimize "
-			"channel selection with peer information received; "
-			"previously selected op_class %u channel %u",
-			p2p->op_reg_class, p2p->op_channel);
-		p2p_reselect_channel(p2p, &intersection);
-	}
-
-	if (!p2p->ssid_set) {
-		p2p_build_ssid(p2p, p2p->ssid, &p2p->ssid_len);
-		p2p->ssid_set = 1;
-	}
-
-	return 0;
-}
-
-
 void p2p_process_go_neg_req(struct p2p_data *p2p, const u8 *sa,
 			    const u8 *data, size_t len, int rx_freq)
 {
@@ -648,6 +587,14 @@
 			return;
 		}
 
+		if (dev->dialog_token == msg.dialog_token) {
+			wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
+				"P2P: Do not reply since dialog token %d "
+				"was already used", msg.dialog_token);
+			p2p_parse_free(&msg);
+			return;
+		}
+
 		go = p2p_go_det(p2p->go_intent, *msg.go_intent);
 		if (go < 0) {
 			wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
@@ -709,8 +656,37 @@
 			goto fail;
 		}
 
-		if (go && p2p_go_select_channel(p2p, dev, &status) < 0)
-			goto fail;
+		if (go) {
+			struct p2p_channels intersection;
+			size_t i;
+			p2p_channels_intersect(&p2p->channels, &dev->channels,
+					       &intersection);
+			if (intersection.reg_classes == 0 ||
+			    intersection.reg_class[0].channels == 0) {
+				status = P2P_SC_FAIL_NO_COMMON_CHANNELS;
+				wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
+					"P2P: No common channels found");
+				goto fail;
+			}
+			for (i = 0; i < intersection.reg_classes; i++) {
+				struct p2p_reg_class *c;
+				c = &intersection.reg_class[i];
+				wpa_printf(MSG_DEBUG, "P2P: reg_class %u",
+					   c->reg_class);
+				wpa_hexdump(MSG_DEBUG, "P2P: channels",
+					    c->channel, c->channels);
+			}
+			if (!p2p->cfg->cfg_op_channel ||
+			    !p2p_channels_includes(&intersection,
+						   p2p->op_reg_class,
+						   p2p->op_channel))
+				p2p_reselect_channel(p2p, &intersection);
+
+			if (!p2p->ssid_set) {
+				p2p_build_ssid(p2p, p2p->ssid, &p2p->ssid_len);
+				p2p->ssid_set = 1;
+			}
+		}
 
 		dev->go_state = go ? LOCAL_GO : REMOTE_GO;
 		dev->oper_freq = p2p_channel_to_freq((const char *)
@@ -887,6 +863,7 @@
 		return;
 	}
 	dev->flags &= ~P2P_DEV_WAIT_GO_NEG_RESPONSE;
+	p2p->cfg->send_action_done(p2p->cfg->cb_ctx);
 
 	if (msg.dialog_token != dev->dialog_token) {
 		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
@@ -920,7 +897,6 @@
 				"P2P: Stop GO Negotiation attempt");
 			p2p_go_neg_failed(p2p, dev, *msg.status);
 		}
-		p2p->cfg->send_action_done(p2p->cfg->cb_ctx);
 		p2p_parse_free(&msg);
 		return;
 	}
@@ -1083,8 +1059,36 @@
 		goto fail;
 	}
 
-	if (go && p2p_go_select_channel(p2p, dev, &status) < 0)
-		goto fail;
+	if (go) {
+		struct p2p_channels intersection;
+		size_t i;
+		p2p_channels_intersect(&p2p->channels, &dev->channels,
+				       &intersection);
+		if (intersection.reg_classes == 0 ||
+		    intersection.reg_class[0].channels == 0) {
+			status = P2P_SC_FAIL_NO_COMMON_CHANNELS;
+			wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
+				"P2P: No common channels found");
+			goto fail;
+		}
+		for (i = 0; i < intersection.reg_classes; i++) {
+			struct p2p_reg_class *c;
+			c = &intersection.reg_class[i];
+			wpa_printf(MSG_DEBUG, "P2P: reg_class %u",
+				   c->reg_class);
+			wpa_hexdump(MSG_DEBUG, "P2P: channels",
+				    c->channel, c->channels);
+		}
+		if (!p2p->cfg->cfg_op_channel ||
+		    !p2p_channels_includes(&intersection, p2p->op_reg_class,
+					   p2p->op_channel))
+			p2p_reselect_channel(p2p, &intersection);
+
+		if (!p2p->ssid_set) {
+			p2p_build_ssid(p2p, p2p->ssid, &p2p->ssid_len);
+			p2p->ssid_set = 1;
+		}
+	}
 
 	p2p_set_state(p2p, P2P_GO_NEG);
 	p2p_clear_timeout(p2p);
@@ -1111,7 +1115,7 @@
 	else
 		freq = dev->listen_freq;
 	if (p2p_send_action(p2p, freq, sa, p2p->cfg->dev_addr, sa,
-			    wpabuf_head(conf), wpabuf_len(conf), 0) < 0) {
+			    wpabuf_head(conf), wpabuf_len(conf), 200) < 0) {
 		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
 			"P2P: Failed to send Action frame");
 		p2p_go_neg_failed(p2p, dev, -1);
@@ -1129,6 +1133,7 @@
 	wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
 		"P2P: Received GO Negotiation Confirm from " MACSTR,
 		MAC2STR(sa));
+	p2p->cfg->send_action_done(p2p->cfg->cb_ctx);
 	dev = p2p_get_device(p2p, sa);
 	if (dev == NULL || dev->wps_method == WPS_NOT_READY ||
 	    dev != p2p->go_neg_peer) {
diff -Nur hostapd-2.0/src/p2p/p2p_group.c hostapd-2.0-TI/src/p2p/p2p_group.c
--- hostapd-2.0/src/p2p/p2p_group.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/p2p/p2p_group.c	2014-03-28 17:49:34.000000000 +0800
@@ -944,9 +944,12 @@
 int p2p_group_is_group_id_match(struct p2p_group *group, const u8 *group_id,
 				size_t group_id_len)
 {
+	const u8 bcast[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+
 	if (group_id_len != ETH_ALEN + group->cfg->ssid_len)
 		return 0;
-	if (os_memcmp(group_id, group->p2p->cfg->dev_addr, ETH_ALEN) != 0)
+	if ((os_memcmp(group_id, group->p2p->cfg->dev_addr, ETH_ALEN) != 0) &&
+	    (os_memcmp(group_id, bcast, ETH_ALEN) != 0))
 		return 0;
 	return os_memcmp(group_id + ETH_ALEN, group->cfg->ssid,
 			 group->cfg->ssid_len) == 0;
diff -Nur hostapd-2.0/src/p2p/p2p.h hostapd-2.0-TI/src/p2p/p2p.h
--- hostapd-2.0/src/p2p/p2p.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/p2p/p2p.h	2014-03-28 17:49:34.000000000 +0800
@@ -53,6 +53,10 @@
 	WPS_NOT_READY, WPS_PIN_DISPLAY, WPS_PIN_KEYPAD, WPS_PBC
 };
 
+enum p2p_sd_action {
+	SRV_UPDATE, SRV_ADD, SRV_DEL, SRV_FLUSH
+};
+
 /**
  * struct p2p_go_neg_results - P2P Group Owner Negotiation results
  */
@@ -143,6 +147,7 @@
 enum p2p_scan_type {
 	P2P_SCAN_SOCIAL,
 	P2P_SCAN_FULL,
+	P2P_SCAN_SPECIFIC,
 	P2P_SCAN_SOCIAL_PLUS_ONE
 };
 
@@ -1022,7 +1027,11 @@
  * of the local services. This will increment the Service Update Indicator
  * value which will be used in SD Request and Response frames.
  */
+#ifdef ANDROID_P2P
+void p2p_sd_service_update(struct p2p_data *p2p, int action);
+#else
 void p2p_sd_service_update(struct p2p_data *p2p);
+#endif
 
 
 enum p2p_invite_role {
@@ -1183,7 +1192,6 @@
  * @p2p: P2P module context from p2p_init()
  * @bssid: BSSID of the scan result
  * @freq: Frequency of the channel on which the device was found in MHz
- * @age: Age of the scan result in milliseconds
  * @level: Signal level (signal strength of the received Beacon/Probe Response
  *	frame)
  * @ies: Pointer to IEs from the scan result
@@ -1725,6 +1733,22 @@
  */
 int p2p_in_progress(struct p2p_data *p2p);
 
+#ifdef ANDROID_P2P
+/**
+ * p2p_search_in_progress - Check whether a P2P SEARCH is in progress
+ * @p2p: P2P module context from p2p_init()
+ * Returns: 0 if P2P module is idle or 1 if an operation is in progress
+ */
+int p2p_search_in_progress(struct p2p_data *p2p);
+
+/**
+ * p2p_search_pending - Check whether there is a deferred P2P SEARCH
+ * @p2p: P2P module context from p2p_init()
+ * Returns: 0 if there is no deferred P2P search or 1 if there is one
+ */
+int p2p_search_pending(struct p2p_data *p2p);
+#endif
+
 /**
  * p2p_other_scan_completed - Notify completion of non-P2P scan
  * @p2p: P2P module context from p2p_init()
@@ -1780,4 +1804,9 @@
 int p2p_set_disc_int(struct p2p_data *p2p, int min_disc_int, int max_disc_int,
 		     int max_disc_tu);
 
+/**
+ * p2p_group_get_interface_addr - Get the interface address of a P2P group
+ * @group: P2P group context from p2p_group_init()
+ */
+const u8 *p2p_group_get_interface_addr(struct p2p_group *group);
 #endif /* P2P_H */
diff -Nur hostapd-2.0/src/p2p/p2p_i.h hostapd-2.0-TI/src/p2p/p2p_i.h
--- hostapd-2.0/src/p2p/p2p_i.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/p2p/p2p_i.h	2014-03-28 17:49:34.000000000 +0800
@@ -235,6 +235,14 @@
 	 */
 	struct dl_list devices;
 
+#ifdef ANDROID_P2P
+	/**
+	 * sd_dev_list - device pointer to be serviced next
+	 * for service discovery
+	 */
+	struct dl_list *sd_dev_list;
+#endif
+
 	/**
 	 * go_neg_peer - Pointer to GO Negotiation peer
 	 */
@@ -347,7 +355,12 @@
 	 * srv_update_indic - Service Update Indicator for local services
 	 */
 	u16 srv_update_indic;
-
+#ifdef ANDROID_P2P
+	/**
+	 * srv_count - Registered services count
+	 */
+	u16 srv_count;
+#endif
 	struct wpabuf *sd_resp; /* Fragmented SD response */
 	u8 sd_resp_addr[ETH_ALEN];
 	u8 sd_resp_dialog_token;
@@ -579,7 +592,6 @@
 };
 
 /* p2p_group.c */
-const u8 * p2p_group_get_interface_addr(struct p2p_group *group);
 u8 p2p_group_presence_req(struct p2p_group *group,
 			  const u8 *client_interface_addr,
 			  const u8 *noa, size_t noa_len);
diff -Nur hostapd-2.0/src/p2p/p2p_invitation.c hostapd-2.0-TI/src/p2p/p2p_invitation.c
--- hostapd-2.0/src/p2p/p2p_invitation.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/p2p/p2p_invitation.c	2014-03-28 17:49:34.000000000 +0800
@@ -176,8 +176,9 @@
 			"P2P: Invitation Request from unknown peer "
 			MACSTR, MAC2STR(sa));
 
-		if (p2p_add_device(p2p, sa, rx_freq, 0, 0, data + 1, len - 1,
-				   0)) {
+		if (p2p_add_device(p2p, sa, rx_freq, 0, 0,
+				   data + 1, len - 1, 0))
+		{
 			wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
 				"P2P: Invitation Request add device failed "
 				MACSTR, MAC2STR(sa));
@@ -506,7 +507,11 @@
 	 * channel.
 	 */
 	p2p_set_state(p2p, P2P_INVITE);
+#ifdef ANDROID_P2P
+	p2p_set_timeout(p2p, 0, 350000);
+#else
 	p2p_set_timeout(p2p, 0, 100000);
+#endif
 }
 
 
diff -Nur hostapd-2.0/src/p2p/p2p_pd.c hostapd-2.0-TI/src/p2p/p2p_pd.c
--- hostapd-2.0/src/p2p/p2p_pd.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/p2p/p2p_pd.c	2014-03-28 17:49:34.000000000 +0800
@@ -152,8 +152,9 @@
 			"P2P: Provision Discovery Request from "
 			"unknown peer " MACSTR, MAC2STR(sa));
 
-		if (p2p_add_device(p2p, sa, rx_freq, 0, 0, data + 1, len - 1,
-				   0)) {
+		if (p2p_add_device(p2p, sa, rx_freq, 0, 0,
+				   data + 1, len - 1, 0))
+		{
 			wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
 			        "P2P: Provision Discovery Request add device "
 				"failed " MACSTR, MAC2STR(sa));
@@ -380,6 +381,9 @@
 		/* TODO: use device discoverability request through GO */
 	}
 
+	dev->dialog_token++;
+	if (dev->dialog_token == 0)
+		dev->dialog_token = 1;
 	req = p2p_build_prov_disc_req(p2p, dev->dialog_token,
 				      dev->req_config_methods,
 				      join ? dev : NULL);
@@ -450,14 +454,6 @@
 	if (p2p->user_initiated_pd)
 		p2p->pd_retries = MAX_PROV_DISC_REQ_RETRIES;
 
-	/*
-	 * Assign dialog token here to use the same value in each retry within
-	 * the same PD exchange.
-	 */
-	dev->dialog_token++;
-	if (dev->dialog_token == 0)
-		dev->dialog_token = 1;
-
 	return p2p_send_prov_disc_req(p2p, dev, join, force_freq);
 }
 
diff -Nur hostapd-2.0/src/p2p/p2p_sd.c hostapd-2.0-TI/src/p2p/p2p_sd.c
--- hostapd-2.0/src/p2p/p2p_sd.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/p2p/p2p_sd.c	2014-03-28 17:49:34.000000000 +0800
@@ -451,7 +451,7 @@
 
 	if (p2p->state != P2P_SD_DURING_FIND || p2p->sd_peer == NULL ||
 	    os_memcmp(sa, p2p->sd_peer->info.p2p_device_addr, ETH_ALEN) != 0) {
-		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
+		wpa_msg(p2p->cfg->msg_ctx, MSG_ERROR,
 			"P2P: Ignore unexpected GAS Initial Response from "
 			MACSTR, MAC2STR(sa));
 		return;
@@ -886,6 +886,19 @@
 		      const struct wpabuf *tlvs)
 {
 	struct p2p_sd_query *q;
+#ifdef ANDROID_P2P
+	/* Currently, supplicant doesn't support more than one pending broadcast SD request.
+	 * So reject if application is registering another one before cancelling the existing one.
+	 */
+	for (q = p2p->sd_queries; q; q = q->next) {
+		if( (q->for_all_peers == 1) && (!dst)) {
+				wpa_printf(MSG_ERROR, "P2P: Already one pending"
+					" Broadcast request. Please cancel the current one"
+					" before adding a new one");
+				return NULL;
+		}
+	}
+#endif
 
 	q = os_zalloc(sizeof(*q));
 	if (q == NULL)
@@ -904,7 +917,7 @@
 
 	q->next = p2p->sd_queries;
 	p2p->sd_queries = q;
-	wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG, "P2P: Added SD Query %p", q);
+	wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG, "P2P: Added SD Query %p for_all_peers %d", q, q->for_all_peers);
 
 	if (dst == NULL) {
 		struct p2p_device *dev;
@@ -929,17 +942,58 @@
 #endif /* CONFIG_WIFI_DISPLAY */
 
 
+#ifdef ANDROID_P2P
+void p2p_sd_service_update(struct p2p_data *p2p, int action)
+#else
 void p2p_sd_service_update(struct p2p_data *p2p)
+#endif
 {
 	p2p->srv_update_indic++;
+#ifdef ANDROID_P2P
+	if(action == SRV_FLUSH)
+		p2p->srv_count = 0;
+	else if (action == SRV_DEL)
+		p2p->srv_count--;
+	else if (action == SRV_ADD)
+		p2p->srv_count++;
+
+	if(p2p->cfg->sd_request) {
+		if (p2p->srv_count == 1) {
+			/* First Service Registered. Enable SD capability */
+			p2p->dev_capab |= P2P_DEV_CAPAB_SERVICE_DISCOVERY;
+		} else if (p2p->srv_count == 0 && !p2p->sd_queries) {
+			/* No services remaining + No queries registered .
+			 * Remove the SD Capability 
+			 */
+			p2p->dev_capab &= ~P2P_DEV_CAPAB_SERVICE_DISCOVERY;
+		}
+	}
+#endif
 }
 
 
 int p2p_sd_cancel_request(struct p2p_data *p2p, void *req)
 {
 	if (p2p_unlink_sd_query(p2p, req)) {
+#ifdef ANDROID_P2P
+	struct p2p_device *dev;
+	struct p2p_sd_query *q = (struct p2p_sd_query *)req;
+#endif
 		wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG,
 			"P2P: Cancel pending SD query %p", req);
+#ifdef ANDROID_P2P
+		/* If the request is a bcast query, then clear the
+		 * P2P_DEV_SD_INFO flag so that when new sd query is registered,
+		 * we will send the SD request frames to peer devices.
+		 */
+		if(q->for_all_peers) {
+			p2p->sd_dev_list = NULL;
+			dl_list_for_each(dev, &p2p->devices,
+							struct p2p_device, list) {
+				dev->flags &= ~P2P_DEV_SD_INFO;
+			}
+		}
+#endif
 		p2p_free_sd_query(req);
 		return 0;
 	}
diff -Nur hostapd-2.0/src/rsn_supp/wpa.c hostapd-2.0-TI/src/rsn_supp/wpa.c
--- hostapd-2.0/src/rsn_supp/wpa.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/rsn_supp/wpa.c	2014-03-28 17:49:32.000000000 +0800
@@ -2627,7 +2627,7 @@
 }
 
 
-#ifdef CONFIG_WNM
+#ifdef CONFIG_IEEE80211V
 int wpa_wnmsleep_install_key(struct wpa_sm *sm, u8 subelem_id, u8 *buf)
 {
 	struct wpa_gtk_data gd;
@@ -2637,6 +2637,7 @@
 #endif /* CONFIG_IEEE80211W */
 	u16 keyinfo;
 	u8 keylen;  /* plaintext key len */
+	u8 keydatalen;
 	u8 *key_rsc;
 
 	os_memset(&gd, 0, sizeof(gd));
@@ -2654,7 +2655,8 @@
 
 	if (subelem_id == WNM_SLEEP_SUBELEM_GTK) {
 		key_rsc = buf + 5;
-		keyinfo = WPA_GET_LE16(buf + 2);
+		keyinfo = WPA_GET_LE16(buf+2);
+		keydatalen = buf[1] - 11 - 8;
 		gd.gtk_len = keylen;
 		if (gd.gtk_len != buf[4]) {
 			wpa_printf(MSG_DEBUG, "GTK len mismatch len %d vs %d",
@@ -2665,7 +2667,18 @@
 		gd.tx = wpa_supplicant_gtk_tx_bit_workaround(
 		         sm, !!(keyinfo & WPA_KEY_INFO_TXRX));
 
-		os_memcpy(gd.gtk, buf + 13, gd.gtk_len);
+		if (keydatalen % 8) {
+			wpa_printf(MSG_DEBUG, "WPA: Unsupported AES-WRAP len "
+				   "%d", keydatalen);
+			return -1;
+		}
+
+		if (aes_unwrap(sm->ptk.kek, keydatalen / 8, buf + 13, gd.gtk))
+		{
+			wpa_printf(MSG_WARNING, "WNM: AES unwrap failed - "
+				   "could not decrypt GTK");
+			return -1;
+		}
 
 		wpa_hexdump_key(MSG_DEBUG, "Install GTK (WNM SLEEP)",
 				gd.gtk, gd.gtk_len);
@@ -2676,11 +2689,22 @@
 		}
 #ifdef CONFIG_IEEE80211W
 	} else if (subelem_id == WNM_SLEEP_SUBELEM_IGTK) {
+		if (buf[1] != 2 + 6 + WPA_IGTK_LEN + 8) {
+			wpa_printf(MSG_DEBUG, "WPA: Unsupported AES-WRAP len "
+				   "%d", buf[1] - 2 - 6 - 8);
+			return -1;
+		}
 		os_memcpy(igd.keyid, buf + 2, 2);
 		os_memcpy(igd.pn, buf + 4, 6);
 
 		keyidx = WPA_GET_LE16(igd.keyid);
-		os_memcpy(igd.igtk, buf + 10, WPA_IGTK_LEN);
+
+		if (aes_unwrap(sm->ptk.kek, WPA_IGTK_LEN / 8, buf + 10,
+			       igd.igtk)) {
+			wpa_printf(MSG_WARNING, "WNM: AES unwrap failed - "
+				   "could not decrypr IGTK");
+			return -1;
+		}
 
 		wpa_hexdump_key(MSG_DEBUG, "Install IGTK (WNM SLEEP)",
 				igd.igtk, WPA_IGTK_LEN);
@@ -2699,4 +2723,4 @@
 
 	return 0;
 }
-#endif /* CONFIG_WNM */
+#endif /* CONFIG_IEEE80211V */
diff -Nur hostapd-2.0/src/rsn_supp/wpa.h hostapd-2.0-TI/src/rsn_supp/wpa.h
--- hostapd-2.0/src/rsn_supp/wpa.h	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/rsn_supp/wpa.h	2014-03-28 17:49:32.000000000 +0800
@@ -365,6 +365,8 @@
 void wpa_tdls_disable_link(struct wpa_sm *sm, const u8 *addr);
 int wpa_tdls_is_external_setup(struct wpa_sm *sm);
 
+#ifdef CONFIG_IEEE80211V
 int wpa_wnmsleep_install_key(struct wpa_sm *sm, u8 subelem_id, u8 *buf);
+#endif /* CONFIG_IEEE80211V */
 
 #endif /* WPA_H */
diff -Nur hostapd-2.0/src/utils/common.c hostapd-2.0-TI/src/utils/common.c
--- hostapd-2.0/src/utils/common.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/utils/common.c	2014-03-28 17:49:34.000000000 +0800
@@ -379,12 +379,16 @@
 			*txt++ = 't';
 			break;
 		default:
+#ifdef WPA_UNICODE_SSID
+			*txt++ = data[i];
+#else
 			if (data[i] >= 32 && data[i] <= 127) {
 				*txt++ = data[i];
 			} else {
 				txt += os_snprintf(txt, end - txt, "\\x%02x",
 						   data[i]);
 			}
+#endif /* WPA_UNICODE_SSID */
 			break;
 		}
 	}
diff -Nur hostapd-2.0/src/wps/wps_registrar.c hostapd-2.0-TI/src/wps/wps_registrar.c
--- hostapd-2.0/src/wps/wps_registrar.c	2013-01-12 23:42:53.000000000 +0800
+++ hostapd-2.0-TI/src/wps/wps_registrar.c	2014-03-28 17:49:32.000000000 +0800
@@ -366,8 +366,13 @@
 	pbc = reg->pbc_sessions;
 	while (pbc) {
 		if (os_memcmp(pbc->uuid_e, uuid_e, WPS_UUID_LEN) == 0 ||
+#ifdef ANDROID_P2P
+		    (p2p_dev_addr && !is_zero_ether_addr(pbc->addr) &&
+		     os_memcmp(pbc->addr, p2p_dev_addr, ETH_ALEN) ==
+#else
 		    (p2p_dev_addr && !is_zero_ether_addr(reg->p2p_dev_addr) &&
 		     os_memcmp(reg->p2p_dev_addr, p2p_dev_addr, ETH_ALEN) ==
+#endif
 		     0)) {
 			if (prev)
 				prev->next = pbc->next;
@@ -1293,7 +1298,7 @@
 	    wps_build_uuid_e(probe, reg->wps->uuid) ||
 	    wps_build_device_attrs(&reg->wps->dev, probe) ||
 	    wps_build_probe_config_methods(reg, probe) ||
-	    (reg->dualband && wps_build_rf_bands(&reg->wps->dev, probe)) ||
+	    wps_build_rf_bands(&reg->wps->dev, probe) ||
 	    wps_build_wfa_ext(probe, 0, auth_macs, count) ||
 	    wps_build_vendor_ext(&reg->wps->dev, probe)) {
 		wpabuf_free(beacon);
